<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Redis数据一致性分析]]></title>
      <url>http://baobing.github.io/2017/12/23/Redis/Redis%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h1><p>Redis是一款优秀的分布式缓存中间件。当然它能胜任的工作还有很多，比如说队列、分布式锁、Key-Value数据库。Redis的优秀毋庸置疑，但是他有明显的短板，那就是<strong><em>无法保证数据的强一致性</em></strong>。如果你对数据一致性要求不高，完全可以考虑使用Redis存放一些业务数据。接下来我将列举一些Redis的优势,最后再聊聊Redis数据一致性。<br><a id="more"></a></p>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><h3 id="定制化的数据结构"><a href="#定制化的数据结构" class="headerlink" title="定制化的数据结构"></a>定制化的数据结构</h3><p><strong>字符串(SDS)</strong>：</p>
<ul>
<li>保存字符串长度，O(1)复杂度查询长度；</li>
<li>字符串操作拼接操作不会带来数组越界异常；</li>
<li>修改字符串不需要重新分配内存空间；</li>
<li>可以保存二进制数据;</li>
</ul>
<p><strong>跳跃表(skip list)</strong>：顺序链表。实现简单，查找快速，平均操作复杂度O(logN)。<br><strong>字典(dict)</strong>：等同于Map。渐进式Rehash。优雅地实现扩容，减少扩容带来的阻塞。<br><strong>压缩列表(ziplist)</strong>：使用二进制方式保存字符串和整数，节省内存。</p>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>Redis根据操作系统的选择合适的IO模型，其中最让人称道的是Epoll支撑下的事件驱动模型(Reactor模型)。Epoll可以支持大量的链接（理论上线是INT类型的最大值），并O(1)复杂度通知用户IO事件。这两点为Redis高并发打下了坚实的基础。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>Redis的操作都是线程安全的，大部分用户操作都是原子的。原因很简单，Redis是单线程模型。即使不得不在其他线程完成的工作(比如说RDB、AOF重写)，它选择使用子进程进行处理（子进程拷贝父进程数据），</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>Redis3.0之后提供Redis Cluster功能，配合redis-trib工具，使用者可以轻松搭建一个Redis集群。Redis集群支持动态扩容缩容，支持主从互备，支持自动地故障转移。</p>
<h1 id="数据一致性分析"><a href="#数据一致性分析" class="headerlink" title="数据一致性分析"></a>数据一致性分析</h1><p>数据一致性，Redis要么明确告知客户端请求失败，要么正确响应客户端请求并且持久化结果。需要</p>
<h2 id="单机持久化"><a href="#单机持久化" class="headerlink" title="单机持久化"></a>单机持久化</h2><p>Redis提供两种持久化方式分别是：RDB和AOF。需要说明的一点是<strong><em>写入文件并不代表持久化成功，还需要将文件同步到磁盘。</em></strong></p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB指的是Redis将内存中的所有数据持久化到磁盘。这就注定RDB只能在一定间隔的情况执行。我们可以通过配置间隔固定的时间或者固定次数的修改后进行持久化。当然我们也可以通过执行SAVE或者BGSAVE显示的持久化数据。显而易见，以上方式总是无法避免最新的数据无法持久化。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF指的是Redis记录所有的写操作命令，并且持久化。AOF持久化有三个级别</p>
<ul>
<li><strong>no</strong>AOF文件同步交给操作系统决定;</li>
<li><strong>everysec</strong>每隔一秒执行一次文件同步；</li>
<li><strong>always</strong>写入文件立即同步。</li>
</ul>
<p>虽然always级别最消耗性能，但是他似乎能够保证数据的一致性。不幸的是，这样也不能保证数据绝对的一致性。原因如下：<br>1.无法以事务的形式写AOF文件和执行写操作。一旦机器在写AOF文件和执行写操作中间的某一时刻崩溃，都会导致数据的不一致性。Mysql使用二阶段提交解决这个问题<br>2.文件同步到磁盘过程并非原子操作。mysql同步两次写解决这个问题。</p>
<h2 id="主从数据一致性"><a href="#主从数据一致性" class="headerlink" title="主从数据一致性"></a>主从数据一致性</h2><p>Redis支持主从互备，自动地故障转移。如果主从之间能够保证数据一致性，那我们也不需要担心持久化造成的数据不一致。不幸的是主从互备并不能保证数据一致性。</p>
<ol>
<li>宕机。虽然多台机器同时宕机的概率极低，当时我们不能忽略这种可能(墨菲定律)。</li>
<li>网络故障。主服务器主动将所有写操作发给从服务器。出现网络通信不畅，就会出现主从不同步。即使网络恢复正常，主服务器也不会将从服务器未接收到的命令发给从服务器。Mysql主从通过从服务器发送确认信号的方式确保主从一致。</li>
<li>过期Key。从服务器不会主动删除过期Key。即使我们访问从服务期的过期Key，从服务器还是不会删除过期Key或者返回空，而是将过期key返回给客户端。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Rdis一款优秀的缓存中间件。Redis的短板在于它无法保证数据的强一致性。如果您的业务场景对数据一致性要求很高，请不要把Redis当做DB使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[InnoDB存储引擎5-索引与算法]]></title>
      <url>http://baobing.github.io/2016/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E5-%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="InnoDB存储引擎索引概述"><a href="#InnoDB存储引擎索引概述" class="headerlink" title="InnoDB存储引擎索引概述"></a>InnoDB存储引擎索引概述</h1><p>InnoDB常见索引B+树索引、全文索引、哈希索引。<br>B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页，然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p>PageDiretory中槽是按照主键顺序存放的，对于某一条具体记录的查询是通过page directory进行二分查找得到的。（我怀疑B+树也用到了二分查找法）。</p>
<h1 id="二叉查找树和平衡二叉树"><a href="#二叉查找树和平衡二叉树" class="headerlink" title="二叉查找树和平衡二叉树"></a>二叉查找树和平衡二叉树</h1><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h2><img src="/2016/11/23/数据库/InnoDB存储引擎5-索引与算法/5-1.png">
<p>##Ｂ＋树的删除操作<br><img src="/2016/11/23/数据库/InnoDB存储引擎5-索引与算法/5-2.png"></p>
<h1 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h1><p>B+索引在数据库中有一个特点是搞扇出性，因此在数据库中，B+树的高度一般都是2~4层，这也就是说查找某一简直的行记录时最多只需要2到4次IO。当前一般的机械磁盘每秒至少可以做10次IO。数据库中B+树索引分为聚集索引和辅助索引。</p>
<p>##　聚集索引<br>InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。<br><img src="/2016/11/23/数据库/InnoDB存储引擎5-索引与算法/5-14.png"></p>
<h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><p>对于辅助索引，叶子节点并不含行记录的全部数据。叶子节点除了包含键值意外，每个叶子节点中的索引行中还包含了一个书签。该书签来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据</p>
<img src="/2016/11/23/数据库/InnoDB存储引擎5-索引与算法/5-16.png">
<h2 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h2><h2 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名称 add  index|key 索引名 （列名，）</span><br><span class="line">alter table 表名称 drop  index|key 索引名 </span><br><span class="line">create/drop index  on 表名称</span><br></pre></td></tr></table></figure>
<p>Show Index from</p>
<h3 id="Fast-Index-Creation"><a href="#Fast-Index-Creation" class="headerlink" title="Fast Index Creation"></a>Fast Index Creation</h3><p>Mysql5.5版本之前，DDL操作过程：</p>
<ul>
<li>首先创建一张新的临时表，表结构为通过命令alter table 新定义的结构。</li>
<li>然后把原表中数据导入到临时表</li>
<li>删除原表 更换表名<br>InnoDB1.0开始支持     一种称为fast index creation的索引创建方式。索引创建时会阻塞表上的DML操作。<br>对于辅助索引，会对表加上一个s锁。不用重建表，因次速度快很多。删除富足索引操作就更简单了，InnoDB存储引擎只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除mysql数据库内部视图上对该表的索引定义即可。<br>FIC常见过程对表上了S锁，因此只能对该表进行读操作，只限定于辅助索引，对于主键的创建和删除同样要创建新表。<h3 id="Online-Schema-Change"><a href="#Online-Schema-Change" class="headerlink" title="Online Schema Change"></a>Online Schema Change</h3>最早由facebook实现的一种在线执行ddl的方式。可以有读写事务对表进行DDL操作。<br>OSC是一个php脚本，因此其有一定的局限性。进行修改的表一定要有主键，且表本身不能存在外键和触发器。此外，允许set sql_bin_log = 0,因此所做的操作不会同步slave服务器，可能导致主从不一致的情况。<h2 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h2>Mysql 5.6开始支持Online DDL。允许辅助索引创建的同事进行诸如Insert、update、delete这类DML操作。此外逼近是辅助索引，以下DDL操作都可以通过在线的方式进行操作 </li>
<li>改变自增长值</li>
<li>天剑或删除外键约束</li>
<li>列的重命名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 新的alter table</span><br><span class="line">alter table tbl_name Add index index_name (index_col_name)</span><br><span class="line">algorithm = &#123;default|inplace|copy&#125; lock = &#123;default|none|shared|exclusive&#125;</span><br></pre></td></tr></table></figure>
<p>algorithm 指定创建和删除索引的算法，cpoy表示按照mysql5.1版本之前的工作模式，即创建临时表的方式。inplace表示不需要创建临时表。default表示根据参数old_alter_table来判断，该参数默认值为off，表示采用inplace的方式。</p>
<p>lock部分为索引创建或删除时对表添加锁的情况，已有的选择为：</p>
<ul>
<li>none：对目标表不添加任何锁</li>
<li>share：和fic类似，对目标表加上一个s锁</li>
<li>exclusive：对目标添加一个x锁</li>
<li>default：一次尝试none、share、exclusive模式</li>
</ul>
<p>Online DDL的原理是在执行创建或者删除操作的同事，将insert、update、delete这类dml操作日志写入到一个缓存中，待完成索引创建后再将重做应用到表上，一次达到数据的一致性。<br>由于Online DDL在创建索引完成后再通过重做日志达到数据库的最终一致性，这意味着在索引创建过程中，sql优化器不会选择正在创建中的索引。</p>
<h1 id="5-5-Cardinality"><a href="#5-5-Cardinality" class="headerlink" title="5.5 Cardinality"></a>5.5 Cardinality</h1><p>cardinality表示索引中不重复记录数量的预估值。cardinality/表中行数应尽可能的接近1。</p>
<p>##InnoDB存储引擎的cardinality统计<br>innoDB内部更新cardinality信息的策略为</p>
<ul>
<li>表中十六之一的数据发生过变化</li>
<li>sta_modified_counter&gt;2 000 000 000<br>默认InnoDB存储引擎对8个叶子节点进行采样，采样的过程如下：</li>
<li>取得B+树索引中叶子节点的数量，记为A-</li>
<li>随机去个B+树索引中的8个叶子节点，统计每个页不同记录的个数，记为P1，P2…P8</li>
<li>根据采样信息给出cardinality的预估值<br>当执行sql语句analyze table show table status、showindex 一集访问information_schema架构下的表tables和statistics会导致存储引擎重新计算索引的cardinality。P214<h1 id="5-6-B-树索引的使用"><a href="#5-6-B-树索引的使用" class="headerlink" title="5.6 B+树索引的使用"></a>5.6 B+树索引的使用</h1><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><h2 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h2>没有命中覆盖索引，并且查询的数据量大于表的20%，优化器会选择聚集索引来查找数据。因此对于不能进行索引覆盖的情况，优化器选择辅助索引的情况是，通过辅助所以呢查找的数据是少量的。利用顺序读来替换随机读的查找<h2 id="索引提示-index-hint"><a href="#索引提示-index-hint" class="headerlink" title="索引提示 index hint"></a>索引提示 index hint</h2>use index 只是告诉优化器可以选择该索引，实际上优化器还是胡再根据自己判断进行选择。如果使用 force index 一定会使用索引。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * form t use index(a) where a =1 and b = 2;</span><br><span class="line">select * form t force index(a) where a =1 and b = 2;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h2><p>Mysql5.6版本开始支持。<br>对于InnoDB和MyISAM存储引擎的范围查询和Join查询操作，MRR的工作方式如下：</p>
<ul>
<li>将查询得到的辅助索引键值存放于一个缓存中，这是缓存中的数据是根据辅助索引键值排序的。</li>
<li>将缓存中的键值根据RowID进行排序。</li>
<li>根据rowID的排序顺序来访问实际的数据文件<br>MRR 优化有一下几个好处</li>
<li>MRR使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键顺序进行书签查找。</li>
<li>减少缓冲池中页被替换的次数</li>
<li>批量处理对键值的操作</li>
</ul>
<h2 id="Index-condition-pushdown-优化-P226"><a href="#Index-condition-pushdown-优化-P226" class="headerlink" title="Index condition pushdown 优化 P226"></a>Index condition pushdown 优化 P226</h2><p>Mysql5.6开始支持。之前当进行索引查找时，首先根据索引来查找记录，然后再根据where条件过滤记录。ICP判断是够可以进行where条件的过滤，也就是将where的部分过滤操作放在存储引擎层。</p>
<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><h2 id="InnoDB存储引擎中哈希算法"><a href="#InnoDB存储引擎中哈希算法" class="headerlink" title="InnoDB存储引擎中哈希算法"></a>InnoDB存储引擎中哈希算法</h2><p>自适应hash索引想问见第二章</p>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>全文检索通常使用代拍索引来实现。它在辅助表中存储了单次与单词自身在一个或多个文档中位置之间的映射。</p>
<ul>
<li>inverted file index ，表现形式为{单次，单次所在文档的id}</li>
<li>full inverted index，其变现形式为{单次，（单次所在文档的id，在具体文档中的位置）}<img src="/2016/11/23/数据库/InnoDB存储引擎5-索引与算法/5-6.png">
<img src="/2016/11/23/数据库/InnoDB存储引擎5-索引与算法/5-7.png">
</li>
</ul>
<h2 id="InnoDB全文检索"><a href="#InnoDB全文检索" class="headerlink" title="InnoDB全文检索"></a>InnoDB全文检索</h2><p>innoDB存储引擎从1.2开始支持全文检索的技术。InnoDB中环将（documentID，Position）视为一个“ilist”。因此在全文检索表中，有两个列，一个是word字段，另一个是ilist字段，并且在word字段上有索引。此外，由于InnoDB在ilist字段中存放了position信息，故可以进行proximity search。InnoDB会批量对Auxiliary  table进行更新，而不是每次插入后更新一次。查询是，首先将FTS index cache 中对应的word字段合并到 辅助表中，然后再进行查询。这个merge操作类似Inser buffer的功能，不同的是 inser buffer 是一个持久的兑现个，并且其是B+树结构。FTS index cache由红黑树排序后批量插入。<br>当数据库关闭时，cache中的数据会通过到磁盘的辅助表中，然而，数据库发生宕机时，未能将cache同步到磁盘上。那么下次重启数据库时，当用户对表进行全文检索时，InnoDB存储引擎会自动读取未完成的文档，然后进行分词操作，在激情分词的结果放入到FTS index cache。<br>innoDB存储引擎中，为了支持全文检索，必须有一个列和word进行映射，这个列被命名为为fts_doc_id,类型必须是 bigint unsigned not null，必须加 unique index。上述这些操作都会有innoDB存储引擎自己完成</p>
<p>InnoDB全文检索存在的限制</p>
<ul>
<li>每张表只能有一个全文检索的索引</li>
<li>由多列组合而成的全文检索索引列必须使用相同的字符集和排序规则</li>
<li>不支持没有单次界定符的预先 如 中文、 日语、韩语。<br><strong><em>不支持中文 还研究个毛</em></strong></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[InnoDB存储引擎4-表]]></title>
      <url>http://baobing.github.io/2016/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E4-%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h1><p>InnoDB中，表都是根据主键顺序组织存放的，这种存放方式的表称为索引组织表。<br>在InnoDB存储引擎表中，每张表都有个主键，如果没有InnoDB回按如下的方式选择或创建主键：</p>
<ul>
<li>首先判断表中是否有非空的唯一索引，如果有，则该列即为主键。主键选择更具定义索引的顺序，而不是建表时列的顺序。</li>
<li>如果不符合上述条件，InnoSB存储引擎自动创建一个6字节大小的指针。<h1 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h1>表空间由段（segment）、区（extent）、页（page）。<h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2>常见的段有数据段、索引段、回滚段<h2 id="区"><a href="#区" class="headerlink" title="区"></a>区</h2>区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4~5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。创建表的默认大小是96KB。其实这是因为在这个段开始时，先用32个页大小的碎片页来存放数据，在使用完这些页之后，才是64个连续页的申请。这样做的目的是，对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。<h2 id="页"><a href="#页" class="headerlink" title="页"></a>页</h2>在InnoDB存储中，默认每个页的大小为16KB。而从1.2开始，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。设置完成，则所有表中页的大小都为innodb_pae_siez，不可以对其再次进行修改。除非通过mysqldump导入和导出操作来产生新的库。<br>InnoDB常见页类型：</li>
<li>数据页</li>
<li>undo页</li>
<li>系统页</li>
<li>事务数据页</li>
<li>插入缓冲位图页</li>
<li>插入缓冲空闲列表页</li>
<li>未压缩的二进制大对象页</li>
<li>压缩二进制大对象页<h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2>每个页最多存放16KB/2-200行的记录，即7992行记录<h1 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h1>可以通过 show table status like ‘table_name’ 查看表行存储格式的信息。<h2 id="Compact行记录格式-P105"><a href="#Compact行记录格式-P105" class="headerlink" title="Compact行记录格式 P105"></a>Compact行记录格式 P105</h2>Mysql5.0中引入。一个页中存放行数据越多，其性能就越高。<img src="/2016/11/23/数据库/InnoDB存储引擎4-表/4-2.png">
编程字段长度列表：长度小于255用一个字节，最大65535。<br>Null标志位用二进制表示为Null的列<br>记录头<img src="/2016/11/23/数据库/InnoDB存储引擎4-表/4-1.png">
没行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节的大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。<h1 id="Redumdant行记录格式"><a href="#Redumdant行记录格式" class="headerlink" title="Redumdant行记录格式"></a>Redumdant行记录格式</h1>Mysql5.0版本记录存储方式<h2 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h2>BlOB、TEXT可以不讲数据放在溢出页面，而且即便是Varchar列数据类型，依然有可能被存放为行溢出数据。<br>Varchar类型的最大长度65532.Varchar（N）中的N指的是字符的长度。而文档中说明Varchar类型最大支持65535，单位是字节。Mysql官方手册中定义的65535长度是指所有Varchar列的长度总和，如果列的长度总和超出这个长度，依然无法创建。<br>InnoDB存储引擎表是索引组织的，即B+Tree的结构，这样每个页中至少应该有两条行记录。Varchar不溢出的最大长度是8098字节。<br>数据保存再BLOB页中，数据页只保存数据的钱768字节。<h2 id="Compressed和Dynamic行记录格式"><a href="#Compressed和Dynamic行记录格式" class="headerlink" title="Compressed和Dynamic行记录格式"></a>Compressed和Dynamic行记录格式</h2>以前支持的compact和redundant格式称为antelope文件格式，新的文件格式称为Barracuda文件格式。Barracuda文件格式下拥有两种新的行记录格式：Compressed和Dynamic。<br>新的两种记录格式对于存放在BLOB中的数据采用了完全溢出的方式<h2 id="Char的行结构存储"><a href="#Char的行结构存储" class="headerlink" title="Char的行结构存储"></a>Char的行结构存储</h2>Mysql4.1版本开始，Char（N）中N指的是字符的长度，而不是之前版本的字节长度。也就说在不同的字符集下，char类型列内部存储的可能不是定长的数据。因此，对于多字节字符编码的char数据类型的存储，InnoDB在内部将其视为变长字符类型。<h1 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h1>InnoDB数据页由一下7部分组成</li>
<li>File Header 文件头</li>
<li>Page Header 页头</li>
<li>Infimum和Supremum Records</li>
<li>User Records 用户记录</li>
<li>Free Space 空闲空间</li>
<li>Page Direcory 页目录</li>
<li>File Trailer 文件结尾信息</li>
</ul>
<h2 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h2><img src="/2016/11/23/数据库/InnoDB存储引擎4-表/4-3.png">
<h2 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h2><img src="/2016/11/23/数据库/InnoDB存储引擎4-表/4-5.png">
<h2 id="Infimum和Suprenum-Record"><a href="#Infimum和Suprenum-Record" class="headerlink" title="Infimum和Suprenum Record"></a>Infimum和Suprenum Record</h2><p>在InnoDB存储引擎中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。Innfimum记录是比该页中任何主键都要小的值，Supremum指比任何可能大的值还要大的值。这两个值都在页创建时被建立，并且在任何情况下不会被删除。</p>
<h2 id="User-Record-和-Free-Space"><a href="#User-Record-和-Free-Space" class="headerlink" title="User Record 和 Free Space"></a>User Record 和 Free Space</h2><p>User Record实际存储行记录的内容。<strong><em>InnoDB存储引擎表总是B+树索引组织的</em></strong><br>Free Space很明显指的就是空闲空间，同样也是个链表数据结构。在一条记录被删除后，该空间会被加入到空闲链表中。</p>
<h2 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h2><p>指向页内行记录的系数索引，倒序保存。同一个槽位下面的行记录用链表串联</p>
<h2 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h2><p>为了检测页已经完整写入磁盘。<br>前四个字节代表该页的checksum值，最后4个字节和FileHeader中的FIL_PAGE_LSN值进行比较。<br>InnoDB每次从磁盘读取一个页就会检测该页的完整性，即页是否发生Corrupt。</p>
<h2 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h2><p>从InnoDB1.0版本开始，通过Named File Formats机制来解决不同版本下页结构兼容的问题</p>
<p>#约束</p>
<h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>InnoDB存储引擎表中，域完整性可以通过以下几种途径来保证：</p>
<ul>
<li>选择合适的数据类型确保一个数据值满足特定条件</li>
<li>外键约束</li>
<li>编写触发器</li>
<li>还可以开率用Default约束作为强制域完整性的一个方面。默认值。<h2 id="约束创建和查找"><a href="#约束创建和查找" class="headerlink" title="约束创建和查找"></a>约束创建和查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table p (</span><br><span class="line">id int , uid int,</span><br><span class="line">primary key (id),</span><br><span class="line">foreign key (uid) references p (id);</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">select constrint_name,constrint_type from</span><br><span class="line">information_schema.table,constraints </span><br><span class="line">where table_schema = &apos;数据库名称&apos; and table_name = &apos;表名称&apos;；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set sql_mode = &apos;strict_trans_tables&apos;</span><br><span class="line">#不满足约束报错，而不是警告</span><br></pre></td></tr></table></figure>
<h1 id="Enum和set约束"><a href="#Enum和set约束" class="headerlink" title="Enum和set约束"></a>Enum和set约束</h1><p>表上有一个性别类型，规定域的范围只能是male或者female，在这种情况下用户可以通过enum进行约束。</p>
<h1 id="触发器和约束"><a href="#触发器和约束" class="headerlink" title="触发器和约束"></a>触发器和约束</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create trigger 触发器名称 before|after |insert|update|delete</span><br><span class="line">on 表名 for each row 触发器语句</span><br><span class="line"></span><br><span class="line">create trigger tgr_usercash_update before update on usercash</span><br><span class="line">for each row </span><br><span class="line">begin </span><br><span class="line">if new.cash -old.cash &gt;0 then</span><br><span class="line">    insert into usercash_error_log</span><br><span class="line">    select old.userid,old.cash,new.cash;</span><br><span class="line">    set new.cash = old.cash;</span><br><span class="line">end if;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>一般来说，成被引用表为父表，引用的表称为子表。外键定义时的 on delete 和 on update 表示在对父表进行delete和update操作时，对子表所做的操作。</p>
<ul>
<li>cascade表示 通过操作</li>
<li>set null 父表改变，子表更新为null</li>
<li>not action 抛出无措，不允许这类操作发生</li>
<li>restrict 与no action 相同。默认值<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h2>视图主要用途之一被用作一个抽闲该装置，特别是对于一些应用程序，程序本身不需要关心基表的结构，只需要按照视图定义来取数据或更新数据，因此，视图同事在一定程度上起到一个安全层的作用。<br>虽然视图是基于基表的一个虚拟表，但是用户可以对某些视图进行更新操作，其本质就是通过视图的定义来更新基本表、。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view v_t as select * form t where id &lt; 10 with check option;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>with check option 检查SQL，防止不满足视图条件的数据进入。</p>
<h2 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h2><p>Oracle对视图物化提供良好的支持。Mysql数据库本身并不支持物化视图，换句话说，Mysql数据库中的视图总是虚拟的。用户可以定时把数据导入到另一张表。触发器实现。</p>
<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><h2 id="分区概述"><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h2><p>分区功能并不是在存储u引擎曾完成的，因此不是只有InnoDB存储引擎支持分区，常见的存储引擎MyISAM、NDB等都支持。CSV、Merge等不支持<br>Mysql数据库在5.1版本添加对分区的支持，分区的过程是将一个表或者索引分解为多个更小、更可管理的部分。Mysql数据库支持水平分区，不支持垂直分区。此外，mysql数据库的分局是局部分区索引，一个分区中既存放数据又存放索引。目前不支持全局分区。<br>在OLTP应用中，对于分区的使用应该非常小心。</p>
<h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><h3 id="range分区"><a href="#range分区" class="headerlink" title="range分区"></a>range分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t( id int) engine=innodb</span><br><span class="line">partition by range(id)(</span><br><span class="line">partition p0 values less than(10),</span><br><span class="line">partition p1 values less than(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>maxvalue 代表正无穷<br>然哥分区主要用于日期列的分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table sales( mony int not null ,date datetime) engine=innodb</span><br><span class="line">partition by range(to_days(date))(</span><br><span class="line">partition p201001values less than(to_days(&apos;2010-02-01&apos;)),</span><br><span class="line">partition p201002values less than(to_days(&apos;2010-02-02&apos;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>explain partition 查看语句分区使用情况。<br>range分区查询，优化器只能对year，to_days,.to_seconds,unix_timestamp这类函数进行优化选择。</p>
<h3 id="List分区"><a href="#List分区" class="headerlink" title="List分区"></a>List分区</h3><p>list分区与range相似，只是分区列的值是离散的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t( id int) engine=innodb</span><br><span class="line">partition by list(id)(</span><br><span class="line">partition p0 values  in (1,3,5,7,8),</span><br><span class="line">partition p1 values in (2,4,6,8)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>在用insert插入多个行数据的过程中遇到分区未定义的值时，MyISAM和InnoDB存储引擎的处理完全不同。myIsam将之前的行数据都插入，但之后的数据不会被插入。innodb将其视为一个事务，因此没有任何插入</p>
<p>###　hash分区<br>hash分区的目的是将数据均匀地分布到预先定义的各个分区中，保证各分区的数据数量大致是一样的。Mysql自动完成这些工作，用户所要做的只是基于将要进行哈希分区的列值顶一个列值或表达式，一集指定被分区的表将会被分割成分区数量.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table t_linear_hash(a int)engine=innodb</span><br><span class="line">partitiion by linear hash(a)</span><br><span class="line">partitions 4;</span><br></pre></td></tr></table></figure></p>
<p>mysql数据库还支持一种称为linearhash的分区，它使用一个更加复杂的算法来确定新行插入到已经分区的表中的位置。P165</p>
<h1 id="key分区-p166"><a href="#key分区-p166" class="headerlink" title="key分区 p166"></a>key分区 p166</h1><p>key分区和hash分区相似，不同之处在于hsah分区使用用户定义的函数进行分区，key分区使用mysql数据库提供的函数进行分区。</p>
<h1 id="columns-分区"><a href="#columns-分区" class="headerlink" title="columns 分区"></a>columns 分区</h1><p>前面四中分区中，分区的条件是：数据必须是整形。columns不需要</p>
<h2 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h2><p>Mysql数据库允许在range和list分区上再进行hash或key子分区。<br>每个子分区的数量必须相同<br>要在一个分区表的任何分区上使用subpartition来明确定义任何字分区，就必须定义所有的子分区<br>每个subpartition自居必须包括子分区的一个名字<br>子分区的名字必须是唯一的</p>
<h2 id="分区中null值"><a href="#分区中null值" class="headerlink" title="分区中null值"></a>分区中null值</h2><p>mysql 数据库的分区总是视null值小于任何一个非null值，这和order by操作一样。Hash和key分区对于null的处理是将含有null值得记录返回0。</p>
<h2 id="分区和性能-P176"><a href="#分区和性能-P176" class="headerlink" title="分区和性能 P176"></a>分区和性能 P176</h2><p>对于OLTP应用，分区应该非常小心，在这种应用下，通常不可能会获取一张 大表10%的数据，大部分都是铜鼓欧索引返回几条记录即可。根据B+树索引的原理克制，对于一张达标，一般的B+树需要2~3次的磁盘IO。一次B+树可以很好的完成操作，不需要分区的帮助。<br>1000w行的表B+树只有两层。设计不好的索引得不偿失。10个分区，如果设计不好就要进行20次IO。</p>
<h2 id="表和分区间-交换数据"><a href="#表和分区间-交换数据" class="headerlink" title="表和分区间 交换数据"></a>表和分区间 交换数据</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[InnoDB存储引擎3-文件]]></title>
      <url>http://baobing.github.io/2016/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E3-%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><a id="more"></a>
<p>查看参数的访问</p>
<ul>
<li><p>通过命令查看show variables</p>
</li>
<li><p>通过information_schema架构下的global_variables视图查找</p>
</li>
</ul>
<h2 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h2><ul>
<li><p>动态参数：set global|session 参数；set @@global|@@session 参数</p>
</li>
<li><p>静态参数</p>
</li>
</ul>
<h1 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h1><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>查看错误日志文件的位置：show variables like ‘log_error’.</p>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><ul>
<li><p>查看慢查询SQL时间：show variables like “long_query_time”。</p>
</li>
<li><p>查看慢查询是否开启：show variables like “log_slow_queries”。</p>
</li>
<li><p>记录未使用索引的sql：log_queries_not_using_indexes;</p>
</li>
<li><p>慢查询类型 slow_query_type .涉及sql语句，IO，运行时间。</p>
</li>
<li><p>记录逻辑IO过多的SQL：long_query_io.</p>
</li>
<li><p>mysqldumpslow 命令 很好的实现慢查询的梳理。肯定有图形化工具</p>
</li>
<li><p>Mysql5.1开始将慢查询放到slow_log表中。</p>
<ul>
<li>参数log_output指定了慢查询的输出格式 File 或者 Table。这个参数可以在线修改，并且是全局的。也可以修改slow_log表的存储引擎。</li>
</ul>
</li>
</ul>
<h2 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h2><p>开启查询日志：set global general_log = on</p>
<p>日志名称：主机名.log。</p>
<p>也可以以表的形式保存。general_log。</p>
<h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p>二进制日志记录了对Mysql数据库执行更改的所有操作，不包括select和show操作。</p>
<h3 id="BINLOG日志作用："><a href="#BINLOG日志作用：" class="headerlink" title="BINLOG日志作用："></a>BINLOG日志作用：</h3><ul>
<li><p>恢复（recovery）：某些数据恢复需要二进制日志，例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行point-in-time的恢复。</p>
</li>
<li><p>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的Mysql数据库与另一条数据进行实时同步。</p>
</li>
<li><p>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。</p>
</li>
</ul>
<h3 id="binlog参数设置："><a href="#binlog参数设置：" class="headerlink" title="binlog参数设置："></a>binlog参数设置：</h3><ul>
<li><p>max_binlog_size:单个文件最大值</p>
</li>
<li><p>binlog_cache_size：事务未提交SQL存放buffer大小。每个回话所有，不能设置过大（导致内存不够），也不能设置过小（sql信息写到临时文件中）。可以通过查看binlog_cache_use、binglog_cache_disk_use的状态判断。</p>
</li>
<li><p>sync_binlog :表示每次写缓冲多少次就同步到磁盘。高可用mysql一定要设置为1。防止宕机导致的日志缺失。对于事务是先写binlog再执行，SQL为成功执行的情况下，会导致数据不一致。可以通过innodb_support_xa来解决。详细可查看<a href="http://blog.csdn.net/zbszhangbosen/article/details/9132833" target="_blank" rel="noopener">浅析innodb_support_xa与innodb_flush_log_at_trx_commit<a>。</a></a></p>
</li>
</ul>
<p>-binlog-do-db和 binlog-ignore-db表示需要写入或者忽略写入哪些库的日志</p>
<ul>
<li>bin_format，日志格式。可能导致二进制日志格式。rand、uuid参数，事务隔离级别。日志格式有statment：记录日志的逻辑SQL语句；row：记录表的更改情况；mixed：一些情况使用statment，一些情况使用row，使用row的情况1）表的存储引擎为NDB 2）使用UUID、User等不确定函数。3）使用insert delay语句 4）用户定义函数UDF 5）使用了临时表。<strong>通常情况，我们使用ROW格式。</strong></li>
</ul>
<p>参看binlog 使用mysqlbinlog</p>
<h1 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h1><p>在Unix系统下本地连接Mysql可以使用unix域套接字方式。show variables like ‘socket’,查看文件位置。</p>
<h1 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h1><p>当mysql实例启动时，会将自己的进程id写入一个文件中，该文件即为pid文件。show variables like ‘pid_file’,查看文件位置。</p>
<h1 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h1><p>MYSQL都有一个以frm为后缀名的文件，这个文件记录了该表的表结构定义。frm还用来存放视图的定义。</p>
<h1 id="InnoDB存储引擎文件"><a href="#InnoDB存储引擎文件" class="headerlink" title="InnoDB存储引擎文件"></a>InnoDB存储引擎文件</h1><h2 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h2><p>参数innodb_data_file_path 表空间文件路径设置。</p>
<p>公共表空间 ibdata1 ibdata2。</p>
<p>参数innodb_file_per_table，每个表产生一个独立表空间。</p>
<p>单独表空间文件近存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间。<br><img src="/2016/11/20/数据库/InnoDB存储引擎3-文件/3-1.png" title="3-1"></p>
<h2 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h2><p>每个InnoDB存储引擎至少有一个重做日志组，每个问价组下至少有2个重做日志文件，默认的ib_logfile0和ib_logfile1。InnoDB存储引擎先写重做日志文件1，当到达文件的最后时，会切换至重做日志文件2，再当重做日志文件2也被写满时，会在切换到重做日志文件1中</p>
<h3 id="二进制日志与重做日志的区别"><a href="#二进制日志与重做日志的区别" class="headerlink" title="二进制日志与重做日志的区别"></a>二进制日志与重做日志的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 二进制日志惠济路所有与Mysql数据库有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志。而InnoDB存储引擎的重做日志只记录有关改引擎本身的事务日志。</span><br><span class="line"></span><br><span class="line">- 记录的内容不同，无论用户二进制日志文件记录的格式设为Statement还是Row，又或者是Mixed，其记录的都是关于一个事务的具体操作内容，即该日志是逻辑日志。而InnoDB存储引擎的重做日志文件记录的是关于每个页的更改的物理情况。</span><br><span class="line"></span><br><span class="line">-  写入的时间也不同，二进制日志文件仅在事务提交前进行提交，即只写磁盘一次，不论这时改事务多大。而在事务进行的过程中，却不断有重做日志条目被写入到重做日志文件中</span><br></pre></td></tr></table></figure>
<h3 id="重做日志格式"><a href="#重做日志格式" class="headerlink" title="重做日志格式"></a>重做日志格式</h3><p>InnoDB1.2为止，总共定义了51种重做日志类型。虽然各种重做日志类型不同，但是他们有着基本的格式。<br><img src="/2016/11/20/数据库/InnoDB存储引擎3-文件/3-2.png" title="3-2"></p>
<h3 id="重做日志-保证数据的一致性"><a href="#重做日志-保证数据的一致性" class="headerlink" title="重做日志 保证数据的一致性"></a>重做日志 保证数据的一致性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">写入重做日志文件的操作不是直接写，而是先写入一个重做日志缓冲中，然后按照一定的条件顺序地写入日志文件。</span><br><span class="line"></span><br><span class="line">从重做日志缓冲往磁盘写入时，是按512个字节，也就是一个山区的大小进行写入。因为扇区是写入的最小单位，因此可以保证写入必定是成功的。因此在重做日志的写入过程中不需要doublewrite。</span><br><span class="line"></span><br><span class="line">参数innodb_flush_log_at_trx_commit的有效值为0，1，2。0代表当提交事务时，并不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。1和2不同在于：1表示在执行commit时会重做日志缓冲同步写到磁盘，即伴有ssync的调用。2表示将重做日志异步写到磁盘，即写到文件系统的缓存中。因此不能保证执行commmit时肯定会写入重做日志文件，只是有这个动作发生。</span><br><span class="line"></span><br><span class="line">因此为了保证事务的ACID中的持久性，必须将innodb_flush_log_at_trx_commit 设置为1，也就是每当有事务提交时，就必须保证事务都已经写入重做日志文件。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行sql，并且写重做日志到缓存-&gt;执行comiit语句-&gt;重做日志写入磁盘-&gt;更新内存数据页</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[InnoDB存储引擎2-InnoDB存储引擎]]></title>
      <url>http://baobing.github.io/2016/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E2-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<h1 id="InnoDB存储引擎的版本"><a href="#InnoDB存储引擎的版本" class="headerlink" title="InnoDB存储引擎的版本"></a>InnoDB存储引擎的版本</h1><a id="more"></a>
<img src="/2016/11/20/数据库/InnoDB存储引擎2-InnoDB存储引擎/2-1.png" title="2-1">
<p>Mysql5.5 InnoDB1.1.X<br>Mysql5.6 InnoDB1.2X</p>
<h1 id="InnoDb体系架构"><a href="#InnoDb体系架构" class="headerlink" title="InnoDb体系架构"></a>InnoDb体系架构</h1> <img src="/2016/11/20/数据库/InnoDB存储引擎2-InnoDB存储引擎/2-1-1.png" title="2-1-1">
<h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><ul>
<li>Master线程：缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、undo页的回收。</li>
<li>IO线程：InnoDB存储引擎中大量使用AIO。IO线程主要工作是负责这些IO请求的回调</li>
<li>Purge线程：回收已经使用并分配的undo页。InnoDb1.1开始引入。</li>
<li>Page Cleaner Thread线程：脏页刷新操作。InnoDB1.2开始引入。<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3>一共八种，分为Mysql缓冲和InnoDB缓冲<br>·<img src="/2016/11/20/数据库/InnoDB存储引擎2-InnoDB存储引擎/2-2.png" title="2-2"><h3 id="LRU-List、Free-List和FlushList"><a href="#LRU-List、Free-List和FlushList" class="headerlink" title="LRU List、Free List和FlushList"></a>LRU List、Free List和FlushList</h3>LRU：最近最久未使用，局部性原理。将页放到队首，查重。改进将选中页防止队列5/8处<br>LFU：基于次数。<br>优化点：</li>
<li>设置midpoint；</li>
<li>设置命中页到达热端的命中次数；</li>
<li>设置热点页被刷出的概率；</li>
<li>show engine innodb status; innodb_buffer_pool_stats表。查看LUR、FreeList、命中率 等内存使用信息<br>unzip_LRU：管理压缩后的页，页的默认大小为16KB<br>伙伴算法：（申请4KB页为例）</li>
<li>检查4DB的unzip_LRU列表，减产是否与可用的空闲页</li>
<li>若有直接使用</li>
<li>否则，检查8KBunzip_LRU列表</li>
<li>若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表</li>
<li>如不能得到空闲页，将LRU列表申请一个16KB的页，将页分为1个8KB的页和2个4KB的页<br>Flush列表 保存脏页，同时脏页也保存在LRU列表中<h3 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h3>InnoDB存储引擎首先将重做日志信息放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。<br>重做日志刷新到磁盘时机：</li>
<li>Master线程每一秒刷新一次</li>
<li>每个事务提交时会刷新</li>
<li>重做日志缓冲池空间小于1/2时<h3 id="额外内存池"><a href="#额外内存池" class="headerlink" title="额外内存池"></a>额外内存池</h3>InnoDB中，对内存的管理通过一个称为内存堆的方式进行。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。<h1 id="CheckPoint技术"><a href="#CheckPoint技术" class="headerlink" title="CheckPoint技术"></a>CheckPoint技术</h1>将脏页强制刷新到磁盘。解决问题：</li>
<li>缩短数据库恢复时间</li>
<li>缓冲池不够用时，将脏页刷新到磁盘</li>
<li>重做日志不可用时，刷新脏页<br>InnoDB通过LSN来标志版本，LSN是8字节的数字。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。<br>Sharp Checkpoint：<br>默认工作方式，数据库关闭时将所有脏页刷新到磁盘<br>Fuzzy Checkpoint：刷新时机</li>
<li>间隔一段 时间刷新</li>
<li>更新LRU列表刷新，被移除队列的页</li>
<li>重做日志文件不可用，循环使用重做日志文件。P35？？？</li>
<li>脏页太多 默认75页</li>
</ul>
<h1 id="Master-工作方式-P36"><a href="#Master-工作方式-P36" class="headerlink" title="Master 工作方式 P36"></a>Master 工作方式 P36</h1><h2 id="InnoDB-1-1"><a href="#InnoDB-1-1" class="headerlink" title="InnoDB 1.1"></a>InnoDB 1.1</h2><p>**磁盘操作会考虑IO的使用情况<br>每一秒的操作：</p>
<ul>
<li>日志缓冲刷新到磁盘，即使这个事务还没有提交 （总是）</li>
<li>合并插入缓冲（可能）</li>
<li>至多刷新100个脏页到磁盘</li>
<li>没有用户活动切换到backgroud loop<br>没十秒的操作：</li>
<li>刷新100个脏页到磁盘</li>
<li>合并至多5个插入缓冲（总是）</li>
<li>删除无用的Undo页（总是）</li>
<li>将日志缓冲刷新到磁盘（总是）<br>刷新100个或者10 个脏页到磁盘（总是）<br>backgroud loop 操作 没有用户活动或者关闭数据库</li>
<li>删除无用undo页</li>
<li>合并20个插入缓冲</li>
<li>跳回到主循环</li>
</ul>
<h1 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h1><h2 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h2><p>背景：辅助索引插入的值不是单调递增或者单调递减。<br>操作：对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个InsertBuffer对象中，好似欺骗。然后再以一定的频率和情况进行Insert Buffer和辅助索引叶子节点的mege操作。<br>使用范围：辅助索引，索引不是唯一的</p>
<h2 id="Chage-Buffer"><a href="#Chage-Buffer" class="headerlink" title="Chage Buffer"></a>Chage Buffer</h2><p>Insert、Delete、Update都进行缓冲，可以设置启用或禁止其中的某项。</p>
<h2 id="Insert-Buffer的内部实现-P51"><a href="#Insert-Buffer的内部实现-P51" class="headerlink" title="Insert Buffer的内部实现 P51"></a>Insert Buffer的内部实现 P51</h2><p>InsertBuffer 数据结构是一颗B+树。全局一个B+树，这颗B+树放在表空间中，默认是ibdata1中。<br><img src="/2016/11/20/数据库/InnoDB存储引擎2-InnoDB存储引擎/2-2-1.png" title="2-2-1"><br> space 表示 表空间id<br>offerset 表示页所在的偏移量<br>metadata 排序呢每个记录进入InsertBuffer的顺序<br>Insert Buffer BitMap 用来标记每个辅助索引页的可用空间。<br><img src="/2016/11/20/数据库/InnoDB存储引擎2-InnoDB存储引擎/2-3.png" title="2-3"></p>
<h2 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h2><p>重做日志中记录的是对页的物理操作，如偏移量800写‘aaaa’记录。如果这个页本身已经发生了损坏，在对其进行重做是没有意义的。这就是说，在应用重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。<br>doublewrite由两部分组成，一部分是内存中doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中连续的128个页，即两个区，大小同样为2MB。在对缓冲池的脏页进行刷新时，通过memcpy函数将脏页先复制到内存doublewrite buffer，之后分两次，每次1MB顺序写入共享表空间的磁盘上，然后调用fsync函数，同步磁盘，避免缓冲写带来的问题。<br><img src="/2016/11/20/数据库/InnoDB存储引擎2-InnoDB存储引擎/2-5.png" title="2-5"></p>
<h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><p>访问模式一样。以该模式访问100次，页通过该模式放了N次，页中记录/16.</p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><h2 id="刷新临近页"><a href="#刷新临近页" class="headerlink" title="刷新临近页"></a>刷新临近页</h2><h1 id="启动、关闭和恢复"><a href="#启动、关闭和恢复" class="headerlink" title="启动、关闭和恢复"></a>启动、关闭和恢复</h1><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><ul>
<li>show engine innodb status； 查看innodb的状态信息</li>
<li>show variables like ‘%version%’；可以查看mysql和innodb的版本信息</li>
<li>innodb_file_io_thread 设置IO线程数量 innodb_read_io_thread;innodb_write_io_thread</li>
<li>innodb_purge_threads 设置purge线程数量</li>
<li>innodb_buffer_pool_size;缓冲池大小</li>
<li>innndb_buffer_pool_instances;InnoDB缓冲池数量;</li>
<li>数据表innodb_buffer_pool_stats保存innoDB相关信息</li>
<li>innodb_old_blocks_time  页读取到mid位置后需要等待多久才会被加入到LRU的热端</li>
<li>innodb_buffer_page_lru表 查看LUR列表的信息</li>
<li>innodb_log_buffer_size 重做</li>
<li>innodb_lru_scan_depth LRU队列中可用页数量</li>
<li>innodb_lru_scan_depth LRU队列中空闲页的最小数值 默认1024</li>
<li>innodb_max_dirty_pages_pct 最大脏页数量，否则刷新会磁盘</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nnoDB存储引擎1——Mysql体系结构和存储引擎]]></title>
      <url>http://baobing.github.io/2016/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1%E2%80%94Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<h1 id="Mysql体系结构"><a href="#Mysql体系结构" class="headerlink" title="Mysql体系结构"></a>Mysql体系结构</h1><a id="more"></a>
<img src="/2016/11/20/数据库/InnoDB存储引擎1—Mysql体系结构和存储引擎/1-1.png" title="1-1">
<ul>
<li>连接池组件：授权，线程重用，链接限制，内存检查</li>
<li>管理服务和工具组件： 备份，恢复，安全，复制，集群，管理权限配置，迁移</li>
<li>SQL接口组件：DML，DDL，存储过程视图，触发器</li>
<li>查询分析组件：查询翻译</li>
<li>优化器组件：访问路径，数据统计</li>
<li>缓冲组件：全局缓冲 或者 指定引擎缓冲</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<h1 id="各存储引擎之间的比较"><a href="#各存储引擎之间的比较" class="headerlink" title="各存储引擎之间的比较"></a>各存储引擎之间的比较</h1><img src="/2016/11/20/数据库/InnoDB存储引擎1—Mysql体系结构和存储引擎/1-2.png" title="1-2">
<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><ul>
<li>面向在线事务处理的应用OLTP</li>
<li>行级锁</li>
<li>外键</li>
</ul>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><ul>
<li>不支持事务</li>
<li>表锁</li>
<li>支持全文索引</li>
<li>在线分析数据库OLAP</li>
<li>缓冲池只缓存索引文件</li>
<li>MYD存放数据MYI存放索引</li>
</ul>
<h2 id="NDB"><a href="#NDB" class="headerlink" title="NDB"></a>NDB</h2><ul>
<li>集群</li>
<li>内存数据库</li>
<li>JOIN操作在数据库层完成，效率低</li>
</ul>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><ul>
<li>内存数据库</li>
<li>无磁盘持久，丢了就完蛋了</li>
<li>默认Hash索引</li>
<li>表锁</li>
<li>不支持Text，Bolg</li>
</ul>
<h2 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h2><ul>
<li>只支持insert和select操作</li>
<li>行锁</li>
<li>使用zlib算法将数据行压缩存储</li>
</ul>
<h1 id="链接Mysql"><a href="#链接Mysql" class="headerlink" title="链接Mysql"></a>链接Mysql</h1><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h2 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h2><p>windows系列使用<br>启用配置文件中启用–enable-named-pipe选项。<br>连接时，客户端需要使用–protocol=memory。</p>
<h2 id="Unix域套接字"><a href="#Unix域套接字" class="headerlink" title="Unix域套接字"></a>Unix域套接字</h2><p>配置文件中指定套接字文件的路径。<br>mysql -u用户名 -s 套接字文件路径</p>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><ul>
<li>show engine; 参看所有存储引擎</li>
<li>use mysql;select * from user; 查看mysql用户</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM命令-instanceof]]></title>
      <url>http://baobing.github.io/2016/09/19/JVM/JVM%E5%91%BD%E4%BB%A4-instanceof/</url>
      <content type="html"><![CDATA[<p>　　instanceof是Java反射编程中经常用到的关键字。instanceof关键字作用是验证一个Java实例是否属于某个特定的类或者接口。<a id="more"></a><br>参考文档</p>
<h1 id="JVM规范"><a href="#JVM规范" class="headerlink" title="JVM规范"></a>JVM规范</h1><blockquote>
<p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.instanceof" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.instanceof</a></p>
</blockquote>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>决定对象是否是给定类型</p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>instanceof<br>indexbyte1<br>indexbyte2</p>
<h2 id="操作栈"><a href="#操作栈" class="headerlink" title="操作栈"></a>操作栈</h2><p>…, objectref →</p>
<p>…, result</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>　　objectref必须是类型引用（从操作栈中弹出）。无符号字节indexbyte1和indexbyte2用来构造一个指向运行时常量池索引，这个索引值为(indexbyte1 &lt;&lt; 8) | indexbyte2，也就是两个数字拼接。索引指向常量池中的对象一定是一个类、数组或者接口类型的引用。<br>　　如果objectref为null，instanceof指令推送一个整数0进入操作栈。<br>　　除此之外，如果objectref是一个已经给定的类、数组或者接口实现，将放置一个整数1到操作数栈，否则放置0。<br>    下面将要介绍确定一个非null得objectref是给定类型的实例。假设S是objectref所属的类，T是指定类、数组或者接口类型，下面是判断规则：</p>
<ul>
<li><p>如果S是一个普通类/非数组的类，则：</p>
<ul>
<li>如果类型T是一个普通类类型，S必须和T的类型相同或者S必须是T的子类型</li>
<li>如果T是一个接口类型，对象S必须实现接口T</li>
</ul>
</li>
<li><p>如果S是一个接口类型，则：</p>
<ul>
<li>如果T是一个普通类类型，则T必须是Object类型。</li>
<li>如果T是一个接口类型，则T必须S实现了相同接口，或者S实现T的父接口</li>
</ul>
</li>
<li><p>如果S属于数组类型SC[],S是一个SC类型的组件，则</p>
<ul>
<li>如果T是普通类类型，则T必须是Object类型。</li>
<li>如果T是接口类型，然后T必须是通过数组实现的接口之一</li>
<li>如果T是一个数据类型TC[],是TC类型数组的组件，则必须符合下面中的一个：<ul>
<li>TC和SC是相同的原始类型</li>
<li>TC和SC是相容的引用类型，并且在运行时规则下，类型SC能够映射为TC</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编译Java项目]]></title>
      <url>http://baobing.github.io/2016/08/29/Java%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91Java%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>一直用Meavn编译打包应用。期间也断断续续了解过一些编译的命令，但是不是很系统尤其是对classpath概念的模糊，这一次写一篇文章记录一下自己的成果。</p>
<a id="more"></a>
<p>参考的博客：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/haolujun/archive/2013/03/02/2939698.html" target="_blank" rel="noopener">http://www.cnblogs.com/haolujun/archive/2013/03/02/2939698.html</a></p>
</blockquote>
<h1 id="javac命令（编译）"><a href="#javac命令（编译）" class="headerlink" title="javac命令（编译）"></a>javac命令（编译）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -g                         生成所有调试信息</span><br><span class="line">  -g:none                    不生成任何调试信息</span><br><span class="line">  -g:&#123;lines,vars,source&#125;     只生成某些调试信息</span><br><span class="line">  -nowarn                    不生成任何警告</span><br><span class="line">  -verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="line">  -deprecation               输出使用已过时的 API 的源位置</span><br><span class="line">  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</span><br><span class="line">  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</span><br><span class="line">  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</span><br><span class="line">  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</span><br><span class="line">  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。</span><br><span class="line">  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line">  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</span><br><span class="line">  -parameters                生成元数据以用于方法参数的反射</span><br><span class="line">  -d &lt;目录&gt;                    指定放置生成的类文件的位置</span><br><span class="line">  -s &lt;目录&gt;                    指定放置生成的源文件的位置</span><br><span class="line">  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</span><br><span class="line">  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件</span><br><span class="line">  -encoding &lt;编码&gt;             指定源文件使用的字符编码</span><br><span class="line">  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br><span class="line">  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</span><br><span class="line">  -version                   版本信息</span><br><span class="line">  -help                      输出标准选项的提要</span><br><span class="line">  -A关键字[=值]                  传递给注释处理程序的选项</span><br><span class="line">  -X                         输出非标准选项的提要</span><br><span class="line">  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</span><br><span class="line">  -Werror                    出现警告时终止编译</span><br><span class="line">  @&lt;文件名&gt;                     从文件读取选项和文件名</span><br></pre></td></tr></table></figure>
<h1 id="java命令（运行）"><a href="#java命令（运行）" class="headerlink" title="java命令（运行）"></a>java命令（运行）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32	  使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64	  使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server	  选择 &quot;server&quot; VM</span><br><span class="line">                  默认 VM 是 server,</span><br><span class="line">                  因为您是在服务器类计算机上运行。</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 : 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br></pre></td></tr></table></figure>
<h1 id="jar命令（打包）"><a href="#jar命令（打包）" class="headerlink" title="jar命令（打包）"></a>jar命令（打包）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">用法: jar &#123;ctxui&#125;[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...</span><br><span class="line">选项:</span><br><span class="line">    -c  创建新档案</span><br><span class="line">    -t  列出档案目录</span><br><span class="line">    -x  从档案中提取指定的 (或所有) 文件</span><br><span class="line">    -u  更新现有档案</span><br><span class="line">    -v  在标准输出中生成详细输出</span><br><span class="line">    -f  指定档案文件名</span><br><span class="line">    -m  包含指定清单文件中的清单信息</span><br><span class="line">    -n  创建新档案后执行 Pack200 规范化</span><br><span class="line">    -e  为捆绑到可执行 jar 文件的独立应用程序</span><br><span class="line">        指定应用程序入口点</span><br><span class="line">    -0  仅存储; 不使用任何 ZIP 压缩</span><br><span class="line">    -P  保留文件名中的前导 &apos;/&apos; (绝对路径) 和 &quot;..&quot; (父目录) 组件</span><br><span class="line">    -M  不创建条目的清单文件</span><br><span class="line">    -i  为指定的 jar 文件生成索引信息</span><br><span class="line">    -C  更改为指定的目录并包含以下文件</span><br></pre></td></tr></table></figure>
<h1 id="编译最简单的应用"><a href="#编译最简单的应用" class="headerlink" title="编译最简单的应用"></a>编译最简单的应用</h1><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test02--|---src---|---A.java--|</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class A&#123;</span><br><span class="line">	public A()&#123;</span><br><span class="line">		System.out.println(&quot;I am A!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		new A();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd java/test01/src</span><br><span class="line">javac A.java</span><br><span class="line">java A</span><br></pre></td></tr></table></figure>
<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am A!</span><br></pre></td></tr></table></figure>
<h1 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h1><p>（1）要想成功编译java文件，需要有classpath和包名（package）的共同配合。</p>
<p>类发现规则：class文件所在目录 = classpath + ‘\’ + 包名（包名中的’.’全变成’\’）</p>
<p>这个规则大家一定要记住，保证万事OK！Java就是靠这个规则来寻找需要的class文件的。</p>
<p>（2）何时需要使用-classpath：当你要编译或执行的类引用了其它的类，但被引用类的.class文件不在当前目录下时，就需要通过-classpath来引入类<br>（3）何时需要指定路径：当你要编译的类所在的目录和你执行javac命令的目录不是同一个目录时，就需要指定源文件的路径(CLASSPATH是用来指定.class路径的，不是用来指定.java文件的路径的) </p>
<h1 id="引入package"><a href="#引入package" class="headerlink" title="引入package"></a>引入package</h1><h2 id="文件目录-1"><a href="#文件目录-1" class="headerlink" title="文件目录"></a>文件目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test03--|---src---|---com---|-baobing-|---A.java--|</span><br><span class="line">                  |--B.java-|</span><br></pre></td></tr></table></figure>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package src.com.baobing;</span><br><span class="line">public class A&#123;</span><br><span class="line">    public  A()&#123;</span><br><span class="line">        System.out.println(&quot;I am A!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package src;</span><br><span class="line">import src.com.baobing.*;</span><br><span class="line">public class B&#123;</span><br><span class="line">    public B()&#123;</span><br><span class="line">        A a = new A();</span><br><span class="line">        System.out.println(&quot;I am B!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行命令-1"><a href="#运行命令-1" class="headerlink" title="运行命令"></a>运行命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/java/test02</span><br><span class="line">javac -cp  ~/java/test02 src/B.java</span><br><span class="line">java src.B</span><br></pre></td></tr></table></figure>
<h2 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am A!</span><br><span class="line">I am B!</span><br></pre></td></tr></table></figure>
<p><strong><em>需要注意的是包名一定更要和文件目录一一对应。</em></strong> 否则会报错。<br>编译时给出正确的classpath和正确的包名，javac程序即可自动查找编译B.java依赖的A.java文件。</p>
<h1 id="打JAR包"><a href="#打JAR包" class="headerlink" title="打JAR包"></a>打JAR包</h1><p>文件路径以及代码都与《引入package》环节的一致，就不赘述了。</p>
<h2 id="运行命令-2"><a href="#运行命令-2" class="headerlink" title="运行命令"></a>运行命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd java/test03</span><br><span class="line">javac src/*.java</span><br><span class="line">jar cvf test03.jar src</span><br><span class="line">java -cp test03.jar src.B</span><br></pre></td></tr></table></figure>
<h2 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am A!</span><br><span class="line">I am B!</span><br></pre></td></tr></table></figure>
<h1 id="引用jar包"><a href="#引用jar包" class="headerlink" title="引用jar包"></a>引用jar包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---test04--|---src---|---C.java--|</span><br><span class="line">           |---lib---|test03.jar-|</span><br></pre></td></tr></table></figure>
<h1 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package src;</span><br><span class="line">import src.*;</span><br><span class="line">import src.com.baobing.*;</span><br><span class="line">public class C&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		new A();</span><br><span class="line">		System.out.println(&quot;------------------&quot;);</span><br><span class="line">		new B();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运行命令-3"><a href="#运行命令-3" class="headerlink" title="运行命令"></a>运行命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd java/test04</span><br><span class="line">javac -cp ./lib/test03.jar src/C.java</span><br><span class="line"># 因为是macos所以用:隔开，必须加上./，否则会报错。揣测是因为使用-cp</span><br><span class="line"># 就不能使用默认的classpath</span><br><span class="line">java -cp ./lib/test03.jar:./ src.C</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am A!</span><br><span class="line">------------------</span><br><span class="line">I am A!</span><br><span class="line">I am B!</span><br></pre></td></tr></table></figure>
<h1 id="可执行jar包"><a href="#可执行jar包" class="headerlink" title="可执行jar包"></a>可执行jar包</h1><h2 id="文件目录-2"><a href="#文件目录-2" class="headerlink" title="文件目录"></a>文件目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test03--|---src-----|---com---|-baobing-|---A.java--|</span><br><span class="line">                    |--B.java-|</span><br><span class="line">        |MANIFEST.MF|</span><br></pre></td></tr></table></figure>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>A.java和B.java的代码与《引入package》环节的一致，不赘述。</p>
<p>注意事项:Main-Class一定要是第一行，不知道原因<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main-Class: src.B</span><br><span class="line">Manifest-Version: 1.0</span><br><span class="line">Created-By: 1.8.0_51 (Oracle Corporation)</span><br></pre></td></tr></table></figure></p>
<h2 id="运行命令-4"><a href="#运行命令-4" class="headerlink" title="运行命令"></a>运行命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd java/test05</span><br><span class="line">jar cvfm test.jar MANIFEST.MF src/B.class src/com/baobing/A.class</span><br><span class="line">java -jar test.jar</span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am A!</span><br><span class="line">I am B!</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM8-锁及优化]]></title>
      <url>http://baobing.github.io/2016/08/29/JVM/JVM8-%E9%94%81%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><a id="more"></a>
<p>下面类由于ArrayList不是线程安全的在数组扩展的时候回导致异常<br>public class SafeThread {<br>    public static List<integer> numberList = new ArrayList&lt;&gt;();<br>    public static class AddToList implements Runnable{<br>        int startNum = 0;<br>        public AddToList(int startNum) {<br>            this.startNum = startNum;<br>        }<br>        @Override<br>        public void run() {<br>            int count = 0;<br>            while(count &lt; 1000000){<br>                numberList.add(startNum);<br>                startNum += 2;<br>                count++;<br>            }<br>        }<br>    }<br>    public static void main(String[] args) throws Exception{<br>        Thread t1 = new Thread(new AddToList(0));<br>        Thread t2 = new Thread(new AddToList(1));<br>        t1.start();<br>        t2.start();<br>        while(t1.isAlive() || t2.isAlive()){<br>            Thread.sleep(1);<br>        }<br>        System.out.println(numberList.size());<br>    }<br>}</integer></p>
<h1 id="对象头Mark"><a href="#对象头Mark" class="headerlink" title="对象头Mark"></a>对象头Mark</h1><p>描述对象的hash、锁信息，垃圾回收标记，年龄<br>指向锁记录的指针；指向monitor的指针 ；GC标记；偏向锁线程ID；</p>
<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>应用场景：大部分情况是没有竞争的情况，可以铜鼓哦偏向来提高性能；<br>锁偏向当前已经占有锁的线程。<br>将对象Mark的标记设置为偏向，并将线程ID写入对象头mark<br>只要没有竞争，获得偏向锁的线程，在将来进入同步块，不需要做同步<br>当其他线程请求相同的锁时，偏向模式结束<br>-XX：+UseBiaseLocking 默认启用；<br>-XX：BiasedLockingStartupDelay = 0；<br>-XX：-UseBiasedLocking 不启用偏向锁<br>竞争激烈的场合，不使用；<br>默认撑起刚开始不使用偏向锁，刚开始竞争比较激烈</p>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>BacicObjectLock 嵌入在线程栈中的对象 。<br>包含两部分：BasicLock 对象头；指向持有本锁的对象的指针；<br>普通锁的处理性能不理想<br> 如果对象没有被锁定，将对象头的mark指针保存到锁对象中，将对象头设置为指向锁的指针。<br>对象头的指的方向是否在线程的内存区域中，说明线程持有锁。<br>具体代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock.set_displaecd_header(mark);</span><br><span class="line">if(mark == (markOop) Atomic::cmpxchg_ptr(lock,obj()-&gt;mark_addr(),mark))&#123;</span><br><span class="line">     TEVENT(slow_enter:release stacklock);</span><br><span class="line">     return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果轻量级锁失败表示存在竞争，升级为重量级锁（常规锁）<br>在没有锁竞争的前提下，减少传统锁使用OS互斥产生的性能损耗；</p>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>空循环，等待锁。<br>如果线程可以很快获得锁，name可以不再os层挂起线程，让线程做几个空操作（自选）<br>如果同步块很长，自选失败，会降低系统性能<br>如果同步快很短，自选成功，节省线程挂起切换时间，提升系统性能</p>
<h1 id="JVM获取锁的步骤"><a href="#JVM获取锁的步骤" class="headerlink" title="JVM获取锁的步骤"></a>JVM获取锁的步骤</h1><p>偏向锁可用先会尝试偏向锁。<br>轻量级锁可用胡先尝试轻量级锁<br>以上都失败，尝试自旋锁<br>再失败，尝试普通锁，使用os互斥量在操作系统层挂起</p>
<h1 id="Java并发编程技巧"><a href="#Java并发编程技巧" class="headerlink" title="Java并发编程技巧"></a>Java并发编程技巧</h1><h2 id="减少锁粒度"><a href="#减少锁粒度" class="headerlink" title="减少锁粒度"></a>减少锁粒度</h2><p>将大对象，拆成小对象，打打增加并行度，降低锁竞争。<br>ConcurrentHashMap<br>若干个Segment：Segment<k,v>[] segments<br>Segment中维护HashEntry<k,v><br>put 操作时 先定位到Segment，锁定一个Segment，执行put</k,v></k,v></p>
<h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><p>根据功能进行锁分离，如：读锁 、写锁。<br>读多写少的情况<br>LinkedBlockingQueue 分为take锁和put锁</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能优化。 多个同步快合并，不需要同步很快完成。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>局部变量不使用同步机制的集合<br>-server-XX：+DoEscapeAnalysis -XX:+ElminateLocks 逃逸分析 判断是否逃逸出局部范围</p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>锁是悲观的操作：预期竞争存在<br>无锁是乐观的操作：认为竞争不存在<br>无锁的实现方式：<br>CAS（Compare And Swap）；非阻塞的同步；<br>CAS（V,E,N）; V需要更新的值，E期望当前的值，N新的值 ；返回最终值；<br>不出现线程的切换<br>AtomicInterger</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM6-类加载]]></title>
      <url>http://baobing.github.io/2016/08/29/JVM/JVM6-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h1 id="class装载验证流程"><a href="#class装载验证流程" class="headerlink" title="class装载验证流程"></a>class装载验证流程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>取得类的二进制流 ；转为方法区的数据结构；生成Class对象<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证：保证Class流的格式是否正确"><a href="#验证：保证Class流的格式是否正确" class="headerlink" title="验证：保证Class流的格式是否正确"></a>验证：保证Class流的格式是否正确</h3><p>文件格式验证：以0xCAFEBABE开头；版本号是否合理；<br>元数据验证（语法检查）：父类检查；继承final类；非抽象类实现所有的抽象方法；<br>字节码验证（JVM规范检查、非常复杂）：运行检查；栈数据类型和操作吗数据参数吻合；跳转指令指定到合理的位置；<br>符号引用验证：常量池中描述类是否存在；访问的方法或字段是否存在且有足够的权限；</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>分配内存，并为类设置初始值<br>非静态属性设置为0、0.0、false<br>final类型，在准备阶段就会被赋予正确的值</p>
<h3 id="解析符"><a href="#解析符" class="headerlink" title="解析符"></a>解析符</h3><p>符号引用替换为直接引用；符号引用：字符串引用对象不一定被加载；直接饮用：指针或者地址编译量引用该对象一定在内存</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>执行类构造器clinit ：static变量赋值 static语句<br>子类的<clint>调用钱保证父类的clint被调用<br>clinit是线程安全的</clint></p>
<h1 id="类装载器ClassLoader"><a href="#类装载器ClassLoader" class="headerlink" title="类装载器ClassLoader"></a>类装载器ClassLoader</h1><p>ClassLoader读入Java字节码将类装载到JVM中<br>ClassLoader可以定制，满足不同 的字节码流获取方式<br>加载阶段</p>
<h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><p>loadClass  载入并返回一个Class<br>defineClass 定义一个类，不公开调用<br>findClass 回调方法足鼎ClassLoader的推荐做法<br>findLoadedClass 寻找已加载的类</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>BootStrap（rt.jar）、Extension(lib/ext/*/jar)、App 、CustomerClassLod er<br><img src="/2016/08/29/JVM/JVM6-类加载/pic1"><br>向上寻找父亲知否加载，父亲加载好返回Class给子类<br>-Xbootclasspath<br>让jvm从指定的路径中加载bootclass，用来替换jdk的rt.jar。一般不会用到。</p>
<h2 id="Thread-setContextClassLoader-上下文加载器"><a href="#Thread-setContextClassLoader-上下文加载器" class="headerlink" title="Thread.setContextClassLoader() 上下文加载器"></a>Thread.setContextClassLoader() 上下文加载器</h2><p>问题：上层ClassLoader无法查看底层ClassLoader中的类<br>是一个角色，任何一个加载器都可以是这个角色<br>解决顶层ClassLoader无法访问底层 ClassLoader<br>顶层classLoader传入底层classLoader<br>2.5 双亲委派模式的破坏<br>双亲模式是默认的模式但是不是必须这么做<br>Tomcat的WebappClassLoder就会先加载自己的Class，找不到再委托parent<br>OSGi（热加载）的ClassLOder芯层王庄结构，分局需要自由加载Class<br>class被替换后，系统无需重启，替换的类立即成效<br><img src="/2016/08/29/JVM/JVM6-类加载/pic2"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM5-GC收集器和参数]]></title>
      <url>http://baobing.github.io/2016/08/29/JVM/JVM5-GC%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="堆得回顾"><a href="#堆得回顾" class="headerlink" title="堆得回顾"></a>堆得回顾</h1><p>大对象、栈分配、不在新生代。<br>s0、s1大小相同、对称，只能一个可用。<br><a id="more"></a><br><img src="/2016/08/29/JVM/JVM5-GC收集器和参数/pic1"></p>
<h1 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h1><p>1）最古老，最稳定，效率高，可能产生较长的停顿。<br>只有一个线程回收，多核中性能不能得到发挥。<br>2）-XX:+UseSerialGC<br>新生代 老年代使用串行回收；新生代复制算法；老年代标记－压缩；<br> DefNew新生代、Tenured老年代、Perm永久代</p>
<h1 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h1><p>-XX:+UseParNewGC 新生代执行并行收集<br> ParNew 新生代</p>
<h1 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h1><p>1）类似于ParNew 新生代复制算法；老年代标记－压缩；<br>PSYoungGen年轻代/ParLOldGen老年代收集/PSPermGen</p>
<p>2）-XX:+UseParallelGC 使用Parallel收集器+老年代串行<br>-XX:+UseParallelOldGC 使用ParallelOldGC 使用Parallel收集器+并行老年代</p>
<p>3）-XX:MaxGCPauseMills 最大停顿时间，单位毫秒；GC尽力保证回收时间不超过设定值<br>-XX:GCTimeRation 0-100的取值范围；垃圾收集时间占总时间的比；默认99，即最大允许1%时间做GC ，比重大，GC时间长<br>这两个参数是矛盾的。因为停顿时间和吞吐量不可能同时调优。</p>
<h1 id="CMS收集器-Concurrent-Mark-Sweep"><a href="#CMS收集器-Concurrent-Mark-Sweep" class="headerlink" title="CMS收集器 Concurrent Mark Sweep"></a>CMS收集器 Concurrent Mark Sweep</h1><p>与应用程序一起并发执行；老年代收集器；并发阶段吞吐量降低；<br>降低停顿、清理不彻、不能再空间快满时清理<br>-XX:CMSInitiatingOccupancyFraction 设置出发GC的阈值 ；<br>如果空间不够，就会引起concurrent mode failure，遇到此情况停止业务，采用串行收集器。<br>CMS-concurrent-sweep 收集显示文字<br>-XX:+UseConcMarkSweepGC<br>新生代用并行收集器，老年代使用CMS+串行收集器<br>-XX:+UseCMSCompactAtFullColleciont  FullGC后，进行一次空间整理，整理过程是独占的，会引起停顿时间变长<br>-XX:CMSFullGCsBeforeCompaction 设置进行几次Full GC（CMS GC）后，进行一次碎片整理<br>-XX:ParallelCMSThreads 设定CMS的线程数量<br>-XX:+CMSClassUnloadingEnabled 允许对类元数据进行回收<br>工作流程：<br>（1）初始标记 根可以直接关联到的对象；速度快；需要停顿<br>（2）并发标记 主要标记过程，标记全部对象；主要步骤；<br>（3）重新标记  由于编发标记时，用户线程依然运行，因此正式清理前修正，需要停止其他线程<br>（4）并发清除 基于标记结果，直接清理对象<br>由于清理时并发的所以只能清除不能压缩<br><img src="/2016/08/29/JVM/JVM5-GC收集器和参数/pic2"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM4-垃圾回收]]></title>
      <url>http://baobing.github.io/2016/08/28/JVM/JVM4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<h1 id="垃圾判定"><a href="#垃圾判定" class="headerlink" title="垃圾判定"></a>垃圾判定</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>循环引用 每次都要技术影响性能<br><a id="more"></a></p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>GCroot :jvm栈中引用的对象，方法区中的类静态属性引用的对象，常量池的对象，本地方法栈JNI（native方法）的引用的对象</p>
<h1 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h1><p>1）标记-清除算法 老年代<br>2）标记压缩 老年代<br>3）复制算法 缺点空间浪费<br>4）分代算法<br>新生代分为一大两小，大小8:1<br>大对象：移到老年代。<br>小对象：放置到复制空间<br>老年对象：长期有效的对象<br>s0、s1只有一个能用<br><img src="/2016/08/28/JVM/JVM4-垃圾回收/pic1.png"></p>
<h1 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h1><p>短命对象归为新生代，长命对象归为老年代<br>根据不同代的特点，选取合适的收集算法<br>少量对象存活，适合复制算法。新生代。<br>大量对象存活，适合标记清理或者标记压缩。老年代。<br>对象多次GC未被回收放入老年代，或者新生代空间不足放入老年代。</p>
<h1 id="可触及性"><a href="#可触及性" class="headerlink" title="可触及性"></a>可触及性</h1><ul>
<li>可复活： 一旦所有引用被释放，就是可复活状态；因为在finalize()中可能复活该对象；<br>避免使用finalize()方法，被调用时间不确定，使用finally代替。<br>finalize方法一个对象只能使用一次。</li>
<li>GCroot :jvm栈中引用的对象，方法区中的类静态属性引用的对象，常量池的对象，本地方法栈JNI（native方法）的引用的对象<img src="/2016/08/28/JVM/JVM4-垃圾回收/pic2.png">
</li>
</ul>
<h1 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h1><p>所有Java代码停止，native代码可以执行，但不能和JVM交互<br>dump线程 死锁检查 dump堆 GC 可以一起StopTheWorld<br>GC线程之外的线程停止工作，进行垃圾回收。防止新的垃圾生成。<br>危害：长时间服务停止，没有响应；遇到HA系统，可能一起主备切换，严重危害生产环境。<br>老年代停顿时间长（微妙、秒、分钟都有可能）、新生代停顿时间短。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM3-参数设置]]></title>
      <url>http://baobing.github.io/2016/08/28/JVM/JVM3-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>-XX:+printGC 打印GC<br>-XX:+PrintGCDetails 打印GC详细信息,打印堆上各个空间的大小和使用率<br><a id="more"></a><br>-XX:+PrintGCTimeStamps 打印GC发生的时间戳<br>-Xloggc:log/gc.log 指定GC log的位置，以文件输出 帮助开发人员分析问题<br>-XX:+PrintHeapAtGC 打印GC前后堆空间的各个代使用情况和总空间<br>-XX:+TraceClassLoading 监控类的加载<br>-XX:+PrintClassHistogram 按下Ctrl+Break后，打印类的信息 显示：序号、实例数量、总大小、类型 [B指字节数组<br>-Xmx 最大堆<br>-Xmx 最小堆</p>
<p>空闲内存<br>System.out.println(Runtime.getRuntime().freeMemory());<br>使用内存<br>System.out.println(Runtime.getRuntime().totalMemory());</p>
<p>-Xmn 设置新生代大小<br>-XX:NewRatio 新生代和老年代的壁纸<br>4表示 新生代：老年代= 1：4 年轻带占堆得20%<br>-XX:SurvivorRation  一个suvivor与年轻带的比值 8 代表  survivor:eden 为 1：8</p>
<p>-XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件<br>-XX:+HeapDumpPath  导出文件路径<br>-XX:OnOutOfMemoryError = 执行一个脚本<br>在OOM时，执行一个脚本<br>官方推荐新生代栈3/8<br>幸存代1/10<br>-XX:PerSize 设置永久区大小<br>-XX:MaxPermSize 永久区最大</p>
<p>使用CGLIB等库的时候，可能会产生大量的类，这些类，有可能撑爆永久区导致OOM</p>
<p>-Xss 指定栈大小<br>通常几百K<br>决定函数调用的深度<br>每个线程都有独立的空间<br>局部变量、参数分配在栈上</p>
<p>-server 服务器模式运行-plan客户端模式启动，启动速度快</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM1-运行机制内存工作原理]]></title>
      <url>http://baobing.github.io/2016/08/28/JVM/JVM1-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="JVM-规范"><a href="#JVM-规范" class="headerlink" title="JVM 规范"></a>JVM 规范</h1><p>JVM可以运行除了java之外的很多语言，如groovy,jruby,scala。JVM规范包括：<br><a id="more"></a><br>1、class文件格式<br>2、数据的内部表示和存储<br>3、returnAddress 数据类型定义<br>4、invokedynamic<br>5、定义pc<br>6、堆、栈、方法区<br>7、 类型转化<br>8 、出栈入栈<br>9 、运算<br>10、流程控制<br>11、函数调用<br>12 对javaLibrary提供支持、反射、类加载、初始化类。安全、多线程、弱引用</p>
<h1 id="运行时数据区的划分"><a href="#运行时数据区的划分" class="headerlink" title="运行时数据区的划分"></a>运行时数据区的划分</h1><ul>
<li>程序计数器</li>
<li>java堆</li>
<li>java虚拟机栈</li>
<li>本地方法栈</li>
<li>方法区</li>
</ul>
<img src="/2016/08/28/JVM/JVM1-运行机制内存工作原理/pic4.png">
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>　　一块较小的内存空间，他的作用可以看做是当前线程所执行的字节码的行号指示器。线程私有的内存区域，生命周期与线程相同。<br>　　如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则个计数器值则为空。<br>　　此内存区域是唯一一个在java虚拟机规范中没有任何OutOfMemoryError情况的区域。<br>　　Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多喝处理器老说是一个内核）都只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的计数器。</p>
<h2 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a>JVM栈</h2><p>　　栈上分配 ：小对象，不存在内存逃逸的情况下，直接分配在栈上。可以自动回收，减轻GC压力，大对象或者逃逸对象无法栈上分配 。内存逃逸指被多个线程共享。</p>
<ul>
<li>执行字节码</li>
<li>线程私用</li>
<li>存储栈帧，执行java方法的调用、执行和退出</li>
<li>存在OutofMemoryError 和 stackOverFlow</li>
</ul>
<h1 id="本地方法栈NativeMethodStack"><a href="#本地方法栈NativeMethodStack" class="headerlink" title="本地方法栈NativeMethodStack"></a>本地方法栈NativeMethodStack</h1><p>　　本地方法栈与JVM栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为JVM使用到的Native方法服务</p>
<ul>
<li>线程私用</li>
<li>执行Native方法的调用、执行和退出</li>
<li>OutofMemoryError 和 stackOverFlow</li>
<li>hotspot将栈与本地方法栈合并。</li>
<li>方法结束自动释放内存</li>
</ul>
<h2 id="栈帧-stack-frame"><a href="#栈帧-stack-frame" class="headerlink" title="栈帧 stack frame"></a>栈帧 stack frame</h2><p>　　JVM栈中存储数据的内容，他被用于存储局部变量表、操作数和部分过程结果的数据结构，同时也被用来处理动态链接，方法返回值和异常分派。<br>　　包含局部变量表，操作数栈，动态链接信息，方法正常完成、异常完成信息<br>　　局部变量由如若干slot组成，长度由编译器决定。单个slot可以存储一个基本类型、reference和returnAddress的数据，两个slot可以存储一个类型为long或double的数据。reference 直接或间接的找到对象，直接或间接的找到对象在方法区中的数据类型。<br>第一个为本对象的引用地址。<br>每个方法创建一个栈帧，并且压入栈。<br>操作数栈，进行数学计算 。</p>
<h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><p>　　JVM明确要求该区域需要实现自动内存管理。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代：再细致一点的有Eden空间、FromSurvior空间，To Survivor、tenured  。从内存分配的角度来看，线程共享的Java堆中可能划分出多个私有的分配缓冲区（TLAB）。存在OutofMemoryError。</p>
<h1 id="方法区（别名-：Method-Area、Non-Heap、永久代、permanent-Gerneration）"><a href="#方法区（别名-：Method-Area、Non-Heap、永久代、permanent-Gerneration）" class="headerlink" title="方法区（别名 ：Method Area、Non-Heap、永久代、permanent Gerneration）"></a>方法区（别名 ：Method Area、Non-Heap、永久代、permanent Gerneration）</h1><ul>
<li>线程共享。</li>
<li>作用是存储Jva类的类型信息、常量、静态变量、即时编辑后的代码等数据。</li>
<li>JVM不要求该区域实现自动内存管理，常量池的回收已经类型信息的卸载</li>
<li>JDK1.2-1.6 hotspot 使用永久代与方法区 jdk1.7 使用堆 </li>
</ul>
<h2 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h2><ul>
<li>全局共享</li>
<li>方法区的一部分</li>
<li>作用是存储Java类文件常量池中的数据信息、字面量和符号引用</li>
<li>并非只有类加载使用，运行期也可以动态添加，如String.intern()</li>
</ul>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p> jdk1.4中nio被引入，目的是避免在java堆和native堆中来来回复制数据带来的性能损失。全局共享。</p>
<h1 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1><p>　　假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，这种分配方式成为“指针碰撞”。相对的分配方式成为“空闲列表”。<br>　　对象内存分配的同步：（1）采用CAS配上失败重试的方式保证更新操作的原子性（2）内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一块内存，本地线程缓冲（TLAB）。<br>　　对象头（Object Header）存放对象哈希码、对象的GC分代、类的元数据信息。</p>
<img src="/2016/08/28/JVM/JVM1-运行机制内存工作原理/pic1.png">
<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>　　对象头、实例数据、和对齐填充（Padding）。对象头包含两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等、这部分数据的长度在32位和64位，官方称它为Mark Word。25位存储哈希码、4位存储对象分代年龄、2位用于存储锁标志</p>
<p>对象的访问定位</p>
<p>（1）使用直接指针访问方式的最大好蠢就是速度更快，他节省了一次指针定位 的时间开销</p>
<img src="/2016/08/28/JVM/JVM1-运行机制内存工作原理/pic2.png">
<p>（2）使用句柄</p>
<img src="/2016/08/28/JVM/JVM1-运行机制内存工作原理/pic3.png">
<h1 id="Java反编译"><a href="#Java反编译" class="headerlink" title="Java反编译"></a>Java反编译</h1><p>javap -verbose Test01 反编译java字节码 查看java字节码</p>
<h1 id="happen-before原则（指令重排原则）"><a href="#happen-before原则（指令重排原则）" class="headerlink" title="happen-before原则（指令重排原则）"></a>happen-before原则（指令重排原则）</h1><ul>
<li>程序顺序原则：一个程序内保证语意的串行</li>
</ul>
<ul>
<li>volatile规则：volatile变量的写必须先于读 。</li>
</ul>
<ul>
<li>锁原则： 解锁必然先于加锁</li>
</ul>
<ul>
<li>传递性</li>
</ul>
<ul>
<li>线程的start方法优先于他的每一动作</li>
</ul>
<ul>
<li>线程的所有操作先于线程的中断</li>
</ul>
<ul>
<li>线程中断先于被中断线程的代码</li>
</ul>
<p>﻿- 构造函数先于finalize()</p>
<h1 id="解释运行"><a href="#解释运行" class="headerlink" title="解释运行"></a>解释运行</h1><ul>
<li>解释执行以解释方式运行字节码</li>
</ul>
<ul>
<li>解释执行的意思是读一句执行一句</li>
</ul>
<h1 id="编译运行JIT"><a href="#编译运行JIT" class="headerlink" title="编译运行JIT"></a>编译运行JIT</h1><ul>
<li>将字节码编译成机器码</li>
</ul>
<ul>
<li>直接执行机器码 </li>
</ul>
<ul>
<li>运行时编译</li>
</ul>
<ul>
<li>速度快十倍</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM11-Jetty简介]]></title>
      <url>http://baobing.github.io/2016/08/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM11-Jetty/</url>
      <content type="html"><![CDATA[<p>简要的介绍了Jetty的启动流程。对象池是一个很新颖的概念，与线程池有所区别。<br><a id="more"></a></p>
<h1 id="创建Server"><a href="#创建Server" class="headerlink" title="创建Server"></a>创建Server</h1><h2 id="初始化线程池"><a href="#初始化线程池" class="headerlink" title="初始化线程池"></a>初始化线程池</h2><p>使用QueuedThreadpool实现SizedThreadPool  </p>
<h2 id="初始化ServerConnector"><a href="#初始化ServerConnector" class="headerlink" title="初始化ServerConnector"></a>初始化ServerConnector</h2><ul>
<li>初始化SecheduledExecutorScheduler</li>
<li><p>初始化ByteBufferPool （相当于对象池，减少GC），创建对象的效率是很高的，回收很低。不能使用sycronized同步，效率太低，必须使用无锁。<br>ArrayByteBufferPool。大小不一定相同，池中保存很多大小不同的对象。<br>列外处理：如果社情的ByteBuffer过大或者过小无法在Pool中满足，则可以申请陈宫，但无法归还给Pool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ArrayByteBufferPool(int minSize,int increment,int maxSize)</span><br><span class="line">direct[] = </span><br><span class="line">indirect[] = </span><br><span class="line">Queue&lt;ByteBuffer&gt; = new ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">//1取得合适的Bucket 2从Bucket中取得ByteBuffer 3不存在创建</span><br><span class="line">acquire()</span><br><span class="line">//1取得合适的Bucket 2清空Buffer 3归还Pool </span><br><span class="line">release()</span><br></pre></td></tr></table></figure>
</li>
<li><p>ConnectionFactory维护<br>用于创建链接，比如Accept后，需要创建一个表示链接的对象</p>
</li>
<li><p>获取cpu数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cores = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新acceptor数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acceptors = Math.max(1,Math.min(4,cores/8));</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建acceptor线程组</p>
</li>
<li>初始化ServerConnectorManger<br>继承自<br>保存selector线程数量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.min(4,Runtime.getRuntime().availableProcessors()/2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="设置port"><a href="#设置port" class="headerlink" title="设置port"></a>设置port</h2><h2 id="关联Server和Connector"><a href="#关联Server和Connector" class="headerlink" title="关联Server和Connector"></a>关联Server和Connector</h2><h1 id="Server-start"><a href="#Server-start" class="headerlink" title="Server.start"></a>Server.start</h1><h2 id="设置启动状态"><a href="#设置启动状态" class="headerlink" title="设置启动状态"></a>设置启动状态</h2><h2 id="启动过程doStart"><a href="#启动过程doStart" class="headerlink" title="启动过程doStart"></a>启动过程doStart</h2><ul>
<li>注册ShutdownMonitor 远程控制接口</li>
<li>获取线程池</li>
<li>设置selector数量<br>累计所有connector的需要</li>
<li>计算所需的所有线程数量<br>如果大于默认的200则中断程序</li>
<li>维护Bean<br>启动QueudThreadPool：创建线程 设置线程的属性 启动线程<br>启动WebAppContext</li>
<li>启动Connector<br>取得ConnectionFactory<br>创建selector线程并启动<br>创建Acceptor线程 设置线程名字优先级，将线程放入acceptors 监听端口<br>没有Acceptor的情况<h2 id="启动完毕"><a href="#启动完毕" class="headerlink" title="启动完毕"></a>启动完毕</h2><h1 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h1><h2 id="Accept成功"><a href="#Accept成功" class="headerlink" title="Accept成功"></a>Accept成功</h2></li>
<li>设置为非阻塞模式</li>
<li>配置Socket</li>
<li>正式处理<br>选择可用ManagedSelector线程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private ManagedSelector chooseSelector()&#123;</span><br><span class="line">    //没有使用原子整数，不必担心因为多线程安全导致的问题</span><br><span class="line">    long s = _selectorIndex++;</span><br><span class="line">    int index = (int) (s % getSelectorCount());</span><br><span class="line">    return _selectors[index]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ManagedSelector处理<br>提交任务 加入到ConcurrentArrayQueue队列</p>
<h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>ManagedSelector.run()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void runChanges()&#123;</span><br><span class="line">    Runnable change;</span><br><span class="line">    while((change = _changes.poll())!=null)</span><br><span class="line">        runChange(change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>select()<br>处理SelectionKey</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM8-NIO和AIO]]></title>
      <url>http://baobing.github.io/2016/08/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM8-NIO%E5%92%8CAIO/</url>
      <content type="html"><![CDATA[<blockquote>
<p>圣人不死，大盗不止——庄子·胠箧</p>
</blockquote>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>New I/O的简称，与旧式的基于流的I/O方法相对。<br><a id="more"></a></p>
<ul>
<li>NIO是基于块(Block)的，它以块为基本单位处理数据</li>
<li>为所有的原始类型提供缓存（Buffer）支持</li>
<li>增加通道（Channel）对象，作为新的原始I/O抽象</li>
<li>支持文件锁（.lock文件作为一把锁）和内存映射文件的文件访问接口</li>
<li>提供了基于Selector的异步网络I/O<h2 id="Buffer和Channel"><a href="#Buffer和Channel" class="headerlink" title="Buffer和Channel"></a>Buffer和Channel</h2>file-&gt;channel-&gt;buffer-&gt;byte<br>file-&gt;channel-&gt;buffer-&gt;channel-&gt;file<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nioCopyFile</span><span class="params">(String resource, String destination)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(resource);</span><br><span class="line">    FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(destination);</span><br><span class="line">    FileChannel inputChannel = inputStream.getChannel();</span><br><span class="line">    FileChannel outputChannel = outputStream.getChannel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = inputChannel.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        outputChannel.write(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    inputChannel.close();</span><br><span class="line">    outputChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Buffer三个参数"><a href="#Buffer三个参数" class="headerlink" title="Buffer三个参数"></a>Buffer三个参数</h2><ul>
<li>position </li>
<li>capacity </li>
<li>limit</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>写模式</th>
<th>读模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置</td>
<td>当前缓冲区的位置，将从position的下一个位置写数据</td>
<td></td>
<td>当前缓冲区读取的位置，将从此位置后，读取数据</td>
</tr>
<tr>
<td>容量</td>
<td>缓冲区上限</td>
<td>缓冲区上限</td>
</tr>
<tr>
<td>上限</td>
<td>通常和容量相等</td>
<td>可读取的总容量和上次写入的数据量相等</td>
</tr>
</tbody>
</table>
<h2 id="Buffer操作"><a href="#Buffer操作" class="headerlink" title="Buffer操作"></a>Buffer操作</h2><p>Buffer.flip：通常将buffer从写模式转化为读模式<br>Buffer.rewind：将position设置为0，并且清楚标志位（mark）<br>Buffer.clear：将position设置0，同时将limit设置为capacity的大小，并清除标志位mark</p>
<h2 id="文件映射到内存"><a href="#文件映射到内存" class="headerlink" title="文件映射到内存"></a>文件映射到内存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nioFileToRandom</span><span class="params">(String resource)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(resource,<span class="string">"rw"</span>);</span><br><span class="line">    FileChannel fc = raf.getChannel();</span><br><span class="line">    MappedByteBuffer mappedByteBuffer = fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,raf.length());</span><br><span class="line">    <span class="keyword">while</span> ((mappedByteBuffer.hasRemaining()))&#123;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)mappedByteBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">    mappedByteBuffer.put(<span class="number">0</span>,(<span class="keyword">byte</span>)<span class="number">98</span>);</span><br><span class="line">    raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="SocketServer编写简单服务器"><a href="#SocketServer编写简单服务器" class="headerlink" title="SocketServer编写简单服务器"></a>SocketServer编写简单服务器</h2><p>缺点： </p>
<ul>
<li>为每一个客户端使用一个线程，如果客户端出现延时等异常，线程可能会被占用很长时间。因为数据的准备和读取都在这个线程中。</li>
<li>此时，如果客户端数量众多，可能会消耗大量的系统资源。</li>
</ul>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>select() 无数据阻塞，有数据返回selectionKey。SelectionKey便是Selector和Channel的关系。从SelectionKey中得到Channel（数据已经准备），并读取数据。<br>selectNow() 没有数据返回0,<br>一个线程监控大量的客户端线程，减少数据准备对业务处理线程影响<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by baobing on 2016/8/23.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadNio</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Socket,Long&gt; timeStat = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> LinkedList&lt;ByteBuffer&gt; outputQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> LinkedList <span class="title">getOutputQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> outputQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(ByteBuffer byteBuffer)</span></span>&#123;</span><br><span class="line">            outputQueue.addFirst(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HandlerMsg</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        SelectionKey selectionKey;</span><br><span class="line">        ByteBuffer byteBuffer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HandlerMsg</span><span class="params">(SelectionKey selectionKey, ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">            <span class="keyword">this</span>.byteBuffer = byteBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            EchoClient echoClient = (EchoClient) selectionKey.attachment();</span><br><span class="line">            echoClient.enqueue(byteBuffer);</span><br><span class="line">            <span class="comment">//修改兴趣事件</span></span><br><span class="line">            selectionKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">            selector.wakeup();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span>  <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        selector = SelectorProvider.provider().openSelector();</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//非阻塞 需要监听事件</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(address);</span><br><span class="line">        <span class="comment">//感兴趣的事件进行注册</span></span><br><span class="line">        SelectionKey selectionKey = serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set readyKeys = selector.selectedKeys();</span><br><span class="line">            Iterator iterator = readyKeys.iterator();</span><br><span class="line">            <span class="keyword">long</span> e = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = (SelectionKey) iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    doAccept(selectionKey);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isValid() &amp;&amp; selectionKey.isReadable())&#123;</span><br><span class="line">                    doRead(selectionKey);</span><br><span class="line">                &#125;  <span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isValid() &amp;&amp; selectionKey.isWritable())&#123;</span><br><span class="line">                    doWrite(selectionKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAccept</span><span class="params">(SelectionKey selectionKey)</span></span>&#123;</span><br><span class="line">        ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">        SocketChannel clientChannel ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientChannel = server.accept();</span><br><span class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//注册读取事件</span></span><br><span class="line">            SelectionKey clientKey = clientChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            clientKey.attach(<span class="keyword">new</span> EchoClient());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SelectionKey selectionKey)</span></span>&#123;</span><br><span class="line">        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len = socketChannel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(len == -<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> HandlerMsg(selectionKey,byteBuffer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SelectionKey selectionKey)</span></span>&#123;</span><br><span class="line">        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">        EchoClient echoClient = (EchoClient) selectionKey.attachment();</span><br><span class="line">        LinkedList&lt;ByteBuffer&gt; outputQueue = echoClient.getOutputQueue();</span><br><span class="line">        ByteBuffer byteBuffer = outputQueue.getLast();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len = socketChannel.write(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">                disconnet();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(byteBuffer.remaining() == <span class="number">0</span>)&#123;</span><br><span class="line">                outputQueue.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(outputQueue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            selectionKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            MultiThreadNio server = <span class="keyword">new</span> MultiThreadNio();</span><br><span class="line">            server.startServer();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"exception caught,program exiting..."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="网络编程AIO"><a href="#网络编程AIO" class="headerlink" title="网络编程AIO"></a>网络编程AIO</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>数据读取完毕通知业务线程，使用回调函数的形式</li>
<li>AIO不加快IO的读写速度，只是改变线程对IO的处理方式，从而提升性能。<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2></li>
</ul>
<img src="/2016/08/27/并发编程/GYM8-NIO和AIO/AIOcode.jpg" title="使用示例">]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ReentrantLock源码分析]]></title>
      <url>http://baobing.github.io/2016/08/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>重入锁是java级别的锁。查看重入锁源码还是应该先阅读AbstractQueuedSynchronizer源码。</p>
<blockquote>
<p><a target="_blank" href="http://baobing.github.io/2016/08/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%881%EF%BC%89/">AbstractQueuedSynchronizer解析（1）</a><br><a target="_blank" href="http://baobing.github.io/2016/08/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%882%EF%BC%89/">AbstractQueuedSynchronizer解析（2）</a></p>
</blockquote>
<a id="more"></a>
<h1 id="ReentrantLock类概述"><a href="#ReentrantLock类概述" class="headerlink" title="ReentrantLock类概述"></a>ReentrantLock类概述</h1><p>　　互斥的重入锁，与sychronized拥有相同的行为，但是它也有扩展的功能。最后一个持有锁的线程拥有重入锁。线程通过调用lock方法获取重入锁。如果当前线程已经持有锁将立刻返回。可以通过调用isHeldByCurrentThread方法检查锁是否被占有。</p>
<p>　　这个类的构造器允许传入fairness参数。设置这个参数为true的时候，等待锁时间最长的线程将得到获取锁的权利。否则不会保证特定的获取锁的顺序。公平锁的性能会稍微低一点，但是它会保证每个线程都不会处于饥饿现象。机制一点，公平锁平不能保证线程按照计划的顺序执行。</p>
<p>　　重入锁最多可以被同一个线程2147483647递归持有（每次持有锁都不释放锁）</p>
<h1 id="非公平锁获取锁"><a href="#非公平锁获取锁" class="headerlink" title="非公平锁获取锁"></a>非公平锁获取锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">﻿    ﻿ <span class="comment">//直接获取锁，不进行排队</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//失败之后再次获取锁</span></span><br><span class="line"></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非公平锁tryAcquire的业务逻辑由nonfairTryAcquire实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">    ﻿       <span class="comment">//锁未被任何线程占据</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line"></span><br><span class="line">              setExclusiveOwnerThread(current);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="comment">//锁之前被当前线程占据，设置state为锁被当前线程重入次数</span></span><br><span class="line">    ﻿    ﻿    <span class="comment">//没有使用原子操作，没有同步，因为保证对state的操作只有一个线程</span></span><br><span class="line">    ﻿    ﻿    <span class="comment">//而且state被volatile修饰，内存可见性一定能保证</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">          setState(nextc);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="公平锁获取锁"><a href="#公平锁获取锁" class="headerlink" title="公平锁获取锁"></a>公平锁获取锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">﻿    <span class="comment">// 等待队列为空即可获得锁，否则加入等待队列</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line"></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line"></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//锁之前被当前线程占据，设置state为锁被当前线程重入次数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">            setState(nextc);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h1><p>只有持有锁的线程才能释放锁，改变state字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line"></span><br><span class="line">    ﻿    ﻿    <span class="comment">//必须持有锁才能释放</span></span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line"></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">          free = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ﻿    ﻿    <span class="comment">//只有持有锁的线程才能改变state字段，不能担心线程安全</span></span><br><span class="line">      setState(c);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> free;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ThreadPoolExecutor源码解析]]></title>
      <url>http://baobing.github.io/2016/08/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>　　线程池的使用范围实在是太广了，很多组件的底层使用线程池创建、管理线程。之前有一篇关于线程池使用，增强的文章:<a href="/2016/08/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM4-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">GYM4-线程池</a><br><a id="more"></a></p>
<h1 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//保存线程运行状态和线程数量两个重要信息，采用一个数字保存多个信息的目的</span></span><br><span class="line"><span class="comment">//是保证多个信息的并发安全 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个队列持有所有还为运行的任务。使用isEmpty判断队列是否为空。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存所有的工作线程，只有持有mainLock锁的才能有操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果为false，空闲的核心线程仍然可以存活</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//除非allowCoreThreadTimeOut为真，否则这个值代表最小的一直存活的</span></span><br><span class="line"> <span class="comment">//工作线程的数量.</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//最大可获得线程数量，只有持有mainLock锁才能操作</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//空闲线程的超时时间以纳秒计时。线程数量大于corePoolSize时并且</span></span><br><span class="line"> <span class="comment">//allowCoreThreadTimeOut为真，线程超时时间才能工作</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//工作线程集合以及相关记录变量的锁。使用锁而不是并发set是因为，</span></span><br><span class="line"> <span class="comment">//可以避免一些不必要的中断。简化了相关的记录变量 例如largestPoolSize。</span></span><br><span class="line"> <span class="comment">// shutdown 和shutdownNow方法都需要持有锁，目的是去报分别检查</span></span><br><span class="line"> <span class="comment">//中断权限和是否正在中断工作线程仍能平稳运行</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//终结使用的condition</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//完成任务的数量，持有mainLock可以修改</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//所有的线程由threadFactory创建，设置线程name，Deamon等</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//线程池饱和时的拒绝策略一共四种 ，可以参看《GYM4-线程池》</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br></pre></td></tr></table></figure>
<h1 id="execute操作"><a href="#execute操作" class="headerlink" title="execute操作"></a>execute操作</h1><p>　　Executor接口定义的方法，执行提交的任务。执行任务的具体线程可能是新创建的也可能是已经存在的。如果线程池关闭或者容量达到上限，RejectedExecutionHandler持有拒绝策略。　　<br>任务提交分为三个步骤：<br>　　1.正在运行的线程数量小于corePoolSize，尝试创建一个新的线程执行当前任务。调用addWorker方法，它会使用原子操作检查runState和workerCount。当无法执行提交任务时，返回false。<br>　　2.如果成功的入队，我们仍然需要检查我们可以让它入队（因为存在最后一个线程结束的可能），或者进入这个方法时线程池关闭。<br>　　3.如果进入任务队列失败，我们尝试创建一个新的线程。如果失败，一定是线程池是关闭或者饱和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//正在线程数量小于小于核心线程数</span></span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//添加新的线程不一定成功，没有使用锁导致可能性比较多</span></span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">           c = ctl.get();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建新的线程失败，加入阻塞队列</span></span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line"></span><br><span class="line">               reject(command);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="comment">//入队失败或线程池关闭，创建新的线程，创建失败拒绝当前任务</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line"></span><br><span class="line">           reject(command);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="addWroker操作"><a href="#addWroker操作" class="headerlink" title="addWroker操作"></a>addWroker操作</h1><p>　　根据当前线程池的装填和给定的边界（核心、最大线程数）检查时候能够创建新的工作线程。如果创建成功调整工作线程的数量，创建一个新的线程运行当前任务。因为线程池关闭或者正在关闭导致的线程创建失败返回false。不管是因为线程工厂返回null还是因为异常（典型是线程启动时的OutOfMemoryError），我们都要回滚。<br>java中的标签：</p>
<ul>
<li>break lable 跳转到标签所在的循环，并且跳过循环</li>
<li>continue lable 跳转到标签所在的循环，并且继续执行循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        retry:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阻塞队列是否为空</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line"></span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line"></span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一直尝试将工作线程数量加一</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果工作线程数量大于允许的最大线程数量返回false</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line"></span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试工作线程数量加一。成功跳出最外层循环，失败往下走</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//状态发生改变返回第一次循环</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//创建新的工作线程</span></span><br><span class="line"></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取锁并将Worker加入集合</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line"></span><br><span class="line">                mainLock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line"></span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                        workers.add(w);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line"></span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line"></span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    mainLock.unlock();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加成功启动线程</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line"></span><br><span class="line">                    t.start();</span><br><span class="line"></span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line"></span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Worker子类"><a href="#Worker子类" class="headerlink" title="Worker子类"></a>Worker子类</h1><p>持有运行任务的线程。继承自AbstractQueuedSynchronizer，实现了非重入的锁，保证工作线程的线程安全。参考<a href="2016/08/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%881%EF%BC%89/">AbstractQueuedSynchronizer解析（1）</a></p>
<p>同时Worker实现Runnable接口，也就是说他会作为一个任务被执行，而执行这个任务的线程就是Woker自身包含的Thread字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//工作线程</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始的任务可能为空</span></span><br><span class="line"></span><br><span class="line"> Runnable firstTask;</span><br><span class="line"></span><br><span class="line"> Worker(Runnable firstTask) &#123;</span><br><span class="line"></span><br><span class="line">     setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//线程运行的runnable就是Woker自身定义的run方法</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread属性将要运行的任务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     runWorker(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="runWoker方法"><a href="#runWoker方法" class="headerlink" title="runWoker方法"></a>runWoker方法</h2><p>工作线程不断从队列中获取任务并且执行他们，下面是对应的几个问题：<br>1.一开始执行firstTask，之后从阻塞队列中获取。如果获得的任务为null说明线程池状态或者参数发生改变，当前工作者应该被清理。<br>2.任务执行前持有锁是为了阻止其他线程中断正在执行的任务，除非线程器停止，线程不会被中断。<br>3.调用beforeExecute可能产生异常，这种情况下我们会杀死线程而不是继续执行任务。<br>4.如果任务报错，我们执行afterExecute方法。<br>5.afterExecute方法异常，线程被杀死。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line"></span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//初始任务为空的话，从队列中获取任务</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                w.lock();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//线程池停止，确保线程中断，否则相反。recheck的目的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//是处理shutdownNow方法清理中断的竞争问题。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line"></span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line"></span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line"></span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line"></span><br><span class="line">                    wt.interrupt();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//调用beforeExecute、run、afterExecute三个方法</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line"></span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        task.run();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line"></span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line"></span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line"></span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    w.completedTasks++;</span><br><span class="line"></span><br><span class="line">                    w.unlock();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AbstractQueuedSynchronizer解析（2）]]></title>
      <url>http://baobing.github.io/2016/08/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>针对性重复练习。持续做你不会做的事。</p>
</blockquote>
<a id="more"></a>
<h1 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h1><p>　　Node节点组成的队列是CLH(Craig, Landin, and Hagersten)的变种。CLH通常作为自旋锁使用。我们将它作为阻塞同步器使用，但是前驱节点持有线程的控制信息的策略是相同的。每个节点中的状态字段保存线程的阻塞信息。前驱节点释放时，当前节点将得到通知信号。每个队列中的节点作为specific-notification-style监视器，持有唯一的等待线程。队列中的第一个线程有机会尝试获取锁，但是不保证一定成功获得（非公平锁），它只是给了线程竞争的权利，所以被释放的竞争者可能再次等待。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     +------+  prev +-----+       +-----+</span><br><span class="line">head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">     +------+       +-----+       +-----+</span><br></pre></td></tr></table></figure></p>
<p>　　进入到CLH队列，你只需要一个原子操作将它拼接在队列尾部。出队，你只需要重置头部节点。<br>插入CLH队列需要一个放入尾部的原子操作，因此存在一个指针指向队中和非队中的分界点。出队需要更新“head”指针。CLH队列需要花费大量的工作决定队首能否成功获取锁，还需要花费一部分时间处理超时和中断导致的任务取消。<br>　　pre指针链接的链表主要保存取消节点。如果一个节点已经取消，它的后继指针被连接到<br>一个未取消的前驱节点。<br>　　我们使用next指针的链接的链表实现阻塞队列机制。每个节点内部保存线程的id，所以一个前驱节点通过遍历next指针查找下一个应该被唤醒的节点。确认后继者过程必须避免新入队节点设置next指针的并发竞争。</p>
<h2 id="Node源码"><a href="#Node源码" class="headerlink" title="Node源码"></a>Node源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//需要注意的是下面两个节点都是静态属性，用来表示当前共享还是独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 状态字段 ，只有一下几种值</span></span><br><span class="line"><span class="comment">    * SIGNAL：当前节点后继者被阻塞（通过park方法）。节点被释放或者取消时，</span></span><br><span class="line"><span class="comment">    * 后继节点必须被唤醒。为了避免竞争，获取方法，acquire 方法的过程必须是：</span></span><br><span class="line"><span class="comment">    * 首先获取一个锁释放信号量；然后使用原子操作获取锁；最后获取失败阻塞线程。</span></span><br><span class="line"><span class="comment">    * CANCELLED:  当前节点因为超市或者中断被取消。节点永远不会离开</span></span><br><span class="line"><span class="comment">    * 这个状态。尤其取消的线程节点不会再次被阻塞。</span></span><br><span class="line"><span class="comment">    * CONDITION:节点处于Condition队列。状态值改变前，它不会被用作同步队列</span></span><br><span class="line"><span class="comment">    * 的节点，这个时候状态值被设置为0</span></span><br><span class="line"><span class="comment">    * PROPAGATE：共享锁被释放时，把这个信号传递给其他节点。及时其他操作被</span></span><br><span class="line"><span class="comment">    * 干扰doReleaseShared操作仍然能够传递。</span></span><br><span class="line"><span class="comment">    * 0:          None of the above</span></span><br><span class="line"><span class="comment">    * 为负数时，表示当前节点不需要被唤醒。这个字段的初始值是0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参考waitStatus字段，连接到一个前驱节点。入队时赋值，出队设置为null。</span></span><br><span class="line"><span class="comment">    * 在前驱节点取消时，我们将当前节点链接到一个永远不会取消的节，</span></span><br><span class="line"><span class="comment">    *  head节点永远不会取消。只有被成功获取锁的节点才能变为head节点。</span></span><br><span class="line"><span class="comment">    * 取消的节点不可能成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接到后继节点，在它释放的时候唤醒后继节点。入队时复制，</span></span><br><span class="line"><span class="comment">     * 绕过取消的前驱节点时被修改，出队时被设置为null。直到节点成功加入</span></span><br><span class="line"><span class="comment">     * 到对位，enq操作才会为它的前驱节点赋值。说以看到next字段为null</span></span><br><span class="line"><span class="comment">     * 的节点不意味着他是队尾。 However, if a next field appears</span></span><br><span class="line"><span class="comment">     * to be null, we can scan prev's from the tail to double-check. 、</span></span><br><span class="line"><span class="comment">     * 取消节点的nex字段被设置为它自身 而不是null，这样有利于isOnSyncQueue</span></span><br><span class="line"><span class="comment">     * 操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拥有当前结点的线程。</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接等待condition的下一个节点，或者特定值 SHARED。</span></span><br><span class="line"><span class="comment">     * 因为condition队列只有在独占模式下才会持有。再次获取锁的时候转变。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="addWaiter入队操作"><a href="#addWaiter入队操作" class="headerlink" title="addWaiter入队操作"></a>addWaiter入队操作</h1><p>　　利用当前线程和给定的模式创建Node节点并且入队。head和tail字段的初始化在这个操作中完成。初始化过程：</p>
<ul>
<li>如果tail字段为null，生成一个新的Node节点。</li>
<li>head和tail指向这个新节点。</li>
<li>新的节点waitStatus为0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    Node pred = tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tail为null，说明tail第一次被初始化</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        node.prev = pred;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cas操作设置node为tail，失败进入enq</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line"></span><br><span class="line">            pred.next = node;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enq(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个线程加入到队尾，或者tail未被初始化。</span></span><br><span class="line">    <span class="comment">//cas操作可能失败，必须使用循环保证最终成功。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        Node t = tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//尾部为null，初始化tail</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line"></span><br><span class="line">                tail = head;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            node.prev = t;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line"></span><br><span class="line">                t.next = node;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="acquire独占模式获取锁操作"><a href="#acquire独占模式获取锁操作" class="headerlink" title="acquire独占模式获取锁操作"></a>acquire独占模式获取锁操作</h1><p>　　子类通过调用这个方法获取锁。取得锁的规则有tryAcquire方法持有，子类重写这个方法而且不会阻塞线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tryAcquire返回false，那么就加入阻塞队列阻塞线程，并等待前继结点释放锁。</span></span><br><span class="line">    <span class="comment">// acquireQueued返回true说明线程应该被中断</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquireQueued返回true，说明当前线程被中断唤醒后获取到锁，</span></span><br><span class="line">        <span class="comment">// 重置其interrupt，status为true。</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　tryAcquire失败线程会加入队列 线程可能会反复的被阻塞和唤醒直到tryAcquire成功，这是因为线程可能被中断， 而acquireQueued方法中会保证忽视中断，只有tryAcquire成功了才返回。<br>　　中断版本的独占获取是acquireInterruptibly方法，doAcquireInterruptibly这个方法中如果线程被中断则acquireInterruptibly会抛出InterruptedException异常。addWaiter方法只是入队操作，acquireQueued方法是主要逻辑，需要重点理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋re-check</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前继是head,说明next就是node了，则尝试获取锁。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前继出队，node成为head</span></span><br><span class="line">                setHead(node);</span><br><span class="line"></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// p != head 或者 p == head但是tryAcquire失败了，那么</span></span><br><span class="line">            <span class="comment">// 应该阻塞当前线程等待前继唤醒。需要设置前继的waitStaus为SIGNAL</span></span><br><span class="line">            <span class="comment">// parkAndCheckInterrupt返回可能是前继unpark或线程被中断。</span></span><br><span class="line">            <span class="comment">// parkAndCheckInterrupt返回值代表线程是否被中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 说明当前线程是被中断唤醒的。</span></span><br><span class="line">                <span class="comment">//注意：线程被中断之后会继续走到if处去判断，也就是会忽视中断。</span></span><br><span class="line">                <span class="comment">// 除非碰巧线程中断后acquire成功了，那么根据Java的最佳实践，</span></span><br><span class="line">                <span class="comment">// 需要重新设置线程的中断状态（acquire.selfInterrupt）。</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出现异常</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line"></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shouldParkAfterFailedAcquire方法的作用是：</p>
<ul>
<li>确定后继是否需要park;</li>
<li>跳过被取消的结点;</li>
<li>设置前继的waitStatus为SIGNAL.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ﻿<span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前继结点已经准备好unpark其后继了，所以后继可以安全的park</span></span><br><span class="line">    ﻿<span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"></span><br><span class="line">        ﻿<span class="comment">/*</span></span><br><span class="line"><span class="comment">        ﻿ * This node has already set status asking a release to signal it,</span></span><br><span class="line"><span class="comment">       ﻿  * so it can safely park.</span></span><br><span class="line"><span class="comment">      ﻿   */</span></span><br><span class="line"></span><br><span class="line">        ﻿<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    ﻿<span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">// CANCELLED</span></span><br><span class="line"></span><br><span class="line">    ﻿    <span class="comment">// 跳过被取消的结点。</span></span><br><span class="line">    ﻿    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">    ﻿        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">     ﻿   &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ﻿    pred.next = node;    ﻿</span><br><span class="line"></span><br><span class="line">    ﻿&#125; <span class="keyword">else</span> &#123;<span class="comment">// 0 或 PROPAGATE (CONDITION用在ConditonObject，这里不会是这个值)</span></span><br><span class="line"></span><br><span class="line">       ﻿ <span class="comment">/**</span></span><br><span class="line"><span class="comment">         ﻿* waitStatus 等于0（初始化）或PROPAGATE。说明线程还没有park，会先重试 </span></span><br><span class="line"><span class="comment">        ﻿ * 确定无法acquire到再park。</span></span><br><span class="line"><span class="comment">       ﻿  */</span></span><br><span class="line">       ﻿ <span class="comment">// 更新pred结点waitStatus为SIGNAL    ﻿</span></span><br><span class="line">       ﻿ compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line"></span><br><span class="line">    ﻿&#125;</span><br><span class="line"></span><br><span class="line">    ﻿<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程被唤醒只可能是：被unpark，被中断或伪唤醒。被中断会设置interrupted，acquire方法返回前会 selfInterrupt重置下线程的中断状态，如果是伪唤醒的话会for循环re-check。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="独占模式释放"><a href="#独占模式释放" class="headerlink" title="独占模式释放"></a>独占模式释放</h1><p>比较简单只要直接唤醒后续结点就可以了，后续结点会从parkAndCheckInterrupt方法中返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tryReease由子类实现，通过设置state值来达到同步的效果。</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"></span><br><span class="line">        Node h = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waitStatus为0说明是初始化的空队列</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒后续的结点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Node s = node.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                    s = t;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="acquireShared共享获取模式"><a href="#acquireShared共享获取模式" class="headerlink" title="acquireShared共享获取模式"></a>acquireShared共享获取模式</h1><p>获取共享锁过程与独占模式基本相同。<br>－ 尝试获取加入队列失败加入队列<br>－ 如果是队首再次获取锁<br>－ 再次失败挂起当前线程，等待被唤醒。<br>与独占模式不同的是成功获取共享锁之后调用setHeadAndPropagate，继续向后遍历队列，寻找相邻的共享节点给予锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果没有许可了则入队等待</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 等待前继释放并传递</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">// 尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取成功则前继出队，跟独占不同的是</span></span><br><span class="line">                    <span class="comment">// 会往后面结点传播唤醒的操作，保证剩下等待的线程能够尽快 获取到剩下的许可。</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// p != head || r &lt; 0</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setHeadAndPropagate方法会将node设置为head。如果当前结点acquire到了之后发现还有许可可以被获取，则继续释放自己的后继， 后继会将这个操作传递下去。这就是PROPAGATE状态的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 以下情况尝试唤醒后继的结点：</span></span><br><span class="line"><span class="comment">     * propagate &gt; 0说明许可还有能够继续被线程acquire;</span></span><br><span class="line"><span class="comment">     * 或者之前的head被设置为PROPAGATE(PROPAGATE可以被转换为SIGNAL)说明需要往后传递;</span></span><br><span class="line"><span class="comment">     * 或者为null,我们还不确定什么情况。</span></span><br><span class="line"><span class="comment">     * 并且后继结点是共享模式或者为如上为null。</span></span><br><span class="line"><span class="comment">     * 上面的检查有点保守，在有多个线程竞争获取/释放的时候可能会导致不必要的唤醒。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 后继结是共享模式或者s == null（不知道什么情况）</span></span><br><span class="line">        <span class="comment">// 如果后继是独占模式，那么即使剩下的许可大于0也不会继续往后传递唤醒操作</span></span><br><span class="line">        <span class="comment">// 即使后面有结点是共享模式。</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 唤醒后继结点</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 队列不为空且有后继结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 不管是共享还是独占只有结点状态为SIGNAL才尝试唤醒后继结点</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 将waitStatus设置为0</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);<span class="comment">// 唤醒后继结点</span></span><br><span class="line">                <span class="comment">// 如果状态为0则更新状态为PROPAGATE，更新失败则重试</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果过程中head被修改了则重试。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文章：<a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-AbstractQueuedSynchronizer.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AbstractQueuedSynchronizer解析（1）]]></title>
      <url>http://baobing.github.io/2016/08/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>不以文害辞,不以辞害志;以意逆志，是为得之。——孟子</p>
</blockquote>
<p>　最近在看ThreadPoolExecutor类的源码。我发现其中一个重要的子类Woker继承自AbstractQueuedSynchronizer（简称AQS）。AQS帮助Woker类轻松实现一个非重入的排它锁。不看不知道一看吓一跳，竟然有11个类继承自AQS，而且这些类都是并发包下面使用频率很高的类。这足以说明这个类的含金量，值得认真研究一下。<br>　<a id="more"></a></p>
<img src="/2016/08/19/并发编程/AbstractQueuedSynchronizer解析（1）/AQSimplement.png" title="AQS子类">
<h1 id="源码注释"><a href="#源码注释" class="headerlink" title="源码注释"></a>源码注释</h1><p>　　为实现依赖于等待队列的阻塞锁和相关同步器（信号量、事件）提供一个框架。此类的设计目标是成为依靠单个原子整形数值来表示状态的大多数同步器的基础。子类必须定义更改此状态的方法，并定义哪种状态对于此对象意味着被获取或被释放。实现这些条件之后，此类中的其他方法就可以实现所有排队和阻塞机制。子类可以维护其他状态字段，但是只有原子更新整形值的应用方法（涉及到同步）被追踪，以下是这三个应用方法 getState()、setState(int) 和compareAndSetState(int, int)。</p>
<p>　　应该将子类定义为非公共内部帮助类，可用它们来实现其内部类的同步属性。AbstractQueuedSynchronizer类 没有实现任何同步接口。而是定义了诸如acquireInterruptibly(int) 之类的方法，在适当的时候可以通过具体的锁和相关同步器调用它们，以达到同步的目的。</p>
<p>　　此类支持默认的独占 模式和共享 模式任何一种方式，也可以同时支持两种模式。处于独占模式下，其他线程不可能再成功获取锁。在共享模式下，多个线程获可能成功获得锁。此类只是机械地感知到在共享模式下成功获取某一锁时，下一个等待线程（如果存在）也必须确定是否可以成功获取该锁。处于不同模式下的等待线程可以共享相同的 FIFO 队列。通常，子类只支持其中一种模式，但两种模式都可以在ReadWriteLock 中发挥作用。只支持独占模式或者只支持共享模式的子类不必定义未使用模式的方法。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>AQS简核心是通过一个共享变量来同步状态，变量的状态由子类去维护，而AQS框架做的是：</p>
<ul>
<li>线程阻塞队列的维护</li>
<li>线程阻塞和唤醒。</li>
</ul>
<p>　　共享变量的修改都是通过CAS操作完成的。AbstractQueuedSynchronizer类是一个典型的模板方法类。它的主要方法是acquire和release。  acquire方法用来获取锁，返回true说明线程获取成功继续执行，一旦返回false则线程加入到等待队列中，等待被唤醒，release方法用来释放锁。 一般来说实现的时候这两个方法被封装为lock和unlock方法。  </p>
<p>下面这4个方法由子类去实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor-Worker"><a href="#ThreadPoolExecutor-Worker" class="headerlink" title="ThreadPoolExecutor.Worker"></a>ThreadPoolExecutor.Worker</h2><p>下面就来看一下以下Worker的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * Worker类为正在运行任务的线程维护中断状态控制，以及其他次要的工作。该类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 通过继承AbstractQueuedSynchronizer类,环绕任务执行加锁，简化锁地获取与释放</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 过程。不使用中断旨在唤醒唤醒一个等待任务的线程，而不是一个正在运行的任务线程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 我们实现一个简单的不可重入锁,而不是直接使用互斥锁ReentrantLock。因为我们</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 不希望当他们调用线程池控制方法如setCorePoolSize时，工作者的任务的锁被再次获取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 为了抑制线程真正启动前中断，我们初始化锁的状态为负值，开始时变为正值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lock methods    state是父类AbstractQueuedSynchronizer的字段</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试获取当前的worker。重载父类方法，父类中不支持该方法。</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放当前的worker</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取失败放入队列，并且线程被中断</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Thread t;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    t.interrupt();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子操作改变锁的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM4-线程池]]></title>
      <url>http://baobing.github.io/2016/08/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM4-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<h1 id="1、线程池"><a href="#1、线程池" class="headerlink" title="1、线程池"></a>1、线程池</h1><p>优点：将更多的精力放在业务上，不必操心线程的创建和销毁。节省线程创建销毁的时间。<br><a id="more"></a></p>
<h2 id="手写简易ThreadPool"><a href="#手写简易ThreadPool" class="headerlink" title="手写简易ThreadPool"></a>手写简易ThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyThreadPool instance = <span class="keyword">new</span> MyThreadPool();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Worker&gt; idleThreads;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadCounter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShutDown =<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        idleThreads = <span class="keyword">new</span> Vector&lt;Worker&gt;(<span class="number">10</span>);</span><br><span class="line">        threadCounter = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCreatedThreadCount</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> threadCounter;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> MyThreadPool <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> instance;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">repool</span><span class="params">(Worker repoolingThread)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isShutDown) repoolingThread.shutDown();</span><br><span class="line">        <span class="keyword">else</span> idleThreads.add(repoolingThread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isShutDown = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(Worker worker : idleThreads)  worker.shutDown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Runnable target)</span></span>&#123;</span><br><span class="line">        Worker thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(idleThreads.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> lastIndex = idleThreads.size()-<span class="number">1</span>;</span><br><span class="line">            thread = (Worker) idleThreads.get(lastIndex);</span><br><span class="line">            idleThreads.remove(lastIndex);</span><br><span class="line">            thread.setTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> MyThreadPool pool;</span><br><span class="line">        <span class="keyword">private</span> Runnable target;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isIdle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="title">Worker</span><span class="params">(Runnable target, String name , MyThreadPool pool)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.pool = pool;</span><br><span class="line">            <span class="keyword">this</span>.target =target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Runnable <span class="title">getTarget</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  target;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Runnable target)</span></span>&#123;<span class="keyword">this</span>.target = target;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIdle</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> isIdle;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isShutdown = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!isShutdown)&#123;</span><br><span class="line">                isIdle =<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(target != <span class="keyword">null</span>) target.run();</span><br><span class="line">                isIdle = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pool.repool(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程池重要接口"><a href="#线程池重要接口" class="headerlink" title="线程池重要接口"></a>线程池重要接口</h1><img src="/2016/08/12/并发编程/GYM4-线程池/ExcutorService.jpg" title="图一">
<h2 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h2><p>　　执行已提交的 Runnable 任务的对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法。通常使用 Executor 而不是显式地创建线程。例如，可能会使用以下方法，而不是为一组任务中的每个任务调用 new Thread(new(RunnableTask())).start()：</p>
<h2 id="ExecuteService"><a href="#ExecuteService" class="headerlink" title="ExecuteService"></a>ExecuteService</h2><p>　　Executor提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。<br>　　可以关闭 ExecutorService，这将导致其拒绝新任务。提供两个方法来关闭 ExecutorService。shutdown() 方法在终止前允许执行以前提交的任务，而 shutdownNow() 方法阻止等待任务启动并试图停止当前正在执行的任务。在终止时，执行程序没有任务在执行，也没有任务在等待执行，并且无法提交新任务。应该关闭未使用的 ExecutorService 以允许回收其资源。<br>　　通过创建并返回一个可用于取消执行和/或等待完成的 Future，方法 submit 扩展了基本方法 Executor.execute(java.lang.Runnable)。方法 invokeAny 和 invokeAll 是批量执行的最常用形式，它们执行任务 collection，然后等待至少一个，或全部任务完成（可使用 ExecutorCompletionService 类来编写这些方法的自定义变体）。</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>　　类提供了用于此包中所提供的执行程序服务的工厂方法。</p>
<h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><h2 id="ThreadPoolExecutor-参数"><a href="#ThreadPoolExecutor-参数" class="headerlink" title="ThreadPoolExecutor 参数"></a>ThreadPoolExecutor 参数</h2><p>Executors.ThreadPoolExecutor的参数不同实现不同的线程池<br>1）corePoolSize 核心线程池标准数量<br>2）maximumPoolSize 线程池最大尺寸<br>3）keepAliceTime 超过标准数量，空闲线程存活时间<br>4）TimeUnit 时间单位<br>5）BlockingQueue<runnable> 保存没有执行的线程<br>6）RejectedExecutionHandler 持有拒绝策略，非必填<br>7）ThreadFactory</runnable></p>
<h2 id="不同参数的不同线程池"><a href="#不同参数的不同线程池" class="headerlink" title="不同参数的不同线程池"></a>不同参数的不同线程池</h2><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>(n,n,0, SECONDS,LinkedBlockingQueue<runnable>)</runnable></p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>(1,1,0L,s,LinkedBlockingQueue<runnable>)</runnable></p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>(0,MAX,60,SECONDS,SychronousQueue)<br>SynchronousQueue 容量为零，60s后线程被销毁,容量可扩张</p>
<h3 id="newSingleThreadExecutor-1"><a href="#newSingleThreadExecutor-1" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    executorService.scheduleWithFixedDelay(</span><br><span class="line">            <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="number">2</span>,<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor的子类ScheduledThreadPoolExecutor实现</p>
<p>##　ExecutorServeice<br>submit();提交Callable 返回Future<br>execute();提交Runnbale 不返回</p>
<h1 id="线程池的扩展"><a href="#线程池的扩展" class="headerlink" title="线程池的扩展"></a>线程池的扩展</h1><h2 id="增强接口"><a href="#增强接口" class="headerlink" title="增强接口"></a>增强接口</h2><ul>
<li>beforeExecute()</li>
<li>afterExecute()</li>
<li>terminated()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService service = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"ready "</span> + ((MyTask) r).name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyTask(String.valueOf(i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##　拒绝策略<br>缓冲队列不可能无限大，防止任务十分繁重导致的内存溢出和其他错误。<br>RejectedExecutionHandler接口持有拒绝策略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的实现类主要有以下几种</p>
<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p>直接拒绝任务，拒绝任务时会抛出RejectedExecutorException</p>
<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>丢弃任务，什么都不做</p>
<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>调用线程池的线程完成任务，不再使用线程池中的线程。直接调用请求Runnable的run()方法。</p>
<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p> 重线程池队列中选取最老的线程丢弃</p>
<h2 id="自定义线程工厂"><a href="#自定义线程工厂" class="headerlink" title="自定义线程工厂"></a>自定义线程工厂</h2><p>ThreadFactory接口。构建新的线程。实现者同时也初始化优先级，线程名称，守护状态等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ThreadPoolExecutor-1"><a href="#ThreadPoolExecutor-1" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><h2 id="ctl属性"><a href="#ctl属性" class="headerlink" title="ctl属性"></a>ctl属性</h2><p>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));<br>后28为表示线程数量前四位表示线程装填,最高的三位表示不同的状态：</p>
<ul>
<li>111 RUNNING 正在运行</li>
<li>000 SHUTDOWN 不再接收任务，队列中任务继续处理</li>
<li>001 STOP 不接受新的任务忙不处理队列中的任务，中断正在处理的任务</li>
<li>010 TIDYING 整理 所有线程终结，workerCount设置为0， terminated()方法运行的过渡状态</li>
<li>011 TERMINATED terminated()方法运行完毕<br>剩下的29位表示有效线程的数量</li>
</ul>
<h2 id="execut"><a href="#execut" class="headerlink" title="execut()"></a>execut()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">/* 如果正在运行的线程小于corePoolSize 。尝试创建新的线程执行当前任务。 调用addWroker方法时，</span></span><br><span class="line"><span class="comment">     会利用原子操作检查运行状态和有效线程数量 ，以防止之不应该添加线程时发生失败警告*/</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 没有使用锁进行同步，加入工作线程和加入队列函数必须进行再次检查。*/</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//双重检查，如果线程池关闭，则移除加入的任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;<span class="comment">//加入队列失败则开启新的线程，不受核心线程数限制，而是最大线程数限制</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Fork-Join-线程池"><a href="#Fork-Join-线程池" class="headerlink" title="Fork/Join 线程池"></a>Fork/Join 线程池</h1><p>将大任务分成小任务，最终将结果整理,分治思想。等待子任务完成。每个子任务不一定需要创建新的线程，而是利用线程中的线程。<br>fork 拆分任务。join等待任务完成。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>从性能角度看，Fork/Join适合处理子任务比较复杂的情况。否则的话开辟线程的时间开销会比大于分治节省的时间，得不偿失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= <span class="number">10000</span>)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i= start;i&lt;=end;i++) sum += i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            CountTask left = <span class="keyword">new</span> CountTask(start,mid);</span><br><span class="line">            CountTask right = <span class="keyword">new</span> CountTask(mid+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//执行子任务</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="comment">//等待子任务完成</span></span><br><span class="line">            sum = (<span class="keyword">int</span>)left.join() +  (<span class="keyword">int</span>)right.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, n);</span><br><span class="line">    Future result = forkJoinPool.submit(task);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">    Long mid = System.currentTimeMillis();</span><br><span class="line">    System.out.println(mid - start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,sum = <span class="number">0</span>; i &lt;= n; i++) sum += i;</span><br><span class="line">    System.out.println(System.currentTimeMillis() - mid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h2><h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><h3 id="ctl属性-1"><a href="#ctl属性-1" class="headerlink" title="ctl属性"></a>ctl属性</h3><p>　　使用一个long型整数保存五个变量，AC（16位保存活跃线程数减去并行度）、TC（16位保存总共的线程数减去并行度）、ST（1位保存线程池是否终结）、EC（15位保存栈顶端ForkJoinTask的eventCount）、ID（15位记录栈顶端ForkJoinTask的poolIndex属性）<br>　　使用一个long型整数表示5个变量并不会节省很多空间，而且大大降低了代码的可读性。仍然这么用的目的是同时保持五个变量的线程安全和并发性能。通过与无锁操作配合提升性能。</p>
<h3 id="scan"><a href="#scan" class="headerlink" title="scan()"></a>scan()</h3><h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker()"></a>runWorker()</h3><h3 id="帮助策略"><a href="#帮助策略" class="headerlink" title="帮助策略"></a>帮助策略</h3><p>自己从top取 别人从Base取 减少冲突。均匀分配任务。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>RecursiveAction 无返回值<br>RecursiveTask    有返回值</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SynchronousQueue源码解析]]></title>
      <url>http://baobing.github.io/2016/08/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/SynchronousQueue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h1><p>　　SychronousQueue类的大部分代码都交给Transfer内部类的两个子类ThransferQueue和ThransferStack完成。我只写关于ThransferStack的代码。<br>　　<a id="more"></a></p>
<p>这两个子类使用非阻塞无锁操作实现，理解起来有些困难。无锁是提高性能的重要手段，与此同时它让代码变得复杂。接下来要自己动手写无锁操作，增加对无锁操作的理解</p>
<blockquote>
<p><a href="http://www.tuicool.com/articles/aYrEZf" target="_blank" rel="noopener">http://www.tuicool.com/articles/aYrEZf</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。队列的头 是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），SynchronousQueue 作为一个空 collection。此队列不允许 null元素。</p>
<p>　　同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p>
<p>　　对于正在等待的生产者和使用者线程而言，此类支持可选的公平排序策略。默认情况下不保证这种排序。但是，使用公平设置为 true 所构造的队列可保证线程以 FIFO 的顺序进行访问。</p>
<h2 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h2><p> public E take() throws InterruptedException {</p>
<pre><code>    E e = transferer.transfer(null, false, 0);

    if (e != null)

        return e;

    Thread.interrupted();

    throw new InterruptedException();

}
</code></pre><h2 id="TransferStack类"><a href="#TransferStack类" class="headerlink" title="TransferStack类"></a>TransferStack类</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final int REQUEST    = 0; //代表未完成的消费者</span><br><span class="line"></span><br><span class="line">static final int DATA       = 1;     //代表未完成的生产者</span><br><span class="line"></span><br><span class="line">static final int FULFILLING = 2; //已经完成状态</span><br><span class="line"></span><br><span class="line">volatile SNode head;               //栈的顶端</span><br></pre></td></tr></table></figure>
<h3 id="transfer操作"><a href="#transfer操作" class="headerlink" title="transfer操作"></a>transfer操作</h3><p>图片是粗略的过程，很多东西无法表示，还是看源码。无锁操作还是要看好几遍才能领会作者的意图，加油吧少年！！</p>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 放置或者获取一个节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点e为null，代表这是一个消费者，否则它是一个生产者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        SNode h = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同为消费者或者生产者</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait 不允许等待</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())<span class="comment">//栈顶节点请求已取消</span></span><br><span class="line"></span><br><span class="line">                    casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//允许等待，尝试将e设置为栈顶，失败就继续循环尝试。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果栈顶元素正在处理，说明栈顶元素找到自己匹配对象（看不懂跳过）</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//返回s的匹配元素</span></span><br><span class="line"></span><br><span class="line">                SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//m == s 说明被取消，等待时间截止未出现匹配元素</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line"></span><br><span class="line">                    clean(s);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//新的节点覆盖s节点，移除s</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line"></span><br><span class="line">                    casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//返回生产者的item</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//颜色不同且栈顶元素未被处理</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//栈顶元素被取消，移除栈顶元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line"></span><br><span class="line">                casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将s放入栈顶，并且设置为正在处理</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line"></span><br><span class="line">    ﻿    ﻿    ﻿    ﻿    ﻿<span class="comment">//栈中元素有可能时间到达，所以要循环遍历</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line"></span><br><span class="line">                    SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line"></span><br><span class="line">                        casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line"></span><br><span class="line">                        s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line"></span><br><span class="line">                        casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line"></span><br><span class="line">                        s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//栈顶元素正在处理，帮助栈顶处理</span></span><br><span class="line"></span><br><span class="line">            SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line"></span><br><span class="line">                casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                SNode mn = m.next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line"></span><br><span class="line">                    casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line"></span><br><span class="line">                    h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="awaitFulfill操作"><a href="#awaitFulfill操作" class="headerlink" title="awaitFulfill操作"></a>awaitFulfill操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算等待终结时间，naoTime()函数更加精确</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">            Thread w = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line"></span><br><span class="line">                         (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (w.isInterrupted()) <span class="comment">//线程中断，取消s节点</span></span><br><span class="line"></span><br><span class="line">                    s.tryCancel();</span><br><span class="line"></span><br><span class="line">                SNode m = s.match;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m != <span class="keyword">null</span>) <span class="comment">//匹配成功返回</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> m;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed) &#123;</span><br><span class="line"></span><br><span class="line">                    nanos = deadline - System.nanoTime();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123; <span class="comment">//截止时间到达，取消当前线程的SNode</span></span><br><span class="line"></span><br><span class="line">                        s.tryCancel();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//线程挂起</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">﻿                    spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">                    s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!timed) <span class="comment">//无限期等待</span></span><br><span class="line"></span><br><span class="line">                    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line"></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PriorityBlockingQueue源码解析]]></title>
      <url>http://baobing.github.io/2016/08/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/PriorityBlockingQueue/</url>
      <content type="html"><![CDATA[<pre><code>优先阻塞队列，一定会涉及优先队列的实现,而且是平衡优先队列。一起看看Doug Lea大师是怎么做的。
</code></pre><a id="more"></a>
<h1 id="PriorityBlockingQueue和"><a href="#PriorityBlockingQueue和" class="headerlink" title="PriorityBlockingQueue和"></a>PriorityBlockingQueue和</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　一个无界阻塞队列，它使用与类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致 OutOfMemoryError）。此类不允许使用 null 元素。依赖自然顺序的优先级队列也不允许插入不可比较的对象（这样做会导致抛出 ClassCastException）。</p>
<p>　　此类及其迭代器可以实现 Collection 和 Iterator 接口的所有可选 方法。iterator() 方法中提供的迭代器并不 保证以特定的顺序遍历 PriorityBlockingQueue 的元素。如果需要有序地进行遍历，则应考虑使用 Arrays.sort(pq.toArray())。此外，可以使用方法 drainTo 按优先级顺序移除 全部或部分元素，并将它们放在另一个 collection 中。</p>
<p>　　在此类上进行的操作不保证具有同等优先级的元素的顺序。如果需要实施某一排序，那么可以定义自定义类或者比较器，比较器可使用修改键断开主优先级值之间的联系。例如，以下是应用先进先出 (first-in-first-out) 规则断开可比较元素之间联系的一个类。要使用该类，则需要插入一个新的FIFOEntry(anEntry) 来替换普通的条目对象。</p>
<p>##属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//优先队列用平衡二叉堆表示：queue[n] queue[2*n+1]和queue[2*(n+1)]。最小堆。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先队列元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有public方法的锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配自旋锁通过CAS获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//兼容以前的版本，序列化和反序列化使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br></pre></td></tr></table></figure>
<h2 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        offer(e); <span class="comment">// never need to block</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n, cap;</span><br><span class="line"></span><br><span class="line">        Object[] array;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优先队列数组装满需要扩容，扩容可能失败，需要循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line"></span><br><span class="line">            tryGrow(array, cap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//将元素插入优先队列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">                siftUpComparable(n, e, array);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line"></span><br><span class="line">            size = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            notEmpty.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//优先队列扩容。考虑到有可能扩容过程中有消费线程获取元素，可以在不扩容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//的前提下继续使用队列。增加吞吐量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//我猜是为了消费者线程可以继续消费，增加并发量</span></span><br><span class="line"></span><br><span class="line">        lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line"></span><br><span class="line">        Object[] newArray = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取到偏向锁标志位的才能扩容，使用CAS操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">            UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line"></span><br><span class="line">                                     <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">//oldCap容量小于64扩展一倍加二，其他情况扩展一半</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line"></span><br><span class="line">                                       (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line"></span><br><span class="line">                                       (oldCap &gt;&gt; <span class="number">1</span>));<span class="comment">//边界检查还是很重要的防止内存泄漏</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line"></span><br><span class="line">                    newCap = MAX_ARRAY_SIZE;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line"></span><br><span class="line">                    newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                allocationSpinLock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//其他线程还是有机会提前扩容新的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line"></span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        lock.lock(); <span class="comment">//数组copy</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line"></span><br><span class="line">            queue = newArray;</span><br><span class="line"></span><br><span class="line">            System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优先队列（最小堆）平衡插入。k代表数组中元素个数。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//插入过程，将元素放在平衡堆的最后一个位置，父节点大于当前节点</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//交换位置，递归重复这个过程。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//父节点下标</span></span><br><span class="line"></span><br><span class="line">            Object e = array[parent];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>) <span class="comment">//大于父节点循环终止</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            array[k] = e;</span><br><span class="line"></span><br><span class="line">            k = parent;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        array[k] = key;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="take-操作"><a href="#take-操作" class="headerlink" title="take 操作"></a>take 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    E result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">            notEmpty.await();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//持有锁才可以访问，堆中第一个元素为最小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        Object[] array = queue;</span><br><span class="line"></span><br><span class="line">        E result = (E) array[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        E x = (E) array[n];</span><br><span class="line"></span><br><span class="line">        array[n] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line"></span><br><span class="line">        size = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆的头元素被去掉，头元素作为Z，选取头元素较小的子节点占据头结点位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将头元素较小子节点作为Z重复这个过程，直到Z小于队列最后一个元素key，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者Z没有子节点。将key放置到Z的位置。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line"></span><br><span class="line">            Object c = array[child];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp;  <span class="comment">//左子节点大于右子节点</span></span><br><span class="line"></span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                c = array[child = right]; <span class="comment">//c等于两个子节点中的较小值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)<span class="comment">//如果key小于c停止循环</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            array[k] = c;</span><br><span class="line"></span><br><span class="line">            k = child;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        array[k] = key;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>　　一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。队列的头 是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），SynchronousQueue 作为一个空 collection。此队列不允许 null元素。</p>
<p>　　同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p>
<p>　　对于正在等待的生产者和使用者线程而言，此类支持可选的公平排序策略。默认情况下不保证这种排序。但是，使用公平设置为 true 所构造的队列可保证线程以 FIFO 的顺序进行访问。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ArrayBlockingQueue和LinkedBlockingQueue]]></title>
      <url>http://baobing.github.io/2016/08/03/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ArrayBlockingQueue%E5%92%8CLinkedBlockingQueue/</url>
      <content type="html"><![CDATA[<p>两点疑问没有解决：</p>
<p>1、为什么ArrayBlockingQueue不使用takeLock、putLock的双锁机制？使用这种锁分离的策略明显效率更高。</p>
<p>2、为什么判断是否存在剩余空间，使用while 而不是if？难道作者怕出现意外，但是什么时候会出现意外呢？<br><a id="more"></a></p>
<h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p>　　一个数组组成的有界阻塞队列，保持队列基本特性先进先出。<br>　　此类对等待的生产者线程和使用者线程进行排序的公平策略选项提供支持。默认情况下，不保证是这种排序策略。通过将fairness设置为true构造的队列允许按照FIFO顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。公平性的保证是通过ReentrantLock的公平锁实现。阻塞超时通过Condition的awaitNanos实现。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//保存队列的数组，循环使用数组。泛型是不能使用数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> takeIndex;<span class="comment">//下一次移除元素所在下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> putIndex; <span class="comment">//下一次添加元素所在下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;      <span class="comment">//队列中元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock; <span class="comment">//重入锁保证线程安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Condition的await相当于Object提供的wait</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//signals相当于notify方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty; <span class="comment">//获取元素线程使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull; <span class="comment">//放置元素线程使用</span></span><br></pre></td></tr></table></figure>
<h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        checkNotNull(e); <span class="comment">//不能放入null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; </span><br><span class="line"></span><br><span class="line">        lock.lockInterruptibly(); <span class="comment">//中断异常交给调用者处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整个数组被填满，线程阻塞。为什么用while而不用if语句？</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//难道是为了方式被唤醒时队列再次被填满。但是当前线程占用锁，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不可能有其他线程调用put方法并且成功添加元素。</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//想想肯定有不使用lock的方法添加元素成功。</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//如果真有这样的方法它一定不是线程安全的。往下看吧- -!</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line"></span><br><span class="line">                notFull.await();</span><br><span class="line"></span><br><span class="line">            enqueue(e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素到指定位置，放置下标前移，发出非空信号量 。持有锁才能调用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">        items[putIndex] = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++putIndex == items.length)<span class="comment">//循环使用数组</span></span><br><span class="line"></span><br><span class="line">            putIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        notEmpty.signal();<span class="comment">//发出非空信号</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//队列为空等待</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                notEmpty.await();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"></span><br><span class="line">        E x = (E) items[takeIndex]; <span class="comment">//Object转泛型</span></span><br><span class="line"></span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)<span class="comment">//循环数组</span></span><br><span class="line"></span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line"></span><br><span class="line">        notFull.signal();<span class="comment">//发出非空通知</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="drainTo操作"><a href="#drainTo操作" class="headerlink" title="drainTo操作"></a>drainTo操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       checkNotNull(c);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"></span><br><span class="line">       lock.lock();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> n = Math.min(maxElements, count);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> take = takeIndex;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">//有add存在不能保证n的正确性</span></span><br><span class="line"></span><br><span class="line">                   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"></span><br><span class="line">                   E x = (E) items[take];</span><br><span class="line"></span><br><span class="line">                   c.add(x);</span><br><span class="line"></span><br><span class="line">                   items[take] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (++take == items.length)<span class="comment">//循环添加</span></span><br><span class="line"></span><br><span class="line">                       take = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                   i++;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Restore invariants even if c.add() threw</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   count -= i;</span><br><span class="line"></span><br><span class="line">                   takeIndex = take;<span class="comment">//下一次获取元素的位置</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                           itrs.queueIsEmpty();</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; take)</span><br><span class="line"></span><br><span class="line">                           itrs.takeIndexWrapped();</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); i--)</span><br><span class="line"></span><br><span class="line">                       notFull.signal();<span class="comment">//取走多个元素可以发出多个未满信号</span></span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">           lock.unlock();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>　　一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO（先进先出）排序元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。链表动态分配空间可以处理更多的节点，但是动态分配空间会两份一些时间。<br>　　可选的容量范围构造方法参数作为防止队列过度扩展的一种方法。如果未指定容量，则它等于 Integer.MAX_VALUE。除非插入节点会使队列超出容量，否则每次插入后会动态地创建链接节点。<br>与ArrayBlockingQueue的不同点1）一个使用数组，固定大小，一个使用链表,非固定大小，最大是int最大值2）LinkedBlockingQueue使用锁分离策略，正类包含takeLock和putLock两把锁，提高了并发效率。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final int capacity;//记录队列容量</span><br><span class="line"></span><br><span class="line">//使用原子整数记录当前队列中元素的个数</span><br><span class="line"></span><br><span class="line">private final AtomicInteger count = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">transient Node&lt;E&gt; head;//头部元素</span><br><span class="line"></span><br><span class="line">private transient Node&lt;E&gt; last;//尾部元素</span><br><span class="line"></span><br><span class="line">//获取头部元素锁和</span><br><span class="line"></span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">  //插入尾部元素锁</span><br><span class="line"></span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public LinkedBlockingQueue(int capacity) &#123;</span><br><span class="line"></span><br><span class="line">    if (capacity &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    this.capacity = capacity;</span><br><span class="line"></span><br><span class="line">    last = head = new Node&lt;E&gt;(null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看出初始化的时候LBQ含有一个Node节点,头指针和尾指针都指向它，count=0。也就是说LBQ一直包含一个多余的Node节点。</p>
<h2 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">       if (e == null) throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">       int c = -1;</span><br><span class="line"></span><br><span class="line">       Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">       final ReentrantLock putLock = this.putLock;</span><br><span class="line"></span><br><span class="line">      //putLock锁住以后队列中元素个数只会减小不会增大</span><br><span class="line"></span><br><span class="line">       final AtomicInteger count = this.count;</span><br><span class="line"></span><br><span class="line">       putLock.lockInterruptibly();//锁住put锁</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line"></span><br><span class="line">           while (count.get() == capacity) &#123;</span><br><span class="line"></span><br><span class="line">               notFull.await();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           enqueue(node);</span><br><span class="line"></span><br><span class="line">       //原子操作保证take与put不会导致线程安全问题</span><br><span class="line"></span><br><span class="line">           c = count.getAndIncrement();</span><br><span class="line"></span><br><span class="line">           if (c + 1 &lt; capacity)</span><br><span class="line"></span><br><span class="line">               notFull.signal();</span><br><span class="line"></span><br><span class="line">       &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">           putLock.unlock();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (c == 0)</span><br><span class="line"></span><br><span class="line">           signalNotEmpty();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   private void enqueue(Node&lt;E&gt; node) &#123;</span><br><span class="line"></span><br><span class="line">       last = last.next = node;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>需要公平机制来避免消费者、生产者饥饿，这时使用ABQ再好不过了。</p>
</li>
<li><p>如果队列的大小是有界的话，首选还是ABQ，ABQ的性能更好，不需要申请空间。否则还是LBQ吧！LBQ可以接受突入起来的大量生产者。</p>
</li>
<li>阻塞队列的效率某些场景的效率会低于非阻塞，下一次再写关于非阻塞队列CourrentLinkedQueue</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BlockingQueue接口]]></title>
      <url>http://baobing.github.io/2016/08/03/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/BlockingQueue%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>　　支持两个附加操作的 Queue，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。<br>　　<a id="more"></a><br>　　BlockingQueue 不接受 null 元素。试图 add、put 或 offer 一个 null 元素时，某些实现会抛出 NullPointerException。null 被用作指示 poll 操作失败的警戒值。<br>　　BlockingQueue 可以是限定容量的。它在任意给定时间都可以有一个 remainingCapacity，超出此容量，便无法无阻塞地 put 附加元素。没有任何内部容量约束的 BlockingQueue 总是报告 Integer.MAX_VALUE 的剩余容量。<br>　　BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。<br>　　BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和 removeAll）没有 必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，addAll(c) 有可能失败（抛出一个异常）。<br>　　BlockingQueue 实质上不 支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的 end-of-stream 或 poison 对象，并根据使用者获取这些对象的时间来对它们进行解释。</p>
<p>队列为空或者队列没有空间时的处理：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:right">返回特殊值</th>
<th style="text-align:right">阻塞</th>
<th style="text-align:right">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:right">offer(e)</td>
<td style="text-align:right">put(e)</td>
<td style="text-align:right">offer(e,time,unit)</td>
</tr>
<tr>
<td>删除</td>
<td style="text-align:center">remove()</td>
<td style="text-align:right">poll()</td>
<td style="text-align:right">take()</td>
<td style="text-align:right">poll(time,unit)</td>
</tr>
<tr>
<td>查看</td>
<td style="text-align:center">element()</td>
<td style="text-align:right">peek()</td>
<td style="text-align:right">不可用</td>
<td style="text-align:right">不可用</td>
</tr>
</tbody>
</table>
<h2 id="源码加注解"><a href="#源码加注解" class="headerlink" title="源码加注解"></a>源码加注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 如果当前没有可用的     空间，则抛出 IllegalStateException。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 当使用有容量限制的队列时，通常首选 offer。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 如果当前没有可用的空间，则返回 false。当使用有容量限制的队列时，此方法通</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 将指定元素插入此队列中，将等待可用的空间（如果有必要）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 将指定元素插入此队列中，在到达指定的等待时间前等待可用的空间（如果有必要）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 附加元素数量；如果没有内部限制，则返回 Integer.MAX_VALUE。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 从此队列中移除指定元素的单个实例（如果存在）。更确切地讲，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 如果此队列包含一个或多个满足 o.equals(e) 的元素 e，则移除</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 该元素。如果此队列包含指定元素（或者此队列由于调用而发生</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 更改），则返回 true。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 如果此队列包含指定元素，则返回 true。更确切地讲，当且仅当此</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 队列至少包含一个满足 o.equals(e) 的元素 e时，返回 true。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 此操作可能比反复轮询此队列更有效。在试图向 collection c 中添加元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 没有成功时，可能导致在抛出相关异常时，元素会同时在两个 collection</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 中出现，或者在其中一个 collection 中出现，也可能在两个 collection </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 中都不出现。如果试图将一个队列放入自身队列中，则会导致</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * IllegalArgumentException 异常。此外，如果正在进行此操作时修改</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 指定的 collection，则此操作行为是不确定的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * collection 中。与上个函数相同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="/2016/08/03/ArrayBlockingQueue和LinkedBlockingQueue/">BlockingQueue实现类1:ArrayBlockingQueue和LinkedBlockingQueue</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM3-无锁]]></title>
      <url>http://baobing.github.io/2016/07/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM3-%E6%97%A0%E9%94%81/</url>
      <content type="html"><![CDATA[<h1 id="CAS-compare-and-swap"><a href="#CAS-compare-and-swap" class="headerlink" title="CAS compare and swap"></a>CAS compare and swap</h1><p>线程切换线程8w个时钟周期。对于竞争不激烈的情况，使用循环使用CAS开销更小。<br>无锁操作在并发比较少的情况下效率高，但不要迷恋无锁。<br>CAS是CPU指令级别的原子操作，一条指令完成比较赋值过程，不用担心并发问题。<br><a id="more"></a></p>
<h1 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h1><p>AtomicInteger 部分源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line"><span class="comment">//只有bootstrap加载器加载的类才能获取Unsafe的实例，其他类只能用反射获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">//valueOffset 代表需要更新的字段在对象中的偏移量，类似于c中的指针，获取需要更新字段的内存地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Unsafe 部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//valueOffset 代表需要更新的字段在对象中的偏移量，类似于c中的指针，获取需要更新字段的内存地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1,<span class="keyword">long</span> valueOffset, expect, update)</span></span>;</span><br><span class="line"><span class="comment">//不断zi'x</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h1><p>　　可以修饰任意类型的变量，是的变量操作变为院子操作<br>AtomicReference<string> stringAtomicReference = new AtomicReference&lt;&gt;();</string></p>
<h1 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h1><p>　　与AtomicReference功能相似，不同点是AtomicStampedReference可以解决过程相关的情景。过程敏感的情景试用。<br>　　假设一个活动只能给每个用户充值一次10元钱，用户可以消费。假设用户A充值以后立马消费10元，AtomicReference还会认为只消费了一次。<br>　　<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference&lt;Integer&gt; money = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> stamp = money.getStamp();</span><br><span class="line">money.compareAndSet(<span class="number">0</span>,<span class="number">10</span>,stamp,stamp+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>AtomicStampedReference部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;</span><br><span class="line">    pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference, V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span> expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h1><p>原子操作的整数数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicIntegerArray array = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//下标为2的位置加一</span></span><br><span class="line">array.getAndIncrement(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[].class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shift;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">    <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">    shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">    <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(array, checkedByteOffset(i), delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h1><p>AtomicIntegerFieldUpdater辅助一个类，用类似静态方法的方式，实现变量的原子操作。优点在于不必改变变量的类型，即可享受原子变量的好处。如果是已有代码修改，将会大大减少代码的修改量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">"score"</span>);</span><br><span class="line">Candidate candidate = <span class="keyword">new</span> Candidate();</span><br><span class="line">scoreUpdater.incrementAndGet(candidate);</span><br></pre></td></tr></table></figure>
<p>AtomicIntegerFieldUpdater部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicLongFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       String fieldName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (AtomicLong.VM_SUPPORTS_LONG_CAS)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CASUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LockedUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LockFreeVector"><a href="#LockFreeVector" class="headerlink" title="LockFreeVector"></a>LockFreeVector</h2><p>无锁数组，amino框架提供</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一桶的大小为8 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> First_BUCKET_SIZE = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//采用二维数组做扩展，每个一维数组的大小都不同 sizeOf(buke[i+1]) = sizeOf( buket[i]) *2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt; buckets;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDescriptor</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> E odlV; </span><br><span class="line">   <span class="keyword">public</span> E newV;</span><br><span class="line">   <span class="keyword">public</span> AtomicReferenceArray&lt;E&gt; addr; <span class="comment">//操作地址</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> addr_ind;<span class="comment">//地址的index</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WriteDesciptor</span><span class="params">(AtomicReferenceArray&lt;E&gt; addr,<span class="keyword">int</span> addr_ind, E oldV,E newV)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.addr = addr;</span><br><span class="line">   <span class="keyword">this</span>.addr_ind =addr_ind;</span><br><span class="line">      <span class="keyword">this</span>.oldV = oldV;</span><br><span class="line">      <span class="keyword">this</span>.newV = newV;</span><br><span class="line">   &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span></span>&#123;</span><br><span class="line">addr.compareAndSet()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">Desciptor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM2-Java内存模型和三个概念]]></title>
      <url>http://baobing.github.io/2016/07/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM2-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>GYM是葛一鸣老师的简写。GYM系列文章都是观看葛老师课程的个人笔记。<br><a id="more"></a></p>
<blockquote>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
<h1 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h1><h2 id="高速缓存带来的不一致问题"><a href="#高速缓存带来的不一致问题" class="headerlink" title="高速缓存带来的不一致问题"></a>高速缓存带来的不一致问题</h2><p>　　计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
</blockquote>
<p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure></p>
<p>　　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>　　在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通常来说有以下2种解决方法：<br>1）通过在总线加LOCK#锁的方式<br>2）通过缓存一致性协议</p>
<p>　　因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。</p>
<p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。所以就出现了缓存一致性协议。最出名的就是Intel<strong><em> 的MESI协议</em></strong>，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h1 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>一个很经典的例子就是银行账户转账问题：<br>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。假设从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。所以这两个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//线程1执行的代码</span><br><span class="line">int i = 0;</span><br><span class="line">i = 10;</span><br><span class="line"> </span><br><span class="line">//线程2执行的代码</span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure></p>
<p>　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。<br>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.<br>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h4><p>有序性：即程序执行的顺序按照代码的先后顺序执行。<br>举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;             </span><br><span class="line">boolean flag = false;</span><br><span class="line">i = 1;                //语句1 </span><br><span class="line">flag = true;          //语句2</span><br></pre></td></tr></table></figure></p>
<p>　　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。<br>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。<br>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;    //语句1</span><br><span class="line">int r = 2;    //语句2</span><br><span class="line">a = a + 3;    //语句3</span><br><span class="line">r = a*a;     //语句4</span><br></pre></td></tr></table></figure></p>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3<br>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。<br>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p>
<p>　　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。<br>　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>　　下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。<br>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。<br>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。<br>举个简单的例子：<br>　　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。<br>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h2 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h2><p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。<br>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 10;         //语句1</span><br><span class="line">y = x;         //语句2</span><br><span class="line">x++;           //语句3</span><br><span class="line">x = x + 1;     //语句4</span><br></pre></td></tr></table></figure></p>
<p>　　其实只有语句1是原子性操作，其他三个语句都不是原子性操作。<br>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。<br>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。<br>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。<br>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h2 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h2><p>对于可见性，Java提供了volatile关键字来保证可见性。<br>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br><strong><em>happens-before原则（先行发生原则）</em></strong><br>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>这8条原则摘自《深入理解Java虚拟机》。<br>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。<br>下面我们来解释一下前4条规则：<br>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。<br>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。<br>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。<br>　　第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h1 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h1><h2 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。<br>先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//线程1</span><br><span class="line">boolean stop = false;</span><br><span class="line">while(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//线程2</span><br><span class="line">stop = true;</span><br></pre></td></tr></table></figure>
<p>　<br>　<br>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。<br>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。<br>　　但是用volatile修饰之后就变得不一样了：<br>第一：使用volatile关键字会强制将修改的值立即写入主存；<br>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。<br>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。<br>那么线程1读取到的就是最新的正确的值。</p>
<h2 id="volatile保证原子性吗？"><a href="#volatile保证原子性吗？" class="headerlink" title="volatile保证原子性吗？"></a>volatile保证原子性吗？</h2><p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。<br>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：<br>　　假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。<br>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。那么两个线程分别进行了一次自增操作后，inc只增加了1。<br>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。<br>把上面的代码改成以下任何一种都可以达到效果：<br>采用synchronized：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public synchronized void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="volatile能保证有序性吗？"><a href="#volatile能保证有序性吗？" class="headerlink" title="volatile能保证有序性吗？"></a>volatile能保证有序性吗？</h2><p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。<br>volatile关键字禁止指令重排序有两层意思：<br>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br>可能上面说的比较绕，举个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"> </span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;         //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure></p>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。<br>那么我们回到前面举的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。<br>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h2 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h2><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>2）它会强制将对缓存的修改操作立即写入主存；<br>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。<br>内存屏障可以被分为以下几种类型<br>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p>
<p>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。<br>为了实现上一章中讨论的JSR-133的规定，Java编译器会这样使用内存屏障。</p>
<p>内存屏障示意表</p>
<p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障。<br>x.finalField = v; StoreStore; sharedRef = x;</p>
<h1 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h1><p>　　通常来说，使用volatile必须具备以下2个条件：<br>1）对变量的写操作不依赖于当前值<br>2）该变量没有包含在具有其他变量的不变式中<br>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<h2 id="状态标记量"><a href="#状态标记量" class="headerlink" title="状态标记量"></a>状态标记量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean flag = false;</span><br><span class="line"> </span><br><span class="line">while(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void setFlag() &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean inited = false;</span><br><span class="line">//线程1:</span><br><span class="line">context = loadContext(); </span><br><span class="line">inited = true;           </span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<h2 id="double-check"><a href="#double-check" class="headerlink" title="double check"></a>double check</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line"> </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance==null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance==null)</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>29</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM1-并发基础和Thread类详解]]></title>
      <url>http://baobing.github.io/2016/07/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM1-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%92%8CThread%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>GYM是葛一鸣老师的简写。GYM系列文章都是观看葛老师课程的个人笔记。<br><a id="more"></a></p>
<h1 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h1><p>1.发挥多处理器的强大能力<br>2.代码责任单一，方便调试<br>3.异步事件的简化处理,防止客户端阻塞<br>4.响应更灵敏的用户界面</p>
<h1 id="多线程危害"><a href="#多线程危害" class="headerlink" title="多线程危害"></a>多线程危害</h1><p>1.线程安全性可能是非常复杂的，线程执行顺序是不可预测的，竞争条件，脏读。<br>2.活跃性问题：某件正确的事情最终会发生，死锁。<br>3.性能问题：context Switch 切换、影响性能。</p>
<h1 id="java线程状态"><a href="#java线程状态" class="headerlink" title="java线程状态"></a>java线程状态</h1><p>1.New：状态 已经分配内存，无cpu时间<br>2.Runable： 资源已经全部分配，可能在已经分配cpu时间<br>3.blocked：进入临界区，被挂起<br>4.waiting：等他其他线程唤醒，或者定时唤醒<br>5.terminated：终止状态<br>x\</p>
<h1 id="java线程的操作"><a href="#java线程的操作" class="headerlink" title="java线程的操作"></a>java线程的操作</h1><ul>
<li>Thread的start()在新的线程中调用run()方法，单纯吊用run()方法不会开启一个新的线程。</li>
<li>两种方法新建：<br>（1）传递一个实现Runable的类；<br>（2）重载Thread的run()方法；</li>
<li>每个线程都拥有自己的名字；<h1 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h1></li>
<li>thread.stop() 不建议使用，过于暴力，直接终止，可能导致数据的不一致，。</li>
<li>thread.interruput() 中断线程，只是给相应的线程打招呼，并不会真的终端线程</li>
<li>thread.isInterruput() 判断线程是否被中断，采取相应的措施</li>
<li>thread.sleep() InterruptedException<br>在sleep过程中其他线程发送中断请求 ，可以在catch中做出中断处理。<br>中断异常的时候清空中断标志位，catch中需要重新设置中断标志，while中使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static class InterruptedThread implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(&quot;i am breaking&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;i want to sleep&quot;);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(&quot;someone interrupt me&quot;);</span><br><span class="line">            //恢复中断标志位</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">    Thread thread = new Thread(new InterruptedThread(), &quot;t1&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(7000);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>输出结果：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i want to sleep</span><br><span class="line">i want to sleep</span><br><span class="line">someone interrupt me</span><br><span class="line">i am breaking</span><br></pre></td></tr></table></figure></p>
<h1 id="六、线程挂起和继续执行"><a href="#六、线程挂起和继续执行" class="headerlink" title="六、线程挂起和继续执行"></a>六、线程挂起和继续执行</h1><p>不建议使用，resume()发生在suspend之前时，线程无法释放锁处于runnable转台</p>
<ul>
<li>tread.suspend() 占用锁不释放</li>
<li>thread.resume()  重启线程</li>
</ul>
<h1 id="七、等待和谦让（debugger、测试可能使用）"><a href="#七、等待和谦让（debugger、测试可能使用）" class="headerlink" title="七、等待和谦让（debugger、测试可能使用）"></a>七、等待和谦让（debugger、测试可能使用）</h1><ul>
<li>thread.yield() 释放当前线程的cpu时间，但是还是继续竞争，</li>
<li>thread.join()等待线程结束<br>调用线程等待join函数的所属线程结束<h2 id="join实现代码"><a href="#join实现代码" class="headerlink" title="join实现代码"></a>join实现代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        long base = System.currentTimeMillis();</span><br><span class="line">        long now = 0;</span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (millis == 0) &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                wait(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                long delay = millis - now;</span><br><span class="line">                if (delay &lt;= 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>在后台默默完成一些系统性的服务，如GC、JIT理解为守护线程<br>setDeamon();在start之前设置<br>如果没有业务线程守护线程也会死掉。</p>
<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p>setPriority(Thread.MAX_PRORITY)<br>高优先级程序不一定就能一直抢占cpu时间，只是几率高一些</p>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><ul>
<li>synchronized<br>（1）指定加锁对象<br>（2）修饰实例方法：相当于当前对象加锁<br>（3）直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁</li>
<li>object.wait()、object.notify()、notifyAll()<pre><code>没有获得监视器之前不能使用wait(),会释放当前线程的监视器，通知其他线程执行；
notify之后不会立即启动wait方法，拿到锁之后可以继续执行wait之后的事情。唤醒所有等待监视器的线程中的其中一个线程。notifyAll唤醒所有的线程，去争用监视器。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    public static Boolean flag = true;</span><br><span class="line"></span><br><span class="line">    public static class Task implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            //必须获取监视器才能用wait 会排数InterruptedException</span><br><span class="line">                synchronized (flag) &#123;</span><br><span class="line">                    System.out.println(&quot;im ready to wait&quot;);</span><br><span class="line">                    flag.wait();</span><br><span class="line">                    System.out.println(&quot;someone notify me&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new Thread(new Task()).start();</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        synchronized (flag) &#123;</span><br><span class="line">            TestWaitNotify.flag.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">输出结果  </span><br><span class="line">/**</span><br><span class="line">  *im ready to wait</span><br><span class="line">  *someone notify me</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>﻿</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组中只出现一次的数字]]></title>
      <url>http://baobing.github.io/2016/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个整型数组里除了两个数字之外，其他的数字都出现两次。请写程序找出这两个只出现一次的数字。要求时间复杂度为O(n),空间复杂度为O（1）。<br>{2，4，3，6，3，2，5，5} 结果为4，6。<br><a id="more"></a></p>
<h1 id="异或运算的特性"><a href="#异或运算的特性" class="headerlink" title="异或运算的特性"></a>异或运算的特性</h1><ol>
<li>交换律 a^b = b^a</li>
<li>结合律 a^b^c = a^(b^c)</li>
<li>a^a = 0</li>
<li>0^a = a</li>
<li>a^b^a = a^a^b = b</li>
<li>如果a^b = 1 != 0，则a与b的二进制形式的个位是不相同的</li>
</ol>
<h1 id="结题思路"><a href="#结题思路" class="headerlink" title="结题思路"></a>结题思路</h1><h2 id="只有一个数字只出现一次"><a href="#只有一个数字只出现一次" class="headerlink" title="只有一个数字只出现一次"></a>只有一个数字只出现一次</h2><p>题目如果改为只有一个出现一次的数字。<br>根据特性5，我们只需要把所有的数字一起异或就会得到这个只出现一次的数字N.<br>N = 0^A[0]^A[1]^A[2]….</p>
<h2 id="两个数字只出现一次"><a href="#两个数字只出现一次" class="headerlink" title="两个数字只出现一次"></a>两个数字只出现一次</h2><p>1) x = n^m = 0^A[0]^A[1]^A[2]….<br>根据特性6我们知道如果n,m不相等.他们异或的结果的二进制形式的每一位都代表n，m二进制对应位不相同。例如两个二进制数字a,b异或：10011^11011 = 1000 , 二进制结果中只有第四位数字等于1，则a，b的第四位不同。<br>2）挑选所有元素异或结果x的其中一个为1的位置不变，其他位置变为0，得到y.假设x的二进制形式为10110，y=10000.<br>3）每个元素与y进行与运算，结果为等于y的是一组，结果不为y的是一组。n和m一定不在同一组。<br>4）问题转化为只有一个数字只出现一次</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestXor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getArrXorResult</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">            result ^= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getXOne</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (l = <span class="number">0</span>; x &gt;&gt; <span class="number">1</span> != <span class="number">0</span>; l++) &#123;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//分别装载两个分组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr0 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span> x = getArrXorResult(arr, <span class="number">0</span>, arr.length);</span><br><span class="line">        <span class="comment">//获取异或结果二进制结果是1的最大的那个</span></span><br><span class="line">        <span class="keyword">int</span> y = getXOne(x);</span><br><span class="line">        <span class="keyword">int</span> index0 = <span class="number">0</span>, index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[i] &amp; y) == y) &#123;</span><br><span class="line">                arr0[index0++] = arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr1[index1++] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = getArrXorResult(arr0, <span class="number">0</span>, index0);</span><br><span class="line">        <span class="keyword">int</span> m = getArrXorResult(arr1, <span class="number">0</span>, index1);</span><br><span class="line">        System.out.println(<span class="string">"n="</span> + n + <span class="string">" m="</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组排成最小的数]]></title>
      <url>http://baobing.github.io/2016/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>　　输入一个正整数数组，每个元素都不相等，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如数组{3，32，321},则打印出这3个数字能排成的最小数字321323.（《剑指Offer》P177）<br><a id="more"></a><br>　　贪心算法的题目，找到解决办法不能，难得是给出正确性证明。书中给出了证明，前半段讲的很好，不过后半段不是很满意。
　　</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>1）将数组中所有数字转化为字符串，组成新的数组Str<br>2）对所有字符串排序。 return Str[i]+Str[j]&lt;Str[j]+Str[i]</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStringComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (o1.toString() + o2.toString()).compareTo(o2.toString() + o1.toString());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">32</span>, <span class="number">321</span>&#125;;</span><br><span class="line">     List&lt;Integer&gt; list = Arrays.asList(arr);</span><br><span class="line">     Collections.sort(list, <span class="keyword">new</span> MinStringComparator());</span><br><span class="line">     StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">100</span>);</span><br><span class="line">     <span class="keyword">for</span> (Integer e : list) &#123;</span><br><span class="line">         stringBuilder.append(e);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>
<h1 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h1><h2 id="排序关系有效性证明"><a href="#排序关系有效性证明" class="headerlink" title="排序关系有效性证明"></a>排序关系有效性证明</h2><p>一个有效的比较规则一定满足自反性、对称性和传递性。<br>1）自反性：显然有 aa = aa,所以a等于a。<br>2）传递性：如果a小于b，则ab<ba。所以ba>ab,因此b大于a。<br>3）传递性：假设a小于b，ab&lt;ba. b小于c，bc&lt;cb<br>a的十进制为m位，b的十进制为n位，c的十进制为k位</ba。所以ba></p>
<img src="/2016/07/28/数据结构与算法/数组排成最小的数/transitivity.png" title="传递性证明过程">
<p>因此 a小于b，b小于c，a必定小于c</p>
<h2 id="最终证明"><a href="#最终证明" class="headerlink" title="最终证明"></a>最终证明</h2><p>排序关系证明是很重要的前提。正面证明很困难，使用反证法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设存在一个序列A小于序列B。</span><br><span class="line">1）假设B[i] = A[j],我们可以一直向前或者向后移动B[i]直到B[i]到达位置j。B序列中的每一个元素都按照这种方法移动即可得到A序列。</span><br><span class="line">2）现在我没减缓这个移动过程，每次只移动一个特定的元素B[i]一步直到B[i]到达位置j，而且一次只移动一步。可就是说经过一次移动序列B(0)：B[0]...B[i-1]B[i]...变为B(1):[0]...B[i]B[i-1]...。 B(l)代表序列B经历过l次移动。</span><br><span class="line">3)因为B[i-1]B[i]&lt;B[i]B[i-1]（这一点需要排序关系证明的支持才能成立），所以B[0]...B[i-1]B[i]...&lt;[0]...B[i]B[i-1]...</span><br><span class="line">4）因为B[i]B[i+1]&lt;B[i+1]B[i]（这一点需要排序关系证明的支持才能成立），所以B[0]...B[i-1]B[i]...&lt;[0]...B[i]B[i-1]...</span><br><span class="line">5)因为B(0)&lt;B(1)&lt;B(2)&lt;...&lt;B(x)=A(0)，所以B&lt;A</span><br><span class="line">这与题设不相符，所以假设不成立。也就是说A是最小的序列</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap源码解析]]></title>
      <url>http://baobing.github.io/2016/07/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>　　 JDK1.8中，ConcurrentHashMap的源码竟然有6300行,作者是大名鼎鼎Doug Lea（感谢开源让我离大神可以这么近，不过代码风格明显没打算交给他人维护）。本文只讲述扩容相关的内容和get操作的并发安全实现，其他操作就放弃了。文章参考一下别人的文章，主要是以下两篇文章：<br>　　 <a id="more"></a></p>
<blockquote>
<p><a href="http://blog.csdn.net/u010887744/article/details/51002358" target="_blank" rel="noopener">http://blog.csdn.net/u010887744/article/details/51002358</a><br><a href="http://www.cnblogs.com/huaizuo/p/5413069.html" target="_blank" rel="noopener">http://www.cnblogs.com/huaizuo/p/5413069.html</a><br>　　友情提示：看ConcurrentHashMap源码还是需要一些Java并发编程的了解，比如内存可见性、原子性、顺序性、无锁。另一点就是先阅读HashMap的源码。</p>
<h1 id="JDK8-HashMap数据结构"><a href="#JDK8-HashMap数据结构" class="headerlink" title="JDK8 HashMap数据结构"></a>JDK8 HashMap数据结构</h1></blockquote>
<p><center></center></p>
<p><center>图1</center><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V val;</span><br><span class="line">        volatile Node&lt;K,V&gt; next;</span><br><span class="line">       //省略省略</span><br><span class="line">&#125;</span><br><span class="line"> transient volatile Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></p>
<p>　　HashMap底层由数组、链表和红黑树三者组成。我们从图1和源码大改也可以推断出来。首先是HashMap使用Node组成的数组table装载所有的键值对，再者HashMap发生Hash值碰撞使用链表将它们连起来，最后是某个链表长度大于指定值链表转化为红黑树。   </p>
<h1 id="重要的常量"><a href="#重要的常量" class="headerlink" title="重要的常量"></a>重要的常量</h1><h2 id="基本常量"><a href="#基本常量" class="headerlink" title="基本常量"></a>基本常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"> //扩容时使用，其他时候为null</span><br><span class="line"> private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"> //基础计数器，主要用于无争用，同时也作为table数组初始化的回退记录</span><br><span class="line"> private transient volatile long baseCount;</span><br><span class="line"></span><br><span class="line"> //table数组初始化和扩容的控制标志。为负数时，table数组正在扩容或初始化，</span><br><span class="line"> //-1代表初始化，其他负数表示 -（1+参数扩容的线程数量）。当table为null时，</span><br><span class="line"> //sizeCtl持有扩容的阈值，0为默认值。</span><br><span class="line"> private transient volatile int sizeCtl;</span><br><span class="line"></span><br><span class="line">//table扩容时 每个线程最少需要处理的元素数量。看不懂就跳过去，下同</span><br><span class="line"> private static final int MIN_TRANSFER_STRIDE = 16;</span><br><span class="line"></span><br><span class="line"> //当table扩容时，transferIndex持有下一个线程或者下次循环可以处理的数组界限</span><br><span class="line"> private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line"> //table数组的默认长度</span><br><span class="line"> private static final int DEFAULT_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line"> //table数组的负载因子. 小数形式不经常使用，它更常见的表示形式是 n - (n &gt;&gt;&gt; 2)</span><br><span class="line"> private static final float LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>
<h2 id="Unsafe相关常量"><a href="#Unsafe相关常量" class="headerlink" title="Unsafe相关常量"></a>Unsafe相关常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe U;</span><br><span class="line">    private static final long SIZECTL; //sizeCtl的偏移量</span><br><span class="line">    private static final long TRANSFERINDEX; //transferIndex的偏移量</span><br><span class="line">    private static final long BASECOUNT;   //</span><br><span class="line">    private static final long CELLSBUSY;</span><br><span class="line">    private static final long CELLVALUE;</span><br><span class="line">    //数组中第一个元素在数组中的位置</span><br><span class="line">    private static final long ABASE;</span><br><span class="line">     //Node数组元素大小scale的二进制去除前导零后的位数</span><br><span class="line">    private static final int ASHIFT;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">    ﻿    ﻿  //获取sizeCtl的偏移量</span><br><span class="line">            SIZECTL = U.objectFieldOffset(k.getDeclaredField(&quot;sizeCtl&quot;)); </span><br><span class="line">    ﻿    ﻿  //省略代码，和上面一样获取各个变量的偏移量</span><br><span class="line">             ...</span><br><span class="line">            Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">            //Arrays和Java别的对象一样，都有一个对象头，它是存储在实际的数据前面的。</span><br><span class="line">            //这个头的长度可以通过unsafe.arrayBaseOffset(T[].class) 方法来获取到，</span><br><span class="line">    ﻿    ﻿    ﻿ //这里T是数组元素的类型</span><br><span class="line">            ABASE = U.arrayBaseOffset(ak); </span><br><span class="line">            int scale = U.arrayIndexScale(ak); //获取数组元素的大小</span><br><span class="line">            if ((scale &amp; (scale - 1)) != 0) //元素大小必须是2的倍数，不知道为什么</span><br><span class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h1><h2 id="无锁方法"><a href="#无锁方法" class="headerlink" title="无锁方法"></a>无锁方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    //内存中直接获取tab数组张第i个元素，保证内存可见性</span><br><span class="line">      static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line">   //为tab数组的第i个元素复制，使用CAS，保证操作的原子性</span><br><span class="line"></span><br><span class="line">    static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line">   static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">/**设置obj对象中offset偏移地址对应的object型field的值为指定值。这是一个有序或者</span><br><span class="line"> 有延迟的putObjectVolatile方法，并且不保证值的改变被其他线程立</span><br><span class="line"> 即看到。只有在field被&lt;code&gt;volatile&lt;/code&gt;修饰并且期望被意外修改的时候</span><br><span class="line">  使用才有用。*/</span><br><span class="line">        U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容方法transfer"><a href="#扩容方法transfer" class="headerlink" title="扩容方法transfer"></a>扩容方法transfer</h2><h3 id="扩容过程解析"><a href="#扩容过程解析" class="headerlink" title="扩容过程解析"></a>扩容过程解析</h3><p>　　ConcurrentHashMap无锁多线程扩容，减少扩容时的时间消耗。单线程构建两倍容量的nextTable；允许多线程复制原table元素到nextTable。为每个内核均分任务，并保证其不小于16（常量MIN_TRANSFER_STRIDE）。<br>1）若nextTab为null，则初始化其为原table的2倍；<br>2）死循环遍历，直到finishing。</p>
<ul>
<li>节点为空，则插入ForwardingNode；</li>
<li>链表节点（fh&gt;=0），分别插入nextTable的i和i+n的位置；</li>
<li>TreeBin节点（fh&lt;0），判断是否需要untreefi，分别插入nextTable的i和i+n的位置；</li>
<li>finishing时，nextTab赋给table，更新sizeCtl为新容量的0.75倍 ，完成扩容。<br>以上说的都是单线程，多线程又是如何实现的呢？<pre><code>遍历到ForwardingNode节点((fh = f.hash) == MOVED)，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心 。由于给节点上了锁，只允许当前线程完成此节点的操作，处理完毕后，将对应值设为ForwardingNode（fwd），其他线程看到forward，直接向后遍历。如此便完成了多线程的复制工作，也解决了线程安全问题。
</code></pre></li>
</ul>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Moves and/or copies the nodes in each bin to new table. See</span><br><span class="line"> * above for explanation.</span><br><span class="line"> */</span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    //n表示原数组的大小 ,stride表示每个线程或者单次循环负责节点的个数 </span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    if (nextTab == null) &#123;            // 为nextTable申请空间</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    //构建一个连节点的指针，用于标识位</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    //循环的关键变量，判断是否已经扩容完成</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    //i--操作保证了倒序遍历数组，bound表示新的线程或者单次循环的下边界</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">      </span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing) //循环没有到达下边界可以继续for循环</span><br><span class="line">                advance = false;</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123; //整个for循环过程结束</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">    ﻿    ﻿   //只有通过CAS成功更新ransferIndex才能获取到扩容的资格</span><br><span class="line">            else if (U.compareAndSwapInt  </span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //i&lt;0说明已经遍历完旧的数组tab；i&gt;=n什么时候有可能呢？</span><br><span class="line">    ﻿   //在下面看到i=n,所以目前i最大应该是n吧,导致的原因可能是多线程</span><br><span class="line">        //i+n&gt;=nextn,nextn=nextTab.length，所以如果满足i+n&gt;=nextn说明已经扩容完成</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; </span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;//a</span><br><span class="line">                nextTable = null;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，</span><br><span class="line">    ﻿    ﻿   //说明新加入一个线程参与到扩容操作,参考sizeCtl的注释</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                //如果有多个线程进行扩容，那么这个值在第二个线程以后就不会相等，</span><br><span class="line">    ﻿    ﻿      ﻿//因为sizeCtl已经被减1了，所以后面的线程就只能直接返回,</span><br><span class="line">    ﻿    ﻿    ﻿  //始终保证只有一个线程执行了 a(上面注释a)</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">    ﻿    ﻿    ﻿//finishing和advance保证线程已经扩容完成了可以退出循环</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ﻿   //如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">    ﻿    //那么如果f.hash=-1的话说明该节点为ForwardingNode，说明该节点已经处理过了</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        else &#123;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        //把链表分表拆分为，hash&amp;n等于0和不等于0的，</span><br><span class="line">    ﻿    ﻿    ﻿    ﻿    //然后分别放在新表的i和i+n位置。n一定是2的幂，这个很重要</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        //把已经替换的节点的旧tab的i的位置用fwd替换，fwd包含nextTab</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;//下面红黑树基本和链表差不多</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //判断扩容后是否还需要红黑树结构</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h1><p>get操作没有使用锁，怎么保证并发安全的？<br>线程安全基本概念可以参考这篇笔记：<a href="/2016/07/29/并发编程/GYM2-Java内存模型和三个概念/">GYM2-Java内存模型和三个概念</a>。<br>线程安全：</p>
<ul>
<li>内存可见性</li>
<li>操作原子性</li>
<li>线程内代码执行顺序性</li>
</ul>
<p>分析get在其他操作发生的线程安全保障：</p>
<ul>
<li>table数组使用volatile修饰，保证table数组的内存可见性。</li>
<li>线程内代码执行顺序性保证，能力有限不知道怎么分析。</li>
<li>put操作将Node节点放入table[i]时（table[i]==null、table[i]是一个链表或者是一个红黑树）：查找放置位置是不改变table数组，找到安放位置，使用CAS更新tab[i]保证操作原子性，没有</li>
<li>remove操作与put操作类似，remove操作过程不改变table[i]，改变table[i]使用CAS保证原子性。</li>
<li>put操作结束时链表转换为红黑树：转化过程不会直接改变链表，而是用链表中的Node节点生成新的TreeBin节点。最后，将红黑树的根节点更新table[i],当然更新操作使用CAS以保证原子性。</li>
<li>扩容操作中table[i]移到nextTable时，这个过程使用CAS操作，get操作会在nextTable中查找。没有移到到nextTable时，不会修改table[i],不存在线程安全问题。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[红黑树和HashMap中实现]]></title>
      <url>http://baobing.github.io/2016/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%A5%E5%8F%8AHashMap/</url>
      <content type="html"><![CDATA[<p>　　本人最近在看JDK的HashMap源码，在JDK1.8中引入红黑树。引入红黑树的原因是加快hash碰撞较多情景下的查找速度。网上找到下面这篇文章感觉写的非常好，思路清晰。我会在原文章基础上做一点批注，方便日后阅读。<br>　　<a id="more"></a></p>
<blockquote>
<p><a href="http://blog.csdn.net/eric491179912/article/details/6179908" target="_blank" rel="noopener">http://blog.csdn.net/eric491179912/article/details/6179908</a></p>
</blockquote>
<h1 id="红黑树的基本特性"><a href="#红黑树的基本特性" class="headerlink" title="红黑树的基本特性"></a>红黑树的基本特性</h1><p>　　一定要牢记这五条特性，推导全靠这几条原则。 </p>
<ol>
<li><p>节点是红色或黑色。</p>
</li>
<li><p>根节点是黑色。</p>
</li>
<li><p>每个叶节点（NIL节点，空节点）是黑色的。<strong><em>这个限制根本没有用啊，亲 - -！</em></strong></p>
</li>
<li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
</li>
<li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
</li>
</ol>
<h1 id="红黑树上结点的插入"><a href="#红黑树上结点的插入" class="headerlink" title="红黑树上结点的插入"></a>红黑树上结点的插入</h1><p>　　<strong><em>任何一个即将插入的新结点的初始颜色都为红色。</em></strong>这一点很容易理解，因为插入黑点会增加某条路径上黑结点的数目，从而导致整棵树黑高度的不平衡。但如果新结点父结点为红色时（如图1所示），将会违返红黑树性质：一条路径上不能出现相邻的两个红色结点。这时就需要通过一系列操作来使红黑树保持平衡。</p>
<img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert1.jpg" title="图1">
<p>　　为了清楚地表示插入操作以下在结点中使用“新”字表示一个新插入的结点；使用“父”字表示新插入点的父结点；使用“叔”字表示“父”结点的兄弟结点；使用“祖”字表示“父”结点的父结点。插入操作分为以下几种情况：</p>
<h2 id="该树为空树。"><a href="#该树为空树。" class="headerlink" title="该树为空树。"></a>该树为空树。</h2><p>直接插入根结点的位置，违反性质2，把节点颜色有红改为黑即可。</p>
<h2 id="黑父"><a href="#黑父" class="headerlink" title="黑父"></a>黑父</h2><p>　　如图2所示，如果新点的父结点为黑色结点，那么插入一个红点将不会影响红黑树的平衡，此时插入操作完成。红黑树比AVL树优秀的地方之一在于黑父的情况比较常见，从而使红黑树需要旋转的几率相对AVL树来说会少一些。</p>
<center><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert2.jpg" title="图2"></center>


<h2 id="红父"><a href="#红父" class="headerlink" title="红父"></a>红父</h2><p>　　如图3所示，由于父结点为红色，此时可以判定，祖父结点必定为黑色。这时需要根据叔父结点的颜色来决定做什么样的操作。青色结点表示颜色未知。由于有可能需要根结点到新点的路径上进行多次旋转操作，而每次进行不平衡判断的起始点（<strong><em>我们可将其视为新点</em></strong>）都不一样。所以我们在此使用一个蓝色箭头指向这个起始点，并称之为判定点。<br>　　注：把一个树看成一个新的节点，继续进行旋转。这点很重要。</p>
<center><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert3.jpg"></center>


<h3 id="红叔"><a href="#红叔" class="headerlink" title="红叔"></a>红叔</h3><p>　　当叔父结点为红色时，如图4所示，无需进行旋转操作，只要将父和叔结点变为黑色，将祖父结点变为红色即可。但由于祖父结点的父结点有可能为红色，从而违反红黑树性质。此时必须将祖父结点作为新的判定点继续向上进行平衡操作。需要注意，无论“父”在“叔”的左边还是右边，无论“新”是“父”的左孩子还是右孩子，它们的操作都完全一样。</p>
<p><center><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert4.jpg"></center><br>　　注：如果祖父节点是根节点怎么办？答案是进行情景一的操作，把祖父节点变为黑色。</p>
<h3 id="黑叔"><a href="#黑叔" class="headerlink" title="黑叔"></a>黑叔</h3><p>情形1：<br><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert5.jpg"></p>
<p>情形2：<br><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert6.jpg"></p>
<p>情形3：</p>
<img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert7.jpg">
<p>情形4：</p>
<img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert8.jpg">
<p>　　可以观察到，当旋转完成后，新的旋转根全部为黑色，此时不需要再向上回溯进行平衡操作，插入操作完成。需要注意，上面四张图的“叔”、“1”、“2”、“3”结点有可能为黑哨兵结点。<br>　　其实红黑树的插入操作不是很难，甚至比AVL树的插入操作还更简单些。但删除操作就远远比AVL树复杂得多，下面就介绍红黑树的删除操作。
　　</p>
<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><p>主要讲解红黑树的平衡插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap.Entry&lt;K,V&gt;继承自HashMap.Node&lt;K,V&gt; </span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     TreeNode&lt;K,V&gt; parent;<span class="comment">//parent阴阳记录父亲节点</span></span><br><span class="line"></span><br><span class="line">     TreeNode&lt;K,V&gt; left;<span class="comment">//left、right其中一个记录叔叔节点</span></span><br><span class="line"></span><br><span class="line">     TreeNode&lt;K,V&gt; right;</span><br><span class="line"></span><br><span class="line">     TreeNode&lt;K,V&gt; prev;  <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> red; <span class="comment">//记录节点的颜色</span></span><br><span class="line"></span><br><span class="line">     TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      * 将链表转化为红黑树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//遍历链表,x代表需要插入的节点</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line"></span><br><span class="line">             next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line"></span><br><span class="line">             x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="comment">//树为空直接插入节点，并且节点颜色变为黑色</span></span><br><span class="line"></span><br><span class="line">                 x.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                 x.red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                 root = x;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                 K k = x.key;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">int</span> h = x.hash;</span><br><span class="line"></span><br><span class="line">                 Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">//查找新节点在红黑树上的位置</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">//dir记录向左走还是向右走 ph 记录当前节点的hash值</span></span><br><span class="line"></span><br><span class="line">                     <span class="keyword">int</span> dir, ph;</span><br><span class="line"></span><br><span class="line">                     K pk = p.key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line"></span><br><span class="line">                         dir = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line"></span><br><span class="line">                         dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">                               (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line"></span><br><span class="line">                              (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                         <span class="comment">//哈希值相等时比较Key的大小</span></span><br><span class="line"></span><br><span class="line">                         dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                     TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">//如果下一步需要到达的位置是null，就可以安放新节点</span></span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                         x.parent = xp;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                             xp.left = x;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                             xp.right = x;</span><br><span class="line"></span><br><span class="line">                         <span class="comment">//插入红黑树，并且保证红黑树的特性不被破坏</span></span><br><span class="line"></span><br><span class="line">                         root = balanceInsertion(root, x);</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         moveRootToFront(tab, root);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                                                 TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         x.red = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//xp表示x的父节点 xpp表示x的祖父节点 xppl、xppr表示x叔叔节点</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//根节点直接变为黑色</span></span><br><span class="line">             <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 x.red = <span class="keyword">false</span>;</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> x;</span><br><span class="line">                 </span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//父亲为红色或者父节点为根节点 直接插入红色新节点</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//父亲节点是左节点</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//父亲节点和叔叔节点是红色，则叔叔和父亲变为黑色，祖父变为红色</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line"></span><br><span class="line">                     xppr.red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                     xp.red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                     xpp.red = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                     x = xpp; <span class="comment">//祖父节点作为新节点，继续平衡之路</span></span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line"></span><br><span class="line">                         root = rotateLeft(root, x = xp);</span><br><span class="line"></span><br><span class="line">                         xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                         xp.red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                             xpp.red = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                             root = rotateRight(root, xpp);</span><br><span class="line"></span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">else</span> &#123; <span class="comment">//父亲节点是右节点</span></span><br><span class="line">             <span class="comment">//父亲节点和叔叔节点是红色，则叔叔和父亲变为黑色，祖父变为红色</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line"></span><br><span class="line">                     xppl.red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                     xp.red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                     xpp.red = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                     x = xpp;<span class="comment">//祖父节点作为新节点，继续平衡之路</span></span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">else</span> &#123; <span class="comment">//父亲节点和叔叔节点是红色</span></span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line"></span><br><span class="line">                         root = rotateRight(root, x = xp);</span><br><span class="line"></span><br><span class="line">                         xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                         xp.red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                             xpp.red = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                             root = rotateLeft(root, xpp);</span><br><span class="line"></span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashMap源码解读]]></title>
      <url>http://baobing.github.io/2016/07/25/Java%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="关于HashMap的疑问"><a href="#关于HashMap的疑问" class="headerlink" title="关于HashMap的疑问"></a>关于HashMap的疑问</h1><ul>
<li><p>HashMap底层的数据结构，怎样解决hash碰撞。</p>
</li>
<li><p>HashMap何时扩容，扩容的过程是怎样的              </p>
</li>
<li><p>红黑树是一种怎样的数据结构</p>
<a id="more"></a>
</li>
</ul>
<h1 id="JDK8-HashMap数据结构"><a href="#JDK8-HashMap数据结构" class="headerlink" title="JDK8 HashMap数据结构"></a>JDK8 HashMap数据结构</h1><center><img src="/2016/07/25/Java基础/HashMap源码解读/HashMap.png" title="图1"></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V val;</span><br><span class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">      <span class="comment">//省略省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>　　不难发现HashMap底层由数组、链表和红黑树三者组成。</p>
<h2 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h2><p>　　包含一个执行自身类型的引用next，显然Node类是组成链表的节点，next引用负责链接各个节点。</p>
<h2 id="table数组"><a href="#table数组" class="headerlink" title="table数组"></a>table数组</h2><p>　　Node类组成的数组，装载所有的键值对。table有以下几个特点:</p>
<ul>
<li>长度N一定为2的幂。即使指定初始长度，N一定是大于等于初始长度的2的幂（可以参考tableSizeFor函数）</li>
<li>table[i]包含的是hash&amp;(N-1)的Node节点。由于N为2的幂，hash&amp;(N-1)等价于hash%N。与运算的速度大大高于取余，这就是作者的高明之处。</li>
<li>延迟初始化，只用第一次在Map中放入元素时，才会调用这个分配空间。</li>
</ul>
<h2 id="链表和红黑树"><a href="#链表和红黑树" class="headerlink" title="链表和红黑树"></a>链表和红黑树</h2><p>　　多个元素hash&amp;(n-1)的值相同的情况称为hash碰撞。链表和红黑树这两种数据结构都是在发生hash碰撞时产生的结果。如果链表的长度大于8且table长度大于64，链表被转化为红黑树。如果红黑树的节点数量小于6，则转化为链表。 </p>
<h1 id="HashMap重要字段"><a href="#HashMap重要字段" class="headerlink" title="HashMap重要字段"></a>HashMap重要字段</h1><ul>
<li><p>Node<k,v>[] table，文章已经提到不再赘述</k,v></p>
</li>
<li><p>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4。HashMap默认初始大小为16</p>
</li>
<li><p>DEFAULT_LOAD_FACTOR = 0.75f。默认负载因子是0.75，也就是说table数组有75%非空时进行扩容。</p>
</li>
<li><p>size：记录Map中键值对个数。</p>
</li>
<li><p>threshold：记录下一次扩容的阈值。threshold = loadFactor * table.length.</p>
</li>
</ul>
<h1 id="重要的函数"><a href="#重要的函数" class="headerlink" title="重要的函数"></a>重要的函数</h1><h2 id="get操作实现函数getNode"><a href="#get操作实现函数getNode" class="headerlink" title="get操作实现函数getNode"></a>get操作实现函数getNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延迟初始化导致table可能为空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//hash对应table数组位置的头元素key等于查找key，直接返回头节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line"></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)   <span class="comment">//头元素是一棵红黑树</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; <span class="comment">//遍历链表直到找到hash相等 key相等的元素</span></span><br><span class="line"></span><br><span class="line">                         ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="put操作实现函数putVal"><a href="#put操作实现函数putVal" class="headerlink" title="put操作实现函数putVal"></a>put操作实现函数putVal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//第一次执行put操作时初始化table</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//节点填充的位置为null，直接放入新的Node节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;  <span class="comment">//key已经在Map中出现，直接覆盖原数字</span></span><br><span class="line"></span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"></span><br><span class="line">                e = p;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//p是一棵红黑树</span></span><br><span class="line"></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;               <span class="comment">//p是一个链表，将元素放置到链表末尾</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 链表长度大于等于8，链表转化为红黑树</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;              </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;     <span class="comment">// 相同key在链表中存在，覆盖原来节点</span></span><br><span class="line"></span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    p = e;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//table数组有一个位置被占用，判断是否扩容</span></span><br><span class="line"></span><br><span class="line">        ++modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"></span><br><span class="line">            resize();</span><br><span class="line"></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容函数resize"><a href="#扩容函数resize" class="headerlink" title="扩容函数resize"></a>扩容函数resize</h2><p>1）获取新数组newTab的长度，为newTab申请空间。需要考虑容量最大边界，延迟初始化等问题。</p>
<p>2）将原数组oldTab中的节点，放入newTab中。链表和红黑树拆解问题。数组容量是2的幂，所以拆解过程很有技巧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;  <span class="comment">//原数组阈值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//分别记录新table容量 和 新的阈值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line"></span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line"></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// Map设置初始容量,threshold为table初始容量</span></span><br><span class="line"></span><br><span class="line">            newCap = oldThr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line"></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line"></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">//设置初始容量时，计算新的阈值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line"></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line"></span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threshold = newThr;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line"></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">        table = newTab;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;   <span class="comment">//遍历原始table</span></span><br><span class="line"></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)    <span class="comment">// 不存在hash碰撞，只有一个节点</span></span><br><span class="line"></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  <span class="comment">// 红黑树</span></span><br><span class="line"></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//将链表分为两个链表，分割依据看下面代码</span></span><br><span class="line"></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; </span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            </span><br><span class="line"></span><br><span class="line"><span class="comment">/* table的capcity一定是2的幂。e.hash &amp; oldCap 结果 r只可能等于0或者oldCap</span></span><br><span class="line"><span class="comment"> e.hash &amp; oldCap == 0 时，e.hash &amp; (oldCap-1) == e.hash &amp; (newCap-1)</span></span><br><span class="line"><span class="comment">e.hash &amp; oldCap == oldCap 时,e.hash &amp; (oldCap-1)+oldCap ==e.hash&amp;(newCap-1)*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; </span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">                                    loHead = e;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line"></span><br><span class="line">                                loTail = e;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">                                    hiHead = e;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line"></span><br><span class="line">                                hiTail = e;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组中第k大的数字]]></title>
      <url>http://baobing.github.io/2016/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>从给定长度的整数数组中，选取第K大的数字。要求时间复杂度为O(N).<br><a id="more"></a></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>1）需要查找的数组a，选取其中一个数字a<a href="start&lt;=i&lt;=end">i</a>作为Key<br>2) 小于Key的数字放在Key左侧<br>3）大于等于Key的数字放在Key右侧<br>4）如果Key的下标keyIndex等于K，返回Key；<br>5）如果keyIndex 小于K，end = keyIndex - 1，重复1）<br>6）如果keyIndex 大于K，start = keyIndex + 1，重复1）</p>
<p>　　这种求解方法是快速排序的思路演化而来。<br>　　个人想到的一个将元素依据大小放置在Key左右的方法。<br>　　使用两个辅助数组，一个保存大于Key的元素，一个保存小于Key的元素。将小于Key的元素放置在头部，将小于Key的元素放于尾部。将剩余的空间放置Key。<br>　　优点：可以得到于Key相同的所有元素，对于相同元素多的数组可以加快速度<br>　　缺点：耗时，需要辅助空间</p>
<h1 id="衍生问题"><a href="#衍生问题" class="headerlink" title="衍生问题"></a>衍生问题</h1><ul>
<li>给定整数数组中，求前K大的所有数字</li>
<li>给定整数数组中，某个的数字出现次数超过数组长度一半，找到这个数字。</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> acm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hubaobin on 16/7/24.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kth</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 结束的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = start;</span><br><span class="line">        <span class="keyword">int</span> last = end;</span><br><span class="line">        <span class="comment">//选取第一个数字作为key,建议还是随机选取避免选取数字过小或者过大</span></span><br><span class="line">        <span class="keyword">int</span> key = a[first];</span><br><span class="line">        <span class="comment">//将小于key的值放在key左侧,大于等于key的值放在右侧</span></span><br><span class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">            <span class="comment">//一定要先从后到前扫描</span></span><br><span class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; a[last] &gt;= key) last--;</span><br><span class="line">            a[first] = a[last];</span><br><span class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; a[first] &lt;= key) first++;</span><br><span class="line">            a[last] = a[first];</span><br><span class="line">        &#125;</span><br><span class="line">        a[first] = key;</span><br><span class="line">        <span class="keyword">if</span> (first == k) <span class="keyword">return</span> a[first];</span><br><span class="line">        <span class="keyword">if</span> (first &gt; k) <span class="keyword">return</span> getKth(a, k, start, first - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getKth(a, k, first + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">while</span> ((k = scanner.nextInt()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(getKth(a, k - <span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快速幂原理解析]]></title>
      <url>http://baobing.github.io/2016/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>求n的m次方，时间复杂度O(log(N)).不考虑大数情况。<br><a id="more"></a></p>
<h1 id="解决方法：快速幂"><a href="#解决方法：快速幂" class="headerlink" title="解决方法：快速幂"></a>解决方法：快速幂</h1><h2 id="求解方法和步骤"><a href="#求解方法和步骤" class="headerlink" title="求解方法和步骤"></a>求解方法和步骤</h2><p>1）假设n=3,m=10</p>
<p>2）将m转化为二进制为t=1010,数组形式为a={1,0,1,0}，a[i]表示m的第i位上的二进制数组。</p>
<p>3）f[i]表示m的前i个二进制数字的十进制形式。我们可以得到<strong><em> f[i+1] = (f[i]+a[i] )</em>2 *</strong> ，如：10 =((((1+0)<em>2+1)</em>2+0)<em>2+1)</em>2 。</p>
<p>4）2^3^4 = (2^3)^4 ，2^(1+2) = 2^2<em>2 ,由上面两条定理可以推得 g[i+1] = (g[i] </em>(n^a[i]))^2 。</p>
<p>其中g[i]表示 n^f[i]。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> acm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by hubaobin on 16/7/22.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickPower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPower</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不能同时为0"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((m &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                result *= n;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result *= result;</span><br><span class="line"></span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(getPower(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快排、递归、堆和基数四种排序方法]]></title>
      <url>http://baobing.github.io/2016/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9B%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>接下来文章将会讲述四种排序算法的实现和可行性证明。<strong><em>只有证明一个算法的正确性，才算理解一种算法。</em></strong><br><a id="more"></a></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1)从需要排序的数组选中一个作为Key，比Key小的放在右边，比Key大的放在左边。</p>
<p>2 )Key右侧的元素重复步骤1)</p>
<p>3)Key右侧的元素重复步骤1)</p>
<p>观察源码即可找到实现步骤一效果的方法。</p>
<h2 id="可行性证明"><a href="#可行性证明" class="headerlink" title="可行性证明"></a>可行性证明</h2><p>题设</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1)每次排序选中Key的左侧小于等于Key </span><br><span class="line"></span><br><span class="line">2)每次排序选中Key的右侧大于等于Key</span><br><span class="line"></span><br><span class="line">3)需要排序数组长度为2或3时，数据一定是升序</span><br></pre></td></tr></table></figure>
<p>假设数组为 a[] ，Key的下标为k，数组范围为0-n。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1)当 0&lt;=i&lt;k 时，a[i] &lt;=a[k] &amp;&amp; a[i]&lt;= a[i+1].</span><br><span class="line"></span><br><span class="line">2)当 k&lt;j&lt;=n 时，a[j] &gt;=a[k] &amp;&amp; a[j]&gt;= a[j-1].</span><br><span class="line"></span><br><span class="line">3)结合1)、2)可以推导出：当 0&lt;=l&lt;n , a[i]&lt;a[i+1]，即排序结果有序</span><br></pre></td></tr></table></figure>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><ul>
<li><p>优点:空间复杂度为 O(N) </p>
</li>
<li><p>缺点:时间复杂度O(Nlog(N))，但是不稳定。Key的选择很关键，选不好复杂度就会变为N的平方。</p>
</li>
<li><p>优化方法：选择数组头部中间尾部，三个元素中间值作为Key。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by baobing on 16/7/15.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sort(<span class="number">0</span>, list.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> key = list[low];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first = low;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> last = high;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一定要从后往前先</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; list[last] &gt;= key) &#123;</span><br><span class="line"></span><br><span class="line">                last--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list[first] = list[last];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; list[first] &lt;= key) &#123;</span><br><span class="line"></span><br><span class="line">                first++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list[last] = list[first];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list[first] = key;</span><br><span class="line"></span><br><span class="line">        sort(low, first - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        sort(first + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</span><br><span class="line"></span><br><span class="line">        QuickSort q = <span class="keyword">new</span> QuickSort(list);</span><br><span class="line"></span><br><span class="line">        q.sort();</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>1）将数组分为两个大小相同的数组（有可能大小相差1），继续分割数组，直到数组大小为1.</p>
<p>2）现在从同一个数组分割来的两个数组都为升序，将两个数组合并为一个升序的数组。</p>
<p>3）重复步骤 2）直到整个数组被合并</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>典型的分治算法。通过子序列的有序性，保证自身的有序性。</p>
<h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><ul>
<li><p>优点：时间复杂度为O(Nlog(N)) 并且极其稳定</p>
</li>
<li><p>缺点：空间复杂度为O(2N)),比较节省空间的场合不适用，尤其是比较大的数组</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by hubaobin on 16/7/16.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 合并两个有序的数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 第一个数组的起始下标为low 终止下标为mid</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 第二个数组的起始下标为mid+1 终止下标为high</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于保存两个数组合并结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个数组的始末下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first1 = low, end1 = mid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个数组的始末下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first2 = mid + <span class="number">1</span>, end2 = high;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录临时数组的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first1 &lt;= end1 &amp;&amp; first2 &lt;= end2) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (list[first1] &lt; list[first2]) &#123;</span><br><span class="line"></span><br><span class="line">                temp[k++] = list[first1++];</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                temp[k++] = list[first2++];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个数组的剩余元素放入临时数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first1 &lt;= end1) &#123;</span><br><span class="line"></span><br><span class="line">            temp[k++] = list[first1++];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个数组的剩余元素放入临时数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first2 &lt;= end2) &#123;</span><br><span class="line"></span><br><span class="line">            temp[k++] = list[first2++];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序好的临时数组覆盖原数组</span></span><br><span class="line"></span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, list, low, temp.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 排序数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low  起始下标</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high 末尾下标</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        sort(low, mid);</span><br><span class="line"></span><br><span class="line">        sort(mid + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        merge(low, mid, high);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sort(<span class="number">0</span>, list.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</span><br><span class="line"></span><br><span class="line">        MergeSort q = <span class="keyword">new</span> MergeSort(list);</span><br><span class="line"></span><br><span class="line">        q.sort();</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>最大堆：完全二叉树，所有根节点的子节点小于等于本身</li>
</ul>
<p>1）N个节点的树，构建为最大堆。</p>
<p>2）根节点与树最后一个叶子节点交换。</p>
<p>3）除去尾部的交换节点之后的树，构造为最大堆</p>
<p>4）重负步骤2）</p>
<h2 id="优点缺点-1"><a href="#优点缺点-1" class="headerlink" title="优点缺点"></a>优点缺点</h2><ul>
<li><p>优点 复杂度O(Nlog(N)) 空间复杂度为O(N)</p>
</li>
<li><p>缺点 构建最大堆浪费不少时间</p>
</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by hubaobin on 16/7/16.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        buildMaxHeapify();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//末尾与头交换，交换后调整最大堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">            swap(<span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">            maxHeapify(i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有子节点的才需要创建最大堆，从最后一个的父节点开始</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> startIndex = getParentIndex(list.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从尾端开始创建最大堆，每次都是正确的堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">            maxHeapify(list.length, i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 创建最大堆</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@paramheapSize</span>需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@paramindex</span>当前需要创建最大堆的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前点与左右子节点比较</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = getChildLeftIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> right = getChildRightIndex(index);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> largest = index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; list[index] &lt; list[left]) &#123;</span><br><span class="line"></span><br><span class="line">            largest = left;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; list[largest] &lt; list[right]) &#123;</span><br><span class="line"></span><br><span class="line">            largest = right;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != index) &#123;</span><br><span class="line"></span><br><span class="line">            swap(index, largest);</span><br><span class="line"></span><br><span class="line">            maxHeapify(heapSize, largest);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = list[a];</span><br><span class="line"></span><br><span class="line">        list[a] = list[b];</span><br><span class="line"></span><br><span class="line">        list[b] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 父节点位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 左子节点position注意括号，加法优先级更高</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildLeftIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 右子节点position</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildRightIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</span><br><span class="line"></span><br><span class="line">        HeapSort q = <span class="keyword">new</span> HeapSort(list);</span><br><span class="line"></span><br><span class="line">        q.sort();</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h2><p>1）将需要排序的数组list中的数字根据他们的个位数字i放到对应的数组bucket[i]的末尾。</p>
<p>2）从0-9依次将bucket中的数字放置到需要排序的数组list。</p>
<p>3）接下来是十位、百位，重复类似步骤1），指导数组list中的所有元素该位置都没有数字。</p>
<h2 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：</p>
<ul>
<li><p>时间复杂度低O(Mlog(N)).（N为排序数字个数M为最大位）对于N大M小的情况尤为突出。</p>
</li>
<li><p>可以实现相同大小的数字，依旧保持先后顺序</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>辅助空间需求要求比较大</p>
</li>
<li><p>M大N小时，性能下降</p>
</li>
<li><p>试用的排序类型比较少，整数最适合</p>
</li>
</ul>
<p>缺点</p>
<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by hubaobin on 16/7/17.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> list[];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> <span class="comment">//d表示最大的数有多少位</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bucket[i]用来装载需要排序的位等于i的数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][list.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//idxArr[i] 表示bucket[i]填充数据个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] idxArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) idxArr[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isContinue = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将数组放入bucket</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> divRes = list[i] / n;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (divRes &gt;= <span class="number">10</span>) isContinue = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> lsd = (divRes % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">                bucket[lsd][idxArr[lsd]++] = list[i];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//bucket中的数字放回原数组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; idxArr[i]; j++) &#123;</span><br><span class="line"></span><br><span class="line">                    list[k++] = bucket[i][j];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                idxArr[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isContinue) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            n *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</span><br><span class="line"></span><br><span class="line">        RadixSort q = <span class="keyword">new</span> RadixSort(list);</span><br><span class="line"></span><br><span class="line">        q.sort();</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
