<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ArrayBlockingQueue和LinkedBlockingQueue]]></title>
      <url>http://baobing.github.io/2016/08/03/ArrayBlockingQueue%E5%92%8CLinkedBlockingQueue/</url>
      <content type="html"><![CDATA[<p>两点疑问没有解决：</p>
<p>1、为什么ArrayBlockingQueue不使用takeLock、putLock的双锁机制？使用这种锁分离的策略明显效率更高。</p>
<p>2、为什么判断是否存在剩余空间，使用while 而不是if？难道作者怕出现意外，但是什么时候会出现意外呢？<br><a id="more"></a></p>
<h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p>　　一个数组组成的有界阻塞队列，保持队列基本特性先进先出。<br>　　此类对等待的生产者线程和使用者线程进行排序的公平策略选项提供支持。默认情况下，不保证是这种排序策略。通过将fairness设置为true构造的队列允许按照FIFO顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。公平性的保证是通过ReentrantLock的公平锁实现。阻塞超时通过Condition的awaitNanos实现。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//保存队列的数组，循环使用数组。泛型是不能使用数组</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> Object[] items; </div><div class="line"></div><div class="line">    <span class="keyword">int</span> takeIndex;<span class="comment">//下一次移除元素所在下标</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> putIndex; <span class="comment">//下一次添加元素所在下标</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> count;      <span class="comment">//队列中元素数量</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> ReentrantLock lock; <span class="comment">//重入锁保证线程安全</span></div><div class="line"></div><div class="line">    <span class="comment">//Condition的await相当于Object提供的wait</span></div><div class="line"></div><div class="line">    <span class="comment">//signals相当于notify方法</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty; <span class="comment">//获取元素线程使用</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull; <span class="comment">//放置元素线程使用</span></div></pre></td></tr></table></figure>
<h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        checkNotNull(e); <span class="comment">//不能放入null</span></div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; </div><div class="line"></div><div class="line">        lock.lockInterruptibly(); <span class="comment">//中断异常交给调用者处理</span></div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">//整个数组被填满，线程阻塞。为什么用while而不用if语句？</span></div><div class="line"></div><div class="line">        <span class="comment">//难道是为了方式被唤醒时队列再次被填满。但是当前线程占用锁，</span></div><div class="line"></div><div class="line">        <span class="comment">//不可能有其他线程调用put方法并且成功添加元素。</span></div><div class="line"></div><div class="line">         <span class="comment">//想想肯定有不使用lock的方法添加元素成功。</span></div><div class="line"></div><div class="line">         <span class="comment">//如果真有这样的方法它一定不是线程安全的。往下看吧- -!</span></div><div class="line"></div><div class="line">            <span class="keyword">while</span> (count == items.length)</div><div class="line"></div><div class="line">                notFull.await();</div><div class="line"></div><div class="line">            enqueue(e);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">            lock.unlock();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//插入元素到指定位置，放置下标前移，发出非空信号量 。持有锁才能调用</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line"></div><div class="line">        items[putIndex] = x;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (++putIndex == items.length)<span class="comment">//循环使用数组</span></div><div class="line"></div><div class="line">            putIndex = <span class="number">0</span>;</div><div class="line"></div><div class="line">        count++;</div><div class="line"></div><div class="line">        notEmpty.signal();<span class="comment">//发出非空信号</span></div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line"></div><div class="line">        lock.lockInterruptibly();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;<span class="comment">//队列为空等待</span></div><div class="line"></div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line"></div><div class="line">                notEmpty.await();</div><div class="line"></div><div class="line">            <span class="keyword">return</span> dequeue();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">            lock.unlock();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line"></div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"></div><div class="line">        E x = (E) items[takeIndex]; <span class="comment">//Object转泛型</span></div><div class="line"></div><div class="line">        items[takeIndex] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (++takeIndex == items.length)<span class="comment">//循环数组</span></div><div class="line"></div><div class="line">            takeIndex = <span class="number">0</span>;</div><div class="line"></div><div class="line">        count--;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</div><div class="line"></div><div class="line">            itrs.elementDequeued();</div><div class="line"></div><div class="line">        notFull.signal();<span class="comment">//发出非空通知</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> x;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="drainTo操作"><a href="#drainTo操作" class="headerlink" title="drainTo操作"></a>drainTo操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</div><div class="line"></div><div class="line">       checkNotNull(c);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (c == <span class="keyword">this</span>)</div><div class="line"></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</div><div class="line"></div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">       <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line"></div><div class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line"></div><div class="line">       lock.lock();</div><div class="line"></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">           <span class="keyword">int</span> n = Math.min(maxElements, count);</div><div class="line"></div><div class="line">           <span class="keyword">int</span> take = takeIndex;</div><div class="line"></div><div class="line">           <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">               <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">//有add存在不能保证n的正确性</span></div><div class="line"></div><div class="line">                   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"></div><div class="line">                   E x = (E) items[take];</div><div class="line"></div><div class="line">                   c.add(x);</div><div class="line"></div><div class="line">                   items[take] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (++take == items.length)<span class="comment">//循环添加</span></div><div class="line"></div><div class="line">                       take = <span class="number">0</span>;</div><div class="line"></div><div class="line">                   i++;</div><div class="line"></div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="keyword">return</span> n;</div><div class="line"></div><div class="line">           &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">               <span class="comment">// Restore invariants even if c.add() threw</span></div><div class="line"></div><div class="line">               <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">                   count -= i;</div><div class="line"></div><div class="line">                   takeIndex = take;<span class="comment">//下一次获取元素的位置</span></div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (count == <span class="number">0</span>)</div><div class="line"></div><div class="line">                           itrs.queueIsEmpty();</div><div class="line"></div><div class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; take)</div><div class="line"></div><div class="line">                           itrs.takeIndexWrapped();</div><div class="line"></div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); i--)</div><div class="line"></div><div class="line">                       notFull.signal();<span class="comment">//取走多个元素可以发出多个未满信号</span></div><div class="line"></div><div class="line">               &#125;</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">           lock.unlock();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>　　一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO（先进先出）排序元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。链表动态分配空间可以处理更多的节点，但是动态分配空间会两份一些时间。<br>　　可选的容量范围构造方法参数作为防止队列过度扩展的一种方法。如果未指定容量，则它等于 Integer.MAX_VALUE。除非插入节点会使队列超出容量，否则每次插入后会动态地创建链接节点。<br>与ArrayBlockingQueue的不同点1）一个使用数组，固定大小，一个使用链表,非固定大小，最大是int最大值2）LinkedBlockingQueue使用锁分离策略，正类包含takeLock和putLock两把锁，提高了并发效率。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private final int capacity;//记录队列容量</div><div class="line"></div><div class="line">//使用原子整数记录当前队列中元素的个数</div><div class="line"></div><div class="line">private final AtomicInteger count = new AtomicInteger();</div><div class="line"></div><div class="line">transient Node&lt;E&gt; head;//头部元素</div><div class="line"></div><div class="line">private transient Node&lt;E&gt; last;//尾部元素</div><div class="line"></div><div class="line">//获取头部元素锁和</div><div class="line"></div><div class="line">private final ReentrantLock takeLock = new ReentrantLock();</div><div class="line"></div><div class="line">private final Condition notEmpty = takeLock.newCondition();</div><div class="line"></div><div class="line">  //插入尾部元素锁</div><div class="line"></div><div class="line">private final ReentrantLock putLock = new ReentrantLock();</div><div class="line"></div><div class="line">private final Condition notFull = putLock.newCondition();</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public LinkedBlockingQueue(int capacity) &#123;</div><div class="line"></div><div class="line">    if (capacity &lt;= 0) throw new IllegalArgumentException();</div><div class="line"></div><div class="line">    this.capacity = capacity;</div><div class="line"></div><div class="line">    last = head = new Node&lt;E&gt;(null);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看出初始化的时候LBQ含有一个Node节点,头指针和尾指针都指向它，count=0。也就是说LBQ一直包含一个多余的Node节点。</p>
<h2 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line"></div><div class="line">       if (e == null) throw new NullPointerException();</div><div class="line"></div><div class="line">       int c = -1;</div><div class="line"></div><div class="line">       Node&lt;E&gt; node = new Node&lt;E&gt;(e);</div><div class="line"></div><div class="line">       final ReentrantLock putLock = this.putLock;</div><div class="line"></div><div class="line">      //putLock锁住以后队列中元素个数只会减小不会增大</div><div class="line"></div><div class="line">       final AtomicInteger count = this.count;</div><div class="line"></div><div class="line">       putLock.lockInterruptibly();//锁住put锁</div><div class="line"></div><div class="line">       try &#123;</div><div class="line"></div><div class="line">           while (count.get() == capacity) &#123;</div><div class="line"></div><div class="line">               notFull.await();</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">           enqueue(node);</div><div class="line"></div><div class="line">       //原子操作保证take与put不会导致线程安全问题</div><div class="line"></div><div class="line">           c = count.getAndIncrement();</div><div class="line"></div><div class="line">           if (c + 1 &lt; capacity)</div><div class="line"></div><div class="line">               notFull.signal();</div><div class="line"></div><div class="line">       &#125; finally &#123;</div><div class="line"></div><div class="line">           putLock.unlock();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (c == 0)</div><div class="line"></div><div class="line">           signalNotEmpty();</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   private void enqueue(Node&lt;E&gt; node) &#123;</div><div class="line"></div><div class="line">       last = last.next = node;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>需要公平机制来避免消费者、生产者饥饿，这时使用ABQ再好不过了。</p>
</li>
<li><p>如果队列的大小是有界的话，首选还是ABQ，ABQ的性能更好，不需要申请空间。否则还是LBQ吧！LBQ可以接受突入起来的大量生产者。</p>
</li>
<li>阻塞队列的效率某些场景的效率会低于非阻塞，下一次再写关于非阻塞队列CourrentLinkedQueue</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BlockingQueue接口]]></title>
      <url>http://baobing.github.io/2016/08/03/BlockingQueue%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>　　支持两个附加操作的 Queue，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。<br>　　<a id="more"></a><br>　　BlockingQueue 不接受 null 元素。试图 add、put 或 offer 一个 null 元素时，某些实现会抛出 NullPointerException。null 被用作指示 poll 操作失败的警戒值。<br>　　BlockingQueue 可以是限定容量的。它在任意给定时间都可以有一个 remainingCapacity，超出此容量，便无法无阻塞地 put 附加元素。没有任何内部容量约束的 BlockingQueue 总是报告 Integer.MAX_VALUE 的剩余容量。<br>　　BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。<br>　　BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和 removeAll）没有 必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，addAll(c) 有可能失败（抛出一个异常）。<br>　　BlockingQueue 实质上不 支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的 end-of-stream 或 poison 对象，并根据使用者获取这些对象的时间来对它们进行解释。</p>
<p>队列为空或者队列没有空间时的处理：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:right">返回特殊值</th>
<th style="text-align:right">阻塞</th>
<th style="text-align:right">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:right">offer(e)</td>
<td style="text-align:right">put(e)</td>
<td style="text-align:right">offer(e,time,unit)</td>
</tr>
<tr>
<td>删除</td>
<td style="text-align:center">remove()</td>
<td style="text-align:right">poll()</td>
<td style="text-align:right">take()</td>
<td style="text-align:right">poll(time,unit)</td>
</tr>
<tr>
<td>查看</td>
<td style="text-align:center">element()</td>
<td style="text-align:right">peek()</td>
<td style="text-align:right">不可用</td>
<td style="text-align:right">不可用</td>
</tr>
</tbody>
</table>
<h2 id="源码加注解"><a href="#源码加注解" class="headerlink" title="源码加注解"></a>源码加注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，</div><div class="line"></div><div class="line">     * 如果当前没有可用的     空间，则抛出 IllegalStateException。</div><div class="line"></div><div class="line">     * 当使用有容量限制的队列时，通常首选 offer。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，</div><div class="line"></div><div class="line">     * 如果当前没有可用的空间，则返回 false。当使用有容量限制的队列时，此方法通</div><div class="line"></div><div class="line">     * 常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 将指定元素插入此队列中，将等待可用的空间（如果有必要）。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 将指定元素插入此队列中，在到达指定的等待时间前等待可用的空间（如果有必要）。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的</div><div class="line"></div><div class="line">     * 附加元素数量；如果没有内部限制，则返回 Integer.MAX_VALUE。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 从此队列中移除指定元素的单个实例（如果存在）。更确切地讲，</div><div class="line"></div><div class="line">     * 如果此队列包含一个或多个满足 o.equals(e) 的元素 e，则移除</div><div class="line"></div><div class="line">     * 该元素。如果此队列包含指定元素（或者此队列由于调用而发生</div><div class="line"></div><div class="line">     * 更改），则返回 true。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 如果此队列包含指定元素，则返回 true。更确切地讲，当且仅当此</div><div class="line"></div><div class="line">     * 队列至少包含一个满足 o.equals(e) 的元素 e时，返回 true。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</div><div class="line"></div><div class="line">     * 此操作可能比反复轮询此队列更有效。在试图向 collection c 中添加元素</div><div class="line"></div><div class="line">     * 没有成功时，可能导致在抛出相关异常时，元素会同时在两个 collection</div><div class="line"></div><div class="line">     * 中出现，或者在其中一个 collection 中出现，也可能在两个 collection </div><div class="line"></div><div class="line">     * 中都不出现。如果试图将一个队列放入自身队列中，则会导致</div><div class="line"></div><div class="line">     * IllegalArgumentException 异常。此外，如果正在进行此操作时修改</div><div class="line"></div><div class="line">     * 指定的 collection，则此操作行为是不确定的。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 </div><div class="line"></div><div class="line">     * collection 中。与上个函数相同。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="/2016/08/03/ArrayBlockingQueue和LinkedBlockingQueue/">BlockingQueue实现类1:ArrayBlockingQueue和LinkedBlockingQueue</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM3-无锁]]></title>
      <url>http://baobing.github.io/2016/07/29/GYM3-%E6%97%A0%E9%94%81/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM2-Java内存模型和三个概念]]></title>
      <url>http://baobing.github.io/2016/07/29/GYM2-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>GYM是葛一鸣老师的简写。GYM系列文章都是观看葛老师课程的个人笔记。<br><a id="more"></a></p>
<blockquote>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
<h1 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h1><h2 id="高速缓存带来的不一致问题"><a href="#高速缓存带来的不一致问题" class="headerlink" title="高速缓存带来的不一致问题"></a>高速缓存带来的不一致问题</h2><p>　　计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
</blockquote>
<p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = i + 1;</div></pre></td></tr></table></figure></p>
<p>　　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>　　在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通常来说有以下2种解决方法：<br>1）通过在总线加LOCK#锁的方式<br>2）通过缓存一致性协议</p>
<p>　　因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。</p>
<p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。所以就出现了缓存一致性协议。最出名的就是Intel<strong><em> 的MESI协议</em></strong>，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h1 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>一个很经典的例子就是银行账户转账问题：<br>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。假设从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。所以这两个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//线程1执行的代码</div><div class="line">int i = 0;</div><div class="line">i = 10;</div><div class="line"> </div><div class="line">//线程2执行的代码</div><div class="line">j = i;</div></pre></td></tr></table></figure></p>
<p>　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。<br>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.<br>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h4><p>有序性：即程序执行的顺序按照代码的先后顺序执行。<br>举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int i = 0;             </div><div class="line">boolean flag = false;</div><div class="line">i = 1;                //语句1 </div><div class="line">flag = true;          //语句2</div></pre></td></tr></table></figure></p>
<p>　　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。<br>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。<br>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 10;    //语句1</div><div class="line">int r = 2;    //语句2</div><div class="line">a = a + 3;    //语句3</div><div class="line">r = a*a;     //语句4</div></pre></td></tr></table></figure></p>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3<br>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。<br>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//线程1:</div><div class="line">context = loadContext();   //语句1</div><div class="line">inited = true;             //语句2</div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p>
<p>　　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。<br>　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>　　下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。<br>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。<br>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。<br>举个简单的例子：<br>　　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。<br>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h2 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h2><p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。<br>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = 10;         //语句1</div><div class="line">y = x;         //语句2</div><div class="line">x++;           //语句3</div><div class="line">x = x + 1;     //语句4</div></pre></td></tr></table></figure></p>
<p>　　其实只有语句1是原子性操作，其他三个语句都不是原子性操作。<br>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。<br>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。<br>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。<br>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h2 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h2><p>对于可见性，Java提供了volatile关键字来保证可见性。<br>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br><strong><em>happens-before原则（先行发生原则）</em></strong><br>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>这8条原则摘自《深入理解Java虚拟机》。<br>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。<br>下面我们来解释一下前4条规则：<br>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。<br>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。<br>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。<br>　　第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h1 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h1><h2 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。<br>先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//线程1</div><div class="line">boolean stop = false;</div><div class="line">while(!stop)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">//线程2</div><div class="line">stop = true;</div></pre></td></tr></table></figure>
<p>　<br>　<br>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。<br>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。<br>　　但是用volatile修饰之后就变得不一样了：<br>第一：使用volatile关键字会强制将修改的值立即写入主存；<br>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。<br>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。<br>那么线程1读取到的就是最新的正确的值。</p>
<h2 id="volatile保证原子性吗？"><a href="#volatile保证原子性吗？" class="headerlink" title="volatile保证原子性吗？"></a>volatile保证原子性吗？</h2><p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。<br>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：<br>　　假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。<br>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。那么两个线程分别进行了一次自增操作后，inc只增加了1。<br>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。<br>把上面的代码改成以下任何一种都可以达到效果：<br>采用synchronized：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public  int inc = 0;</div><div class="line"> </div><div class="line">    public synchronized void increase() &#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">        for(int i=0;i&lt;10;i++)&#123;</div><div class="line">            new Thread()&#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    for(int j=0;j&lt;1000;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="volatile能保证有序性吗？"><a href="#volatile能保证有序性吗？" class="headerlink" title="volatile能保证有序性吗？"></a>volatile能保证有序性吗？</h2><p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。<br>volatile关键字禁止指令重排序有两层意思：<br>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br>可能上面说的比较绕，举个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//x、y为非volatile变量</div><div class="line">//flag为volatile变量</div><div class="line"> </div><div class="line">x = 2;        //语句1</div><div class="line">y = 0;        //语句2</div><div class="line">flag = true;  //语句3</div><div class="line">x = 4;         //语句4</div><div class="line">y = -1;       //语句5</div></pre></td></tr></table></figure></p>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。<br>那么我们回到前面举的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//线程1:</div><div class="line">context = loadContext();   //语句1</div><div class="line">inited = true;             //语句2</div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。<br>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h2 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h2><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>2）它会强制将对缓存的修改操作立即写入主存；<br>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。<br>内存屏障可以被分为以下几种类型<br>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p>
<p>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。<br>为了实现上一章中讨论的JSR-133的规定，Java编译器会这样使用内存屏障。</p>
<p>内存屏障示意表</p>
<p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障。<br>x.finalField = v; StoreStore; sharedRef = x;</p>
<h1 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h1><p>　　通常来说，使用volatile必须具备以下2个条件：<br>1）对变量的写操作不依赖于当前值<br>2）该变量没有包含在具有其他变量的不变式中<br>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<h2 id="状态标记量"><a href="#状态标记量" class="headerlink" title="状态标记量"></a>状态标记量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">volatile boolean flag = false;</div><div class="line"> </div><div class="line">while(!flag)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public void setFlag() &#123;</div><div class="line">    flag = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">volatile boolean inited = false;</div><div class="line">//线程1:</div><div class="line">context = loadContext(); </div><div class="line">inited = true;           </div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<h2 id="double-check"><a href="#double-check" class="headerlink" title="double check"></a>double check</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">    private volatile static Singleton instance = null;</div><div class="line"> </div><div class="line">    private Singleton() &#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        if(instance==null) &#123;</div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                if(instance==null)</div><div class="line">                    instance = new Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>29</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM1-并发基础和Thread类详解]]></title>
      <url>http://baobing.github.io/2016/07/29/GYM1-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%92%8CThread%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>GYM是葛一鸣老师的简写。GYM系列文章都是观看葛老师课程的个人笔记。<br><a id="more"></a></p>
<h1 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h1><p>1.发挥多处理器的强大能力<br>2.代码责任单一，方便调试<br>3.异步事件的简化处理,防止客户端阻塞<br>4.响应更灵敏的用户界面</p>
<h1 id="多线程危害"><a href="#多线程危害" class="headerlink" title="多线程危害"></a>多线程危害</h1><p>1.线程安全性可能是非常复杂的，线程执行顺序是不可预测的，竞争条件，脏读。<br>2.活跃性问题：某件正确的事情最终会发生，死锁。<br>3.性能问题：context Switch 切换、影响性能。</p>
<h1 id="java线程状态"><a href="#java线程状态" class="headerlink" title="java线程状态"></a>java线程状态</h1><p>1.New：状态 已经分配内存，无cpu时间<br>2.Runable： 资源已经全部分配，可能在已经分配cpu时间<br>3.blocked：进入临界区，被挂起<br>4.waiting：等他其他线程唤醒，或者定时唤醒<br>5.terminated：终止状态<br><img src="/2016/07/29/GYM1-并发基础和Thread类详解/ThreadStatus.png" alt="图1" title="图1"></p>
<h1 id="java线程的操作"><a href="#java线程的操作" class="headerlink" title="java线程的操作"></a>java线程的操作</h1><ul>
<li>Thread的start()在新的线程中调用run()方法，单纯吊用run()方法不会开启一个新的线程。</li>
<li>两种方法新建：<br>（1）传递一个实现Runable的类；<br>（2）重载Thread的run()方法；</li>
<li>每个线程都拥有自己的名字；<h1 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h1></li>
<li>thread.stop() 不建议使用，过于暴力，直接终止，可能导致数据的不一致，。</li>
<li>thread.interruput() 中断线程，只是给相应的线程打招呼，并不会真的终端线程</li>
<li>thread.isInterruput() 判断线程是否被中断，采取相应的措施</li>
<li>thread.sleep() InterruptedException<br>在sleep过程中其他线程发送中断请求 ，可以在catch中做出中断处理。<br>中断异常的时候清空中断标志位，catch中需要重新设置中断标志，while中使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">static class InterruptedThread implements Runnable &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        while (true) &#123;</div><div class="line">            if (Thread.currentThread().isInterrupted()) &#123;</div><div class="line">                System.out.println(&quot;i am breaking&quot;);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(&quot;i want to sleep&quot;);</div><div class="line">                Thread.sleep(5000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                System.out.println(&quot;someone interrupt me&quot;);</div><div class="line">            //恢复中断标志位</div><div class="line">                Thread.currentThread().interrupt();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException&#123;</div><div class="line">    Thread thread = new Thread(new InterruptedThread(), &quot;t1&quot;);</div><div class="line">    thread.start();</div><div class="line">    Thread.sleep(7000);</div><div class="line">    thread.interrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>输出结果：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i want to sleep</div><div class="line">i want to sleep</div><div class="line">someone interrupt me</div><div class="line">i am breaking</div></pre></td></tr></table></figure></p>
<h1 id="六、线程挂起和继续执行"><a href="#六、线程挂起和继续执行" class="headerlink" title="六、线程挂起和继续执行"></a>六、线程挂起和继续执行</h1><p>不建议使用，resume()发生在suspend之前时，线程无法释放锁处于runnable转台</p>
<ul>
<li>tread.suspend() 占用锁不释放</li>
<li>thread.resume()  重启线程</li>
</ul>
<h1 id="七、等待和谦让（debugger、测试可能使用）"><a href="#七、等待和谦让（debugger、测试可能使用）" class="headerlink" title="七、等待和谦让（debugger、测试可能使用）"></a>七、等待和谦让（debugger、测试可能使用）</h1><ul>
<li>thread.yield() 释放当前线程的cpu时间，但是还是继续竞争，</li>
<li>thread.join()等待线程结束<br>调用线程等待join函数的所属线程结束<h2 id="join实现代码"><a href="#join实现代码" class="headerlink" title="join实现代码"></a>join实现代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public final synchronized void join(long millis)</div><div class="line">    throws InterruptedException &#123;</div><div class="line">        long base = System.currentTimeMillis();</div><div class="line">        long now = 0;</div><div class="line">        if (millis &lt; 0) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class="line">        &#125;</div><div class="line">        if (millis == 0) &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                wait(0);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                long delay = millis - now;</div><div class="line">                if (delay &lt;= 0) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                wait(delay);</div><div class="line">                now = System.currentTimeMillis() - base;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>在后台默默完成一些系统性的服务，如GC、JIT理解为守护线程<br>setDeamon();在start之前设置<br>如果没有业务线程守护线程也会死掉。</p>
<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p>setPriority(Thread.MAX_PRORITY)<br>高优先级程序不一定就能一直抢占cpu时间，只是几率高一些</p>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><ul>
<li>synchronized<br>（1）指定加锁对象<br>（2）修饰实例方法：相当于当前对象加锁<br>（3）直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁</li>
<li>object.wait()、object.notify()、notifyAll()<pre><code>没有获得监视器之前不能使用wait(),会释放当前线程的监视器，通知其他线程执行；
notify之后不会立即启动wait方法，拿到锁之后可以继续执行wait之后的事情。唤醒所有等待监视器的线程中的其中一个线程。notifyAll唤醒所有的线程，去争用监视器。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">    public static Boolean flag = true;</div><div class="line"></div><div class="line">    public static class Task implements Runnable &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">            //必须获取监视器才能用wait 会排数InterruptedException</div><div class="line">                synchronized (flag) &#123;</div><div class="line">                    System.out.println(&quot;im ready to wait&quot;);</div><div class="line">                    flag.wait();</div><div class="line">                    System.out.println(&quot;someone notify me&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        new Thread(new Task()).start();</div><div class="line">        Thread.sleep(5000);</div><div class="line">        synchronized (flag) &#123;</div><div class="line">            TestWaitNotify.flag.notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">输出结果  </div><div class="line">/**</div><div class="line">  *im ready to wait</div><div class="line">  *someone notify me</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ul>
<p>﻿</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组中只出现一次的数字]]></title>
      <url>http://baobing.github.io/2016/07/28/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个整型数组里除了两个数字之外，其他的数字都出现两次。请写程序找出这两个只出现一次的数字。要求时间复杂度为O(n),空间复杂度为O（1）。<br>{2，4，3，6，3，2，5，5} 结果为4，6。<br><a id="more"></a></p>
<h1 id="异或运算的特性"><a href="#异或运算的特性" class="headerlink" title="异或运算的特性"></a>异或运算的特性</h1><ol>
<li>交换律 a^b = b^a</li>
<li>结合律 a^b^c = a^(b^c)</li>
<li>a^a = 0</li>
<li>0^a = a</li>
<li>a^b^a = a^a^b = b</li>
<li>如果a^b = 1 != 0，则a与b的二进制形式的个位是不相同的</li>
</ol>
<h1 id="结题思路"><a href="#结题思路" class="headerlink" title="结题思路"></a>结题思路</h1><h2 id="只有一个数字只出现一次"><a href="#只有一个数字只出现一次" class="headerlink" title="只有一个数字只出现一次"></a>只有一个数字只出现一次</h2><p>题目如果改为只有一个出现一次的数字。<br>根据特性5，我们只需要把所有的数字一起异或就会得到这个只出现一次的数字N.<br>N = 0^A[0]^A[1]^A[2]….</p>
<h2 id="两个数字只出现一次"><a href="#两个数字只出现一次" class="headerlink" title="两个数字只出现一次"></a>两个数字只出现一次</h2><p>1) x = n^m = 0^A[0]^A[1]^A[2]….<br>根据特性6我们知道如果n,m不相等.他们异或的结果的二进制形式的每一位都代表n，m二进制对应位不相同。例如两个二进制数字a,b异或：10011^11011 = 1000 , 二进制结果中只有第四位数字等于1，则a，b的第四位不同。<br>2）挑选所有元素异或结果x的其中一个为1的位置不变，其他位置变为0，得到y.假设x的二进制形式为10110，y=10000.<br>3）每个元素与y进行与运算，结果为等于y的是一组，结果不为y的是一组。n和m一定不在同一组。<br>4）问题转化为只有一个数字只出现一次</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestXor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getArrXorResult</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</div><div class="line">            result ^= arr[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getXOne</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (l = <span class="number">0</span>; x &gt;&gt; <span class="number">1</span> != <span class="number">0</span>; l++) &#123;</div><div class="line">            x &gt;&gt;= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; l;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</div><div class="line">        <span class="comment">//分别装载两个分组</span></div><div class="line">        <span class="keyword">int</span>[] arr0 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</div><div class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</div><div class="line">        <span class="keyword">int</span> x = getArrXorResult(arr, <span class="number">0</span>, arr.length);</div><div class="line">        <span class="comment">//获取异或结果二进制结果是1的最大的那个</span></div><div class="line">        <span class="keyword">int</span> y = getXOne(x);</div><div class="line">        <span class="keyword">int</span> index0 = <span class="number">0</span>, index1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> ((arr[i] &amp; y) == y) &#123;</div><div class="line">                arr0[index0++] = arr[i];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                arr1[index1++] = arr[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> n = getArrXorResult(arr0, <span class="number">0</span>, index0);</div><div class="line">        <span class="keyword">int</span> m = getArrXorResult(arr1, <span class="number">0</span>, index1);</div><div class="line">        System.out.println(<span class="string">"n="</span> + n + <span class="string">" m="</span> + m);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组排成最小的数]]></title>
      <url>http://baobing.github.io/2016/07/28/%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>　　输入一个正整数数组，每个元素都不相等，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如数组{3，32，321},则打印出这3个数字能排成的最小数字321323.（《jianzhiOffer》P177）<br><a id="more"></a><br>　　贪心算法的题目，找到解决办法不能，难得是给出正确性证明。书中给出了证明，前半段讲的很好，不过后半段不是很满意。
　　</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>1）将数组中所有数字转化为字符串，组成新的数组Str<br>2）对所有字符串排序。 return Str[i]+Str[j]&lt;Str[j]+Str[i]</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStringComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> (o1.toString() + o2.toString()).compareTo(o2.toString() + o1.toString());</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">32</span>, <span class="number">321</span>&#125;;</div><div class="line">     List&lt;Integer&gt; list = Arrays.asList(arr);</div><div class="line">     Collections.sort(list, <span class="keyword">new</span> MinStringComparator());</div><div class="line">     StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">100</span>);</div><div class="line">     <span class="keyword">for</span> (Integer e : list) &#123;</div><div class="line">         stringBuilder.append(e);</div><div class="line">     &#125;</div><div class="line">     System.out.println(stringBuilder.toString());</div></pre></td></tr></table></figure>
<h1 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h1><h2 id="排序关系有效性证明"><a href="#排序关系有效性证明" class="headerlink" title="排序关系有效性证明"></a>排序关系有效性证明</h2><p>一个有效的比较规则一定满足自反性、对称性和传递性。<br>1）自反性：显然有 aa = aa,所以a等于a。<br>2）传递性：如果a小于b，则ab<ba。所以ba>ab,因此b大于a。<br>3）传递性：假设a小于b，ab&lt;ba. b小于c，bc&lt;cb<br>a的十进制为m位，b的十进制为n位，c的十进制为k位</ba。所以ba></p>
<img src="/2016/07/28/数组排成最小的数/transitivity.png" alt="传递性证明过程" title="传递性证明过程">
<p>因此 a小于b，b小于c，a必定小于c</p>
<h2 id="最终证明"><a href="#最终证明" class="headerlink" title="最终证明"></a>最终证明</h2><p>排序关系证明是很重要的前提。正面证明很困难，使用反证法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">假设存在一个序列A小于序列B。</div><div class="line">1）假设B[i] = A[j],我们可以一直向前或者向后移动B[i]直到B[i]到达位置j。B序列中的每一个元素都按照这种方法移动即可得到A序列。</div><div class="line">2）现在我没减缓这个移动过程，每次只移动一个特定的元素B[i]一步直到B[i]到达位置j，而且一次只移动一步。可就是说经过一次移动序列B(0)：B[0]...B[i-1]B[i]...变为B(1):[0]...B[i]B[i-1]...。 B(l)代表序列B经历过l次移动。</div><div class="line">3)因为B[i-1]B[i]&lt;B[i]B[i-1]（这一点需要排序关系证明的支持才能成立），所以B[0]...B[i-1]B[i]...&lt;[0]...B[i]B[i-1]...</div><div class="line">4）因为B[i]B[i+1]&lt;B[i+1]B[i]（这一点需要排序关系证明的支持才能成立），所以B[0]...B[i-1]B[i]...&lt;[0]...B[i]B[i-1]...</div><div class="line">5)因为B(0)&lt;B(1)&lt;B(2)&lt;...&lt;B(x)=A(0)，所以B&lt;A</div><div class="line">这与题设不相符，所以假设不成立。也就是说A是最小的序列</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap源码解析]]></title>
      <url>http://baobing.github.io/2016/07/25/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>　　 JDK1.8中，ConcurrentHashMap的源码竟然有6300行,作者是大名鼎鼎Doug Lea（感谢开源让我离大神可以这么近，不过代码风格明显没打算交给他人维护）。本文只讲述扩容相关的内容，其他操作就放弃了。文章参考一下别人的文章，主要是以下两篇文章：<br>　　 <a id="more"></a></p>
<blockquote>
<p><a href="http://blog.csdn.net/u010887744/article/details/51002358" target="_blank" rel="external">http://blog.csdn.net/u010887744/article/details/51002358</a><br><a href="http://www.cnblogs.com/huaizuo/p/5413069.html" target="_blank" rel="external">http://www.cnblogs.com/huaizuo/p/5413069.html</a><br>　　友情提示：看ConcurrentHashMap源码还是需要一些Java并发编程的了解，比如内存可见性、原子性、顺序性、无锁。另一点就是先阅读HashMap的源码。</p>
<h1 id="JDK8-HashMap数据结构"><a href="#JDK8-HashMap数据结构" class="headerlink" title="JDK8 HashMap数据结构"></a>JDK8 HashMap数据结构</h1></blockquote>
<p><center></center></p>
<p><center>图1</center><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;</div><div class="line">        final K key;</div><div class="line">        volatile V val;</div><div class="line">        volatile Node&lt;K,V&gt; next;</div><div class="line">       //省略省略</div><div class="line">&#125;</div><div class="line"> transient volatile Node&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure></p>
<p>　　HashMap底层由数组、链表和红黑树三者组成。我们从图1和源码大改也可以推断出来。首先是HashMap使用Node组成的数组table装载所有的键值对，再者HashMap发生Hash值碰撞使用链表将它们连起来，最后是某个链表长度大于指定值链表转化为红黑树。   </p>
<h1 id="重要的常量"><a href="#重要的常量" class="headerlink" title="重要的常量"></a>重要的常量</h1><h2 id="基本常量"><a href="#基本常量" class="headerlink" title="基本常量"></a>基本常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> transient volatile Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line"> //扩容时使用，其他时候为null</div><div class="line"> private transient volatile Node&lt;K,V&gt;[] nextTable;</div><div class="line"></div><div class="line"> //基础计数器，主要用于无争用，同时也作为table数组初始化的回退记录</div><div class="line"> private transient volatile long baseCount;</div><div class="line"></div><div class="line"> //table数组初始化和扩容的控制标志。为负数时，table数组正在扩容或初始化，</div><div class="line"> //-1代表初始化，其他负数表示 -（1+参数扩容的线程数量）。当table为null时，</div><div class="line"> //sizeCtl持有扩容的阈值，0为默认值。</div><div class="line"> private transient volatile int sizeCtl;</div><div class="line"></div><div class="line">//table扩容时 每个线程最少需要处理的元素数量。看不懂就跳过去，下同</div><div class="line"> private static final int MIN_TRANSFER_STRIDE = 16;</div><div class="line"></div><div class="line"> //当table扩容时，transferIndex持有下一个线程或者下次循环可以处理的数组界限</div><div class="line"> private transient volatile int transferIndex;</div><div class="line"></div><div class="line"> //table数组的默认长度</div><div class="line"> private static final int DEFAULT_CAPACITY = 16;</div><div class="line"></div><div class="line"> //table数组的负载因子. 小数形式不经常使用，它更常见的表示形式是 n - (n &gt;&gt;&gt; 2)</div><div class="line"> private static final float LOAD_FACTOR = 0.75f;</div></pre></td></tr></table></figure>
<h2 id="Unsafe相关常量"><a href="#Unsafe相关常量" class="headerlink" title="Unsafe相关常量"></a>Unsafe相关常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// Unsafe mechanics</div><div class="line">    private static final sun.misc.Unsafe U;</div><div class="line">    private static final long SIZECTL; //sizeCtl的偏移量</div><div class="line">    private static final long TRANSFERINDEX; //transferIndex的偏移量</div><div class="line">    private static final long BASECOUNT;   //</div><div class="line">    private static final long CELLSBUSY;</div><div class="line">    private static final long CELLVALUE;</div><div class="line">    //数组中第一个元素在数组中的位置</div><div class="line">    private static final long ABASE;</div><div class="line">     //Node数组元素大小scale的二进制去除前导零后的位数</div><div class="line">    private static final int ASHIFT;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        try &#123;</div><div class="line">            U = sun.misc.Unsafe.getUnsafe();</div><div class="line">            Class&lt;?&gt; k = ConcurrentHashMap.class;</div><div class="line">    ﻿    ﻿  //获取sizeCtl的偏移量</div><div class="line">            SIZECTL = U.objectFieldOffset(k.getDeclaredField(&quot;sizeCtl&quot;)); </div><div class="line">    ﻿    ﻿  //省略代码，和上面一样获取各个变量的偏移量</div><div class="line">             ...</div><div class="line">            Class&lt;?&gt; ak = Node[].class;</div><div class="line">            //Arrays和Java别的对象一样，都有一个对象头，它是存储在实际的数据前面的。</div><div class="line">            //这个头的长度可以通过unsafe.arrayBaseOffset(T[].class) 方法来获取到，</div><div class="line">    ﻿    ﻿    ﻿ //这里T是数组元素的类型</div><div class="line">            ABASE = U.arrayBaseOffset(ak); </div><div class="line">            int scale = U.arrayIndexScale(ak); //获取数组元素的大小</div><div class="line">            if ((scale &amp; (scale - 1)) != 0) //元素大小必须是2的倍数，不知道为什么</div><div class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</div><div class="line">            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw new Error(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h1><h2 id="无锁方法"><a href="#无锁方法" class="headerlink" title="无锁方法"></a>无锁方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    //内存中直接获取tab数组张第i个元素，保证内存可见性</div><div class="line">      static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</div><div class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">    &#125;</div><div class="line">   //为tab数组的第i个元素复制，使用CAS，保证操作的原子性</div><div class="line"></div><div class="line">    static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">    &#125;</div><div class="line">   static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</div><div class="line">/**设置obj对象中offset偏移地址对应的object型field的值为指定值。这是一个有序或者</div><div class="line"> 有延迟的putObjectVolatile方法，并且不保证值的改变被其他线程立</div><div class="line"> 即看到。只有在field被&lt;code&gt;volatile&lt;/code&gt;修饰并且期望被意外修改的时候</div><div class="line">  使用才有用。*/</div><div class="line">        U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="扩容方法transfer"><a href="#扩容方法transfer" class="headerlink" title="扩容方法transfer"></a>扩容方法transfer</h2><h3 id="扩容过程解析"><a href="#扩容过程解析" class="headerlink" title="扩容过程解析"></a>扩容过程解析</h3><p>　　ConcurrentHashMap无锁多线程扩容，减少扩容时的时间消耗。单线程构建两倍容量的nextTable；允许多线程复制原table元素到nextTable。为每个内核均分任务，并保证其不小于16（常量MIN_TRANSFER_STRIDE）。<br>1）若nextTab为null，则初始化其为原table的2倍；<br>2）死循环遍历，直到finishing。</p>
<ul>
<li>节点为空，则插入ForwardingNode；</li>
<li>链表节点（fh&gt;=0），分别插入nextTable的i和i+n的位置；</li>
<li>TreeBin节点（fh&lt;0），判断是否需要untreefi，分别插入nextTable的i和i+n的位置；</li>
<li>finishing时，nextTab赋给table，更新sizeCtl为新容量的0.75倍 ，完成扩容。<br>以上说的都是单线程，多线程又是如何实现的呢？<pre><code>遍历到ForwardingNode节点((fh = f.hash) == MOVED)，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心 。由于给节点上了锁，只允许当前线程完成此节点的操作，处理完毕后，将对应值设为ForwardingNode（fwd），其他线程看到forward，直接向后遍历。如此便完成了多线程的复制工作，也解决了线程安全问题。
</code></pre></li>
</ul>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Moves and/or copies the nodes in each bin to new table. See</div><div class="line"> * above for explanation.</div><div class="line"> */</div><div class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class="line">    //n表示原数组的大小 ,stride表示每个线程或者单次循环负责节点的个数 </div><div class="line">    int n = tab.length, stride;</div><div class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</div><div class="line">    if (nextTab == null) &#123;            // 为nextTable申请空间</div><div class="line">        try &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</div><div class="line">            nextTab = nt;</div><div class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</div><div class="line">            sizeCtl = Integer.MAX_VALUE;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        nextTable = nextTab;</div><div class="line">        transferIndex = n;</div><div class="line">    &#125;</div><div class="line">    int nextn = nextTab.length;</div><div class="line">    //构建一个连节点的指针，用于标识位</div><div class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">    boolean advance = true;</div><div class="line">    //循环的关键变量，判断是否已经扩容完成</div><div class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</div><div class="line">    //i--操作保证了倒序遍历数组，bound表示新的线程或者单次循环的下边界</div><div class="line">    for (int i = 0, bound = 0;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int fh;</div><div class="line">      </div><div class="line">        while (advance) &#123;</div><div class="line">            int nextIndex, nextBound;</div><div class="line">            if (--i &gt;= bound || finishing) //循环没有到达下边界可以继续for循环</div><div class="line">                advance = false;</div><div class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123; //整个for循环过程结束</div><div class="line">                i = -1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">    ﻿    ﻿   //只有通过CAS成功更新ransferIndex才能获取到扩容的资格</div><div class="line">            else if (U.compareAndSwapInt  </div><div class="line">                     (this, TRANSFERINDEX, nextIndex,</div><div class="line">                      nextBound = (nextIndex &gt; stride ?</div><div class="line">                                   nextIndex - stride : 0))) &#123;</div><div class="line">                bound = nextBound;</div><div class="line">                i = nextIndex - 1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //i&lt;0说明已经遍历完旧的数组tab；i&gt;=n什么时候有可能呢？</div><div class="line">    ﻿   //在下面看到i=n,所以目前i最大应该是n吧,导致的原因可能是多线程</div><div class="line">        //i+n&gt;=nextn,nextn=nextTab.length，所以如果满足i+n&gt;=nextn说明已经扩容完成</div><div class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; </div><div class="line">            int sc;</div><div class="line">            if (finishing) &#123;//a</div><div class="line">                nextTable = null;</div><div class="line">                table = nextTab;</div><div class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            //利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，</div><div class="line">    ﻿    ﻿   //说明新加入一个线程参与到扩容操作,参考sizeCtl的注释</div><div class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class="line">                //如果有多个线程进行扩容，那么这个值在第二个线程以后就不会相等，</div><div class="line">    ﻿    ﻿      ﻿//因为sizeCtl已经被减1了，所以后面的线程就只能直接返回,</div><div class="line">    ﻿    ﻿    ﻿  //始终保证只有一个线程执行了 a(上面注释a)</div><div class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class="line">                    return;</div><div class="line">    ﻿    ﻿    ﻿//finishing和advance保证线程已经扩容完成了可以退出循环</div><div class="line">                finishing = advance = true;</div><div class="line">                i = n; // recheck before commit</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ﻿   //如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了</div><div class="line">        else if ((f = tabAt(tab, i)) == null)</div><div class="line">            advance = casTabAt(tab, i, null, fwd);</div><div class="line">    ﻿    //那么如果f.hash=-1的话说明该节点为ForwardingNode，说明该节点已经处理过了</div><div class="line">        else if ((fh = f.hash) == MOVED)</div><div class="line">            advance = true; // already processed</div><div class="line">        else &#123;</div><div class="line">            synchronized (f) &#123;</div><div class="line">                if (tabAt(tab, i) == f) &#123;</div><div class="line">                    Node&lt;K,V&gt; ln, hn;</div><div class="line">                    if (fh &gt;= 0) &#123;</div><div class="line">                        int runBit = fh &amp; n;</div><div class="line">                        Node&lt;K,V&gt; lastRun = f;</div><div class="line">                        //把链表分表拆分为，hash&amp;n等于0和不等于0的，</div><div class="line">    ﻿    ﻿    ﻿    ﻿    //然后分别放在新表的i和i+n位置。n一定是2的幂，这个很重要</div><div class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</div><div class="line">                            int b = p.hash &amp; n;</div><div class="line">                            if (b != runBit) &#123;</div><div class="line">                                runBit = b;</div><div class="line">                                lastRun = p;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        if (runBit == 0) &#123;</div><div class="line">                            ln = lastRun;</div><div class="line">                            hn = null;</div><div class="line">                        &#125;</div><div class="line">                        else &#123;</div><div class="line">                            hn = lastRun;</div><div class="line">                            ln = null;</div><div class="line">                        &#125;</div><div class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                            if ((ph &amp; n) == 0)</div><div class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                            else</div><div class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                        &#125;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        //把已经替换的节点的旧tab的i的位置用fwd替换，fwd包含nextTab</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;//下面红黑树基本和链表差不多</div><div class="line">                    else if (f instanceof TreeBin) &#123;</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</div><div class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</div><div class="line">                        int lc = 0, hc = 0;</div><div class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</div><div class="line">                            int h = e.hash;</div><div class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div class="line">                                (h, e.key, e.val, null, null);</div><div class="line">                            if ((h &amp; n) == 0) &#123;</div><div class="line">                                if ((p.prev = loTail) == null)</div><div class="line">                                    lo = p;</div><div class="line">                                else</div><div class="line">                                    loTail.next = p;</div><div class="line">                                loTail = p;</div><div class="line">                                ++lc;</div><div class="line">                            &#125;</div><div class="line">                            else &#123;</div><div class="line">                                if ((p.prev = hiTail) == null)</div><div class="line">                                    hi = p;</div><div class="line">                                else</div><div class="line">                                    hiTail.next = p;</div><div class="line">                                hiTail = p;</div><div class="line">                                ++hc;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        //判断扩容后是否还需要红黑树结构</div><div class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</div><div class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[红黑树和HashMap中实现]]></title>
      <url>http://baobing.github.io/2016/07/25/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%A5%E5%8F%8AHashMap/</url>
      <content type="html"><![CDATA[<p>　　本人最近在看JDK的HashMap源码，在JDK1.8中引入红黑树。引入红黑树的原因是加快hash碰撞较多情景下的查找速度。网上找到下面这篇文章感觉写的非常好，思路清晰。我会在原文章基础上做一点批注，方便日后阅读。<br>　　<a id="more"></a></p>
<blockquote>
<p><a href="http://blog.csdn.net/eric491179912/article/details/6179908" target="_blank" rel="external">http://blog.csdn.net/eric491179912/article/details/6179908</a></p>
</blockquote>
<h1 id="红黑树的基本特性"><a href="#红黑树的基本特性" class="headerlink" title="红黑树的基本特性"></a>红黑树的基本特性</h1><p>　　一定要牢记这五条特性，推导全靠这几条原则。 </p>
<ol>
<li><p>节点是红色或黑色。</p>
</li>
<li><p>根节点是黑色。</p>
</li>
<li><p>每个叶节点（NIL节点，空节点）是黑色的。<strong><em>这个限制根本没有用啊，亲 - -！</em></strong></p>
</li>
<li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
</li>
<li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
</li>
</ol>
<h1 id="红黑树上结点的插入"><a href="#红黑树上结点的插入" class="headerlink" title="红黑树上结点的插入"></a>红黑树上结点的插入</h1><p>　　<strong><em>任何一个即将插入的新结点的初始颜色都为红色。</em></strong>这一点很容易理解，因为插入黑点会增加某条路径上黑结点的数目，从而导致整棵树黑高度的不平衡。但如果新结点父结点为红色时（如图1所示），将会违返红黑树性质：一条路径上不能出现相邻的两个红色结点。这时就需要通过一系列操作来使红黑树保持平衡。</p>
<center><img src="/2016/07/25/红黑树以及HashMap/insert1.jpg" alt="图1" title="图1"></center>

<p>　　为了清楚地表示插入操作以下在结点中使用“新”字表示一个新插入的结点；使用“父”字表示新插入点的父结点；使用“叔”字表示“父”结点的兄弟结点；使用“祖”字表示“父”结点的父结点。插入操作分为以下几种情况：</p>
<h2 id="该树为空树。"><a href="#该树为空树。" class="headerlink" title="该树为空树。"></a>该树为空树。</h2><p>直接插入根结点的位置，违反性质2，把节点颜色有红改为黑即可。</p>
<h2 id="黑父"><a href="#黑父" class="headerlink" title="黑父"></a>黑父</h2><p>　　如图2所示，如果新点的父结点为黑色结点，那么插入一个红点将不会影响红黑树的平衡，此时插入操作完成。红黑树比AVL树优秀的地方之一在于黑父的情况比较常见，从而使红黑树需要旋转的几率相对AVL树来说会少一些。</p>
<center><img src="/2016/07/25/红黑树以及HashMap/insert2.jpg" alt="图2" title="图2"></center>


<h2 id="红父"><a href="#红父" class="headerlink" title="红父"></a>红父</h2><p>　　如图3所示，由于父结点为红色，此时可以判定，祖父结点必定为黑色。这时需要根据叔父结点的颜色来决定做什么样的操作。青色结点表示颜色未知。由于有可能需要根结点到新点的路径上进行多次旋转操作，而每次进行不平衡判断的起始点（<strong><em>我们可将其视为新点</em></strong>）都不一样。所以我们在此使用一个蓝色箭头指向这个起始点，并称之为判定点。<br>　　注：把一个树看成一个新的节点，继续进行旋转。这点很重要。</p>
<center><img src="/2016/07/25/红黑树以及HashMap/insert3.jpg" alt="insert3.jpg" title=""></center>


<h3 id="红叔"><a href="#红叔" class="headerlink" title="红叔"></a>红叔</h3><p>　　当叔父结点为红色时，如图4所示，无需进行旋转操作，只要将父和叔结点变为黑色，将祖父结点变为红色即可。但由于祖父结点的父结点有可能为红色，从而违反红黑树性质。此时必须将祖父结点作为新的判定点继续向上进行平衡操作。需要注意，无论“父”在“叔”的左边还是右边，无论“新”是“父”的左孩子还是右孩子，它们的操作都完全一样。</p>
<p><center><img src="/2016/07/25/红黑树以及HashMap/insert4.jpg" alt="insert4.jpg" title=""></center><br>　　注：如果祖父节点是根节点怎么办？答案是进行情景一的操作，把祖父节点变为黑色。</p>
<h3 id="黑叔"><a href="#黑叔" class="headerlink" title="黑叔"></a>黑叔</h3><p>情形1：<br><img src="/2016/07/25/红黑树以及HashMap/insert5.jpg" alt="insert5.jpg" title=""></p>
<p>情形2：<br><img src="/2016/07/25/红黑树以及HashMap/insert6.jpg" alt="insert6.jpg" title=""></p>
<p>情形3：</p>
<img src="/2016/07/25/红黑树以及HashMap/insert7.jpg" alt="insert7.jpg" title="">
<p>情形4：</p>
<img src="/2016/07/25/红黑树以及HashMap/insert8.jpg" alt="insert8.jpg" title="">
<p>　　可以观察到，当旋转完成后，新的旋转根全部为黑色，此时不需要再向上回溯进行平衡操作，插入操作完成。需要注意，上面四张图的“叔”、“1”、“2”、“3”结点有可能为黑哨兵结点。<br>　　其实红黑树的插入操作不是很难，甚至比AVL树的插入操作还更简单些。但删除操作就远远比AVL树复杂得多，下面就介绍红黑树的删除操作。
　　</p>
<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><p>主要讲解红黑树的平衡插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//LinkedHashMap.Entry&lt;K,V&gt;继承自HashMap.Node&lt;K,V&gt; </span></div><div class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; parent;<span class="comment">//parent阴阳记录父亲节点</span></div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; left;<span class="comment">//left、right其中一个记录叔叔节点</span></div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; right;</div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; prev;  <span class="comment">// needed to unlink next upon deletion</span></div><div class="line"></div><div class="line">     <span class="keyword">boolean</span> red; <span class="comment">//记录节点的颜色</span></div><div class="line"></div><div class="line">     TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</div><div class="line"></div><div class="line">         <span class="keyword">super</span>(hash, key, val, next);</div><div class="line"></div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     <span class="comment">/**</span></div><div class="line"></div><div class="line">      * 将链表转化为红黑树</div><div class="line"></div><div class="line">      */</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</div><div class="line"></div><div class="line">         TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">         <span class="comment">//遍历链表,x代表需要插入的节点</span></div><div class="line"></div><div class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</div><div class="line"></div><div class="line">             next = (TreeNode&lt;K,V&gt;)x.next;</div><div class="line"></div><div class="line">             x.left = x.right = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">             <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="comment">//树为空直接插入节点，并且节点颜色变为黑色</span></div><div class="line"></div><div class="line">                 x.parent = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                 x.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                 root = x;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                 K k = x.key;</div><div class="line"></div><div class="line">                 <span class="keyword">int</span> h = x.hash;</div><div class="line"></div><div class="line">                 Class&lt;?&gt; kc = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                 <span class="comment">//查找新节点在红黑树上的位置</span></div><div class="line"></div><div class="line">                 <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</div><div class="line"></div><div class="line">                     <span class="comment">//dir记录向左走还是向右走 ph 记录当前节点的hash值</span></div><div class="line"></div><div class="line">                     <span class="keyword">int</span> dir, ph;</div><div class="line"></div><div class="line">                     K pk = p.key;</div><div class="line"></div><div class="line"></div><div class="line">                     <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line"></div><div class="line">                         dir = -<span class="number">1</span>;</div><div class="line"></div><div class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line"></div><div class="line">                         dir = <span class="number">1</span>;</div><div class="line"></div><div class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</div><div class="line"></div><div class="line">                               (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</div><div class="line"></div><div class="line">                              (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</div><div class="line"></div><div class="line">                         <span class="comment">//哈希值相等时比较Key的大小</span></div><div class="line"></div><div class="line">                         dir = tieBreakOrder(k, pk);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                     TreeNode&lt;K,V&gt; xp = p;</div><div class="line"></div><div class="line">                     <span class="comment">//如果下一步需要到达的位置是null，就可以安放新节点</span></div><div class="line"></div><div class="line">                     <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                         x.parent = xp;</div><div class="line"></div><div class="line">                         <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</div><div class="line"></div><div class="line">                             xp.left = x;</div><div class="line"></div><div class="line">                         <span class="keyword">else</span></div><div class="line"></div><div class="line">                             xp.right = x;</div><div class="line"></div><div class="line">                         <span class="comment">//插入红黑树，并且保证红黑树的特性不被破坏</span></div><div class="line"></div><div class="line">                         root = balanceInsertion(root, x);</div><div class="line"></div><div class="line">                         <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line">         moveRootToFront(tab, root);</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line"></div><div class="line">     <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></div><div class="line"></div><div class="line">                                                 TreeNode&lt;K,V&gt; x) &#123;</div><div class="line"></div><div class="line">         x.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">         <span class="comment">//xp表示x的父节点 xpp表示x的祖父节点 xppl、xppr表示x叔叔节点</span></div><div class="line"></div><div class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</div><div class="line"></div><div class="line">             <span class="comment">//根节点直接变为黑色</span></div><div class="line">             <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</div><div class="line">                 x.red = <span class="keyword">false</span>;</div><div class="line">                 </div><div class="line">                 <span class="keyword">return</span> x;</div><div class="line">                 </div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="comment">//父亲为红色或者父节点为根节点 直接插入红色新节点</span></div><div class="line"></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                 <span class="keyword">return</span> root;</div><div class="line"></div><div class="line">             <span class="comment">//父亲节点是左节点</span></div><div class="line"></div><div class="line">             <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//父亲节点和叔叔节点是红色，则叔叔和父亲变为黑色，祖父变为红色</span></div><div class="line"></div><div class="line">                 <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</div><div class="line"></div><div class="line">                     xppr.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                     x = xpp; <span class="comment">//祖父节点作为新节点，继续平衡之路</span></div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (x == xp.right) &#123;</div><div class="line"></div><div class="line">                         root = rotateLeft(root, x = xp);</div><div class="line"></div><div class="line">                         xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                         xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                         <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                             xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                             root = rotateRight(root, xpp);</div><div class="line"></div><div class="line">                         &#125;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="keyword">else</span> &#123; <span class="comment">//父亲节点是右节点</span></div><div class="line">             <span class="comment">//父亲节点和叔叔节点是红色，则叔叔和父亲变为黑色，祖父变为红色</span></div><div class="line"></div><div class="line">                 <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</div><div class="line"></div><div class="line">                     xppl.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                     x = xpp;<span class="comment">//祖父节点作为新节点，继续平衡之路</span></div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="keyword">else</span> &#123; <span class="comment">//父亲节点和叔叔节点是红色</span></div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (x == xp.left) &#123;</div><div class="line"></div><div class="line">                         root = rotateRight(root, x = xp);</div><div class="line"></div><div class="line">                         xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                         xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                         <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                             xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                             root = rotateLeft(root, xpp);</div><div class="line"></div><div class="line">                         &#125;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashMap源码解读]]></title>
      <url>http://baobing.github.io/2016/07/25/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="关于HashMap的疑问"><a href="#关于HashMap的疑问" class="headerlink" title="关于HashMap的疑问"></a>关于HashMap的疑问</h1><ul>
<li><p>HashMap底层的数据结构，怎样解决hash碰撞。</p>
</li>
<li><p>HashMap何时扩容，扩容的过程是怎样的              </p>
</li>
<li><p>红黑树是一种怎样的数据结构</p>
<a id="more"></a>
</li>
</ul>
<h1 id="JDK8-HashMap数据结构"><a href="#JDK8-HashMap数据结构" class="headerlink" title="JDK8 HashMap数据结构"></a>JDK8 HashMap数据结构</h1><center><img src="/2016/07/25/HashMap源码解读/HashMap.png" alt="图1" title="图1"></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">       <span class="keyword">final</span> K key;</div><div class="line">       <span class="keyword">volatile</span> V val;</div><div class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</div><div class="line">      <span class="comment">//省略省略</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure>
<p>　　不难发现HashMap底层由数组、链表和红黑树三者组成。</p>
<h2 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h2><p>　　包含一个执行自身类型的引用next，显然Node类是组成链表的节点，next引用负责链接各个节点。</p>
<h2 id="table数组"><a href="#table数组" class="headerlink" title="table数组"></a>table数组</h2><p>　　Node类组成的数组，装载所有的键值对。table有以下几个特点:</p>
<ul>
<li>长度N一定为2的幂。即使指定初始长度，N一定是大于等于初始长度的2的幂（可以参考tableSizeFor函数）</li>
<li>table[i]包含的是hash&amp;(N-1)的Node节点。由于N为2的幂，hash&amp;(N-1)等价于hash%N。与运算的速度大大高于取余，这就是作者的高明之处。</li>
<li>延迟初始化，只用第一次在Map中放入元素时，才会调用这个分配空间。</li>
</ul>
<h2 id="链表和红黑树"><a href="#链表和红黑树" class="headerlink" title="链表和红黑树"></a>链表和红黑树</h2><p>　　多个元素hash&amp;(n-1)的值相同的情况称为hash碰撞。链表和红黑树这两种数据结构都是在发生hash碰撞时产生的结果。如果链表的长度大于8且table长度大于64，链表被转化为红黑树。如果红黑树的节点数量小于6，则转化为链表。 </p>
<h1 id="HashMap重要字段"><a href="#HashMap重要字段" class="headerlink" title="HashMap重要字段"></a>HashMap重要字段</h1><ul>
<li><p>Node<k,v>[] table，文章已经提到不再赘述</k,v></p>
</li>
<li><p>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4。HashMap默认初始大小为16</p>
</li>
<li><p>DEFAULT_LOAD_FACTOR = 0.75f。默认负载因子是0.75，也就是说table数组有75%非空时进行扩容。</p>
</li>
<li><p>size：记录Map中键值对个数。</p>
</li>
<li><p>threshold：记录下一次扩容的阈值。threshold = loadFactor * table.length.</p>
</li>
</ul>
<h1 id="重要的函数"><a href="#重要的函数" class="headerlink" title="重要的函数"></a>重要的函数</h1><h2 id="get操作实现函数getNode"><a href="#get操作实现函数getNode" class="headerlink" title="get操作实现函数getNode"></a>get操作实现函数getNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line"></div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line"></div><div class="line">        <span class="comment">//延迟初始化导致table可能为空</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line"></div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//hash对应table数组位置的头元素key等于查找key，直接返回头节点</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line"></div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                <span class="keyword">return</span> first;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;  </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)   <span class="comment">//头元素是一棵红黑树</span></div><div class="line"></div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line"></div><div class="line">                do &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; <span class="comment">//遍历链表直到找到hash相等 key相等的元素</span></div><div class="line"></div><div class="line">                         ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line"></div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="put操作实现函数putVal"><a href="#put操作实现函数putVal" class="headerlink" title="put操作实现函数putVal"></a>put操作实现函数putVal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"></div><div class="line">                   <span class="keyword">boolean</span> evict) &#123;</div><div class="line"></div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="comment">//第一次执行put操作时初始化table</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) </div><div class="line"></div><div class="line">            n = (tab = resize()).length;</div><div class="line"></div><div class="line">        <span class="comment">//节点填充的位置为null，直接放入新的Node节点</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;  <span class="comment">//key已经在Map中出现，直接覆盖原数字</span></div><div class="line"></div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                e = p;</div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//p是一棵红黑树</span></div><div class="line"></div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line"></div><div class="line">            <span class="keyword">else</span> &#123;               <span class="comment">//p是一个链表，将元素放置到链表末尾</span></div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">// 链表长度大于等于8，链表转化为红黑树</span></div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</div><div class="line">                            treeifyBin(tab, hash);</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    &#125;              </div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;     <span class="comment">// 相同key在链表中存在，覆盖原来节点</span></div><div class="line"></div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    p = e;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line"></div><div class="line">                V oldValue = e.value;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                    e.value = value;</div><div class="line"></div><div class="line">                afterNodeAccess(e);</div><div class="line"></div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//table数组有一个位置被占用，判断是否扩容</span></div><div class="line"></div><div class="line">        ++modCount;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line"></div><div class="line">            resize();</div><div class="line"></div><div class="line">        afterNodeInsertion(evict);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="扩容函数resize"><a href="#扩容函数resize" class="headerlink" title="扩容函数resize"></a>扩容函数resize</h2><p>1）获取新数组newTab的长度，为newTab申请空间。需要考虑容量最大边界，延迟初始化等问题。</p>
<p>2）将原数组oldTab中的节点，放入newTab中。链表和红黑树拆解问题。数组容量是2的幂，所以拆解过程很有技巧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line"></div><div class="line">        Node&lt;K,V&gt;[] oldTab = table;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldThr = threshold;  <span class="comment">//原数组阈值</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//分别记录新table容量 和 新的阈值</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line"></div><div class="line">                threshold = Integer.MAX_VALUE;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> oldTab;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line"></div><div class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line"></div><div class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// Map设置初始容量,threshold为table初始容量</span></div><div class="line"></div><div class="line">            newCap = oldThr;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line"></div><div class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line"></div><div class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">//设置初始容量时，计算新的阈值</span></div><div class="line"></div><div class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line"></div><div class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line"></div><div class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        threshold = newThr;</div><div class="line"></div><div class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line"></div><div class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line"></div><div class="line">        table = newTab;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;   <span class="comment">//遍历原始table</span></div><div class="line"></div><div class="line">                Node&lt;K,V&gt; e;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                    oldTab[j] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)    <span class="comment">// 不存在hash碰撞，只有一个节点</span></div><div class="line"></div><div class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line"></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  <span class="comment">// 红黑树</span></div><div class="line"></div><div class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line"></div><div class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    <span class="comment">//将链表分为两个链表，分割依据看下面代码</span></div><div class="line"></div><div class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; </div><div class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                        Node&lt;K,V&gt; next;</div><div class="line"></div><div class="line">                        do &#123;</div><div class="line"></div><div class="line">                            next = e.next;</div><div class="line">                            </div><div class="line"></div><div class="line"><span class="comment">/* table的capcity一定是2的幂。e.hash &amp; oldCap 结果 r只可能等于0或者oldCap</span></div><div class="line"> e.hash &amp; oldCap == 0 时，e.hash &amp; (oldCap-1) == e.hash &amp; (newCap-1)</div><div class="line">e.hash &amp; oldCap == oldCap 时,e.hash &amp; (oldCap-1)+oldCap ==e.hash&amp;(newCap-1)*/</div><div class="line"></div><div class="line"></div><div class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; </div><div class="line"></div><div class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                                    loHead = e;</div><div class="line"></div><div class="line">                                <span class="keyword">else</span></div><div class="line"></div><div class="line">                                    loTail.next = e;</div><div class="line"></div><div class="line">                                loTail = e;</div><div class="line"></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                                    hiHead = e;</div><div class="line"></div><div class="line">                                <span class="keyword">else</span></div><div class="line"></div><div class="line">                                    hiTail.next = e;</div><div class="line"></div><div class="line">                                hiTail = e;</div><div class="line"></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                            loTail.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                            newTab[j] = loHead;</div><div class="line"></div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                            hiTail.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                            newTab[j + oldCap] = hiHead;</div><div class="line"></div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> newTab;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组中第k大的数字]]></title>
      <url>http://baobing.github.io/2016/07/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>从给定长度的整数数组中，选取第K大的数字。要求时间复杂度为O(N).<br><a id="more"></a></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>1）需要查找的数组a，选取其中一个数字a<a href="start&lt;=i&lt;=end">i</a>作为Key<br>2) 小于Key的数字放在Key左侧<br>3）大于等于Key的数字放在Key右侧<br>4）如果Key的下标keyIndex等于K，返回Key；<br>5）如果keyIndex 小于K，end = keyIndex - 1，重复1）<br>6）如果keyIndex 大于K，start = keyIndex + 1，重复1）</p>
<p>　　这种求解方法是快速排序的思路演化而来。<br>　　个人想到的一个将元素依据大小放置在Key左右的方法。<br>　　使用两个辅助数组，一个保存大于Key的元素，一个保存小于Key的元素。将小于Key的元素放置在头部，将小于Key的元素放于尾部。将剩余的空间放置Key。<br>　　优点：可以得到于Key相同的所有元素，对于相同元素多的数组可以加快速度<br>　　缺点：耗时，需要辅助空间</p>
<h1 id="衍生问题"><a href="#衍生问题" class="headerlink" title="衍生问题"></a>衍生问题</h1><ul>
<li>给定整数数组中，求前K大的所有数字</li>
<li>给定整数数组中，某个的数字出现次数超过数组长度一半，找到这个数字。</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> acm;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by hubaobin on 16/7/24.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kth</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> start 开始的下标</div><div class="line">     * <span class="doctag">@param</span> end 结束的下标</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> first = start;</div><div class="line">        <span class="keyword">int</span> last = end;</div><div class="line">        <span class="comment">//选取第一个数字作为key,建议还是随机选取避免选取数字过小或者过大</span></div><div class="line">        <span class="keyword">int</span> key = a[first];</div><div class="line">        <span class="comment">//将小于key的值放在key左侧,大于等于key的值放在右侧</span></div><div class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</div><div class="line">            <span class="comment">//一定要先从后到前扫描</span></div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; a[last] &gt;= key) last--;</div><div class="line">            a[first] = a[last];</div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; a[first] &lt;= key) first++;</div><div class="line">            a[last] = a[first];</div><div class="line">        &#125;</div><div class="line">        a[first] = key;</div><div class="line">        <span class="keyword">if</span> (first == k) <span class="keyword">return</span> a[first];</div><div class="line">        <span class="keyword">if</span> (first &gt; k) <span class="keyword">return</span> getKth(a, k, start, first - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> getKth(a, k, first + <span class="number">1</span>, end);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>&#125;;</div><div class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> k;</div><div class="line">        <span class="keyword">while</span> ((k = scanner.nextInt()) != -<span class="number">1</span>) &#123;</div><div class="line">            System.out.println(getKth(a, k - <span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快速幂原理解析]]></title>
      <url>http://baobing.github.io/2016/07/22/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>求n的m次方，时间复杂度O(log(N)).不考虑大数情况。<br><a id="more"></a></p>
<h1 id="解决方法：快速幂"><a href="#解决方法：快速幂" class="headerlink" title="解决方法：快速幂"></a>解决方法：快速幂</h1><h2 id="求解方法和步骤"><a href="#求解方法和步骤" class="headerlink" title="求解方法和步骤"></a>求解方法和步骤</h2><p>1）假设n=3,m=10</p>
<p>2）将m转化为二进制为t=1010,数组形式为a={1,0,1,0}，a[i]表示m的第i位上的二进制数组。</p>
<p>3）f[i]表示m的前i个二进制数字的十进制形式。我们可以得到<strong><em> f[i+1] = (f[i]+a[i] )</em>2 *</strong> ，如：10 =((((1+0)<em>2+1)</em>2+0)<em>2+1)</em>2 。</p>
<p>4）2^3^4 = (2^3)^4 ，2^(1+2) = 2^2<em>2 ,由上面两条定理可以推得 g[i+1] = (g[i] </em>(n^a[i]))^2 。</p>
<p>其中g[i]表示 n^f[i]。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">package</span> acm;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/22.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickPower</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPower</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不能同时为0"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((m &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">                result *= n;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            result *= result;</div><div class="line"></div><div class="line">            m &gt;&gt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        System.out.println(getPower(<span class="number">2</span>, <span class="number">10</span>));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快排、递归、堆和基数四种排序方法]]></title>
      <url>http://baobing.github.io/2016/07/19/%E5%9B%9B%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>接下来文章将会讲述四种排序算法的实现和可行性证明。<strong><em>只有证明一个算法的正确性，才算理解一种算法。</em></strong><br><a id="more"></a></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1)从需要排序的数组选中一个作为Key，比Key小的放在右边，比Key大的放在左边。</p>
<p>2 )Key右侧的元素重复步骤1)</p>
<p>3)Key右侧的元素重复步骤1)</p>
<p>观察源码即可找到实现步骤一效果的方法。</p>
<h2 id="可行性证明"><a href="#可行性证明" class="headerlink" title="可行性证明"></a>可行性证明</h2><p>题设</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1)每次排序选中Key的左侧小于等于Key </div><div class="line"></div><div class="line">2)每次排序选中Key的右侧大于等于Key</div><div class="line"></div><div class="line">3)需要排序数组长度为2或3时，数据一定是升序</div></pre></td></tr></table></figure>
<p>假设数组为 a[] ，Key的下标为k，数组范围为0-n。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1)当 0&lt;=i&lt;k 时，a[i] &lt;=a[k] &amp;&amp; a[i]&lt;= a[i+1].</div><div class="line"></div><div class="line">2)当 k&lt;j&lt;=n 时，a[j] &gt;=a[k] &amp;&amp; a[j]&gt;= a[j-1].</div><div class="line"></div><div class="line">3)结合1)、2)可以推导出：当 0&lt;=l&lt;n , a[i]&lt;a[i+1]，即排序结果有序</div></pre></td></tr></table></figure>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><ul>
<li><p>优点:空间复杂度为 O(N) </p>
</li>
<li><p>缺点:时间复杂度O(Nlog(N))，但是不稳定。Key的选择很关键，选不好复杂度就会变为N的平方。</p>
</li>
<li><p>优化方法：选择数组头部中间尾部，三个元素中间值作为Key。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by baobing on 16/7/15.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        sort(<span class="number">0</span>, list.length-<span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> key = list[low];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> first = low;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> last = high;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//一定要从后往前先</span></div><div class="line"></div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; list[last] &gt;= key) &#123;</div><div class="line"></div><div class="line">                last--;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            list[first] = list[last];</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; list[first] &lt;= key) &#123;</div><div class="line"></div><div class="line">                first++;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            list[last] = list[first];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        list[first] = key;</div><div class="line"></div><div class="line">        sort(low, first - <span class="number">1</span>);</div><div class="line"></div><div class="line">        sort(first + <span class="number">1</span>, high);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        QuickSort q = <span class="keyword">new</span> QuickSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>1）将数组分为两个大小相同的数组（有可能大小相差1），继续分割数组，直到数组大小为1.</p>
<p>2）现在从同一个数组分割来的两个数组都为升序，将两个数组合并为一个升序的数组。</p>
<p>3）重复步骤 2）直到整个数组被合并</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>典型的分治算法。通过子序列的有序性，保证自身的有序性。</p>
<h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><ul>
<li><p>优点：时间复杂度为O(Nlog(N)) 并且极其稳定</p>
</li>
<li><p>缺点：空间复杂度为O(2N)),比较节省空间的场合不适用，尤其是比较大的数组</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/16.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span>[] list;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 合并两个有序的数组</div><div class="line"></div><div class="line">     * 第一个数组的起始下标为low 终止下标为mid</div><div class="line"></div><div class="line">     * 第二个数组的起始下标为mid+1 终止下标为high</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//用于保存两个数组合并结果</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="comment">//第一个数组的始末下标</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> first1 = low, end1 = mid;</div><div class="line"></div><div class="line">        <span class="comment">//第二个数组的始末下标</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> first2 = mid + <span class="number">1</span>, end2 = high;</div><div class="line"></div><div class="line">        <span class="comment">//记录临时数组的下标</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first1 &lt;= end1 &amp;&amp; first2 &lt;= end2) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (list[first1] &lt; list[first2]) &#123;</div><div class="line"></div><div class="line">                temp[k++] = list[first1++];</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                temp[k++] = list[first2++];</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//第一个数组的剩余元素放入临时数组</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first1 &lt;= end1) &#123;</div><div class="line"></div><div class="line">            temp[k++] = list[first1++];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//第二个数组的剩余元素放入临时数组</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first2 &lt;= end2) &#123;</div><div class="line"></div><div class="line">            temp[k++] = list[first2++];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//排序好的临时数组覆盖原数组</span></div><div class="line"></div><div class="line">        System.arraycopy(temp, <span class="number">0</span>, list, low, temp.length);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 排序数组</div><div class="line"></div><div class="line">     *</div><div class="line"></div><div class="line">     * <span class="doctag">@param</span> low  起始下标</div><div class="line"></div><div class="line">     * <span class="doctag">@param</span> high 末尾下标</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">        sort(low, mid);</div><div class="line"></div><div class="line">        sort(mid + <span class="number">1</span>, high);</div><div class="line"></div><div class="line">        merge(low, mid, high);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        sort(<span class="number">0</span>, list.length - <span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        MergeSort q = <span class="keyword">new</span> MergeSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>最大堆：完全二叉树，所有根节点的子节点小于等于本身</li>
</ul>
<p>1）N个节点的树，构建为最大堆。</p>
<p>2）根节点与树最后一个叶子节点交换。</p>
<p>3）除去尾部的交换节点之后的树，构造为最大堆</p>
<p>4）重负步骤2）</p>
<h2 id="优点缺点-1"><a href="#优点缺点-1" class="headerlink" title="优点缺点"></a>优点缺点</h2><ul>
<li><p>优点 复杂度O(Nlog(N)) 空间复杂度为O(N)</p>
</li>
<li><p>缺点 构建最大堆浪费不少时间</p>
</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/16.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        buildMaxHeapify();</div><div class="line"></div><div class="line">        <span class="comment">//末尾与头交换，交换后调整最大堆</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line"></div><div class="line">            swap(<span class="number">0</span>, i);</div><div class="line"></div><div class="line">            maxHeapify(i, <span class="number">0</span>);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeapify</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//没有子节点的才需要创建最大堆，从最后一个的父节点开始</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> startIndex = getParentIndex(list.length - <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">//从尾端开始创建最大堆，每次都是正确的堆</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line"></div><div class="line">            maxHeapify(list.length, i);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 创建最大堆</div><div class="line"></div><div class="line">     *</div><div class="line"></div><div class="line">     * <span class="doctag">@paramheapSize</span>需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了</div><div class="line"></div><div class="line">     * <span class="doctag">@paramindex</span>当前需要创建最大堆的位置</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//当前点与左右子节点比较</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = getChildLeftIndex(index);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> right = getChildRightIndex(index);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">int</span> largest = index;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; list[index] &lt; list[left]) &#123;</div><div class="line"></div><div class="line">            largest = left;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; list[largest] &lt; list[right]) &#123;</div><div class="line"></div><div class="line">            largest = right;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (largest != index) &#123;</div><div class="line"></div><div class="line">            swap(index, largest);</div><div class="line"></div><div class="line">            maxHeapify(heapSize, largest);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> temp = list[a];</div><div class="line"></div><div class="line">        list[a] = list[b];</div><div class="line"></div><div class="line">        list[b] = temp;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 父节点位置</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 左子节点position注意括号，加法优先级更高</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildLeftIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 右子节点position</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildRightIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        HeapSort q = <span class="keyword">new</span> HeapSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h2><p>1）将需要排序的数组list中的数字根据他们的个位数字i放到对应的数组bucket[i]的末尾。</p>
<p>2）从0-9依次将bucket中的数字放置到需要排序的数组list。</p>
<p>3）接下来是十位、百位，重复类似步骤1），指导数组list中的所有元素该位置都没有数字。</p>
<h2 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：</p>
<ul>
<li><p>时间复杂度低O(Mlog(N)).（N为排序数字个数M为最大位）对于N大M小的情况尤为突出。</p>
</li>
<li><p>可以实现相同大小的数字，依旧保持先后顺序</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>辅助空间需求要求比较大</p>
</li>
<li><p>M大N小时，性能下降</p>
</li>
<li><p>试用的排序类型比较少，整数最适合</p>
</li>
</ul>
<p>缺点</p>
<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/17.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> list[];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> <span class="comment">//d表示最大的数有多少位</span></span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">//bucket[i]用来装载需要排序的位等于i的数字</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][list.length];</div><div class="line"></div><div class="line">        <span class="comment">//idxArr[i] 表示bucket[i]填充数据个数</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] idxArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) idxArr[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> isContinue = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">//将数组放入bucket</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> divRes = list[i] / n;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (divRes &gt;= <span class="number">10</span>) isContinue = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> lsd = (divRes % <span class="number">10</span>);</div><div class="line"></div><div class="line">                bucket[lsd][idxArr[lsd]++] = list[i];</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//bucket中的数字放回原数组</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; idxArr[i]; j++) &#123;</div><div class="line"></div><div class="line">                    list[k++] = bucket[i][j];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                idxArr[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!isContinue) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            n *= <span class="number">10</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        RadixSort q = <span class="keyword">new</span> RadixSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
