<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ConcurrentHashMap源码解析]]></title>
      <url>http://baobing.github.io/2016/07/25/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>　　 JDK1.8中，ConcurrentHashMap的源码竟然有6300行,作者是大名鼎鼎Doug Lea（感谢开源让我离大神可以这么近，不过代码风格明显没打算交给他人维护）。本文只讲述扩容相关的内容，其他操作就放弃了。文章参考一下别人的文章，主要是以下两篇文章：<br>　　 <a id="more"></a></p>
<blockquote>
<p><a href="http://blog.csdn.net/u010887744/article/details/51002358" target="_blank" rel="external">http://blog.csdn.net/u010887744/article/details/51002358</a><br><a href="http://www.cnblogs.com/huaizuo/p/5413069.html" target="_blank" rel="external">http://www.cnblogs.com/huaizuo/p/5413069.html</a><br>　　友情提示：看ConcurrentHashMap源码还是需要一些Java并发编程的了解，比如内存可见性、原子性、顺序性、无锁。另一点就是先阅读HashMap的源码。</p>
<h1 id="JDK8-HashMap数据结构"><a href="#JDK8-HashMap数据结构" class="headerlink" title="JDK8 HashMap数据结构"></a>JDK8 HashMap数据结构</h1></blockquote>
<p><center></center></p>
<p><center>图1</center><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;</div><div class="line">        final K key;</div><div class="line">        volatile V val;</div><div class="line">        volatile Node&lt;K,V&gt; next;</div><div class="line">       //省略省略</div><div class="line">&#125;</div><div class="line"> transient volatile Node&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure></p>
<p>　　HashMap底层由数组、链表和红黑树三者组成。我们从图1和源码大改也可以推断出来。首先是HashMap使用Node组成的数组table装载所有的键值对，再者HashMap发生Hash值碰撞使用链表将它们连起来，最后是某个链表长度大于指定值链表转化为红黑树。   </p>
<h1 id="重要的常量"><a href="#重要的常量" class="headerlink" title="重要的常量"></a>重要的常量</h1><h2 id="基本常量"><a href="#基本常量" class="headerlink" title="基本常量"></a>基本常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> transient volatile Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line"> //扩容时使用，其他时候为null</div><div class="line"> private transient volatile Node&lt;K,V&gt;[] nextTable;</div><div class="line"></div><div class="line"> //基础计数器，主要用于无争用，同时也作为table数组初始化的回退记录</div><div class="line"> private transient volatile long baseCount;</div><div class="line"></div><div class="line"> //table数组初始化和扩容的控制标志。为负数时，table数组正在扩容或初始化，</div><div class="line"> //-1代表初始化，其他负数表示 -（1+参数扩容的线程数量）。当table为null时，</div><div class="line"> //sizeCtl持有扩容的阈值，0为默认值。</div><div class="line"> private transient volatile int sizeCtl;</div><div class="line"></div><div class="line">//table扩容时 每个线程最少需要处理的元素数量。看不懂就跳过去，下同</div><div class="line"> private static final int MIN_TRANSFER_STRIDE = 16;</div><div class="line"></div><div class="line"> //当table扩容时，transferIndex持有下一个线程或者下次循环可以处理的数组界限</div><div class="line"> private transient volatile int transferIndex;</div><div class="line"></div><div class="line"> //table数组的默认长度</div><div class="line"> private static final int DEFAULT_CAPACITY = 16;</div><div class="line"></div><div class="line"> //table数组的负载因子. 小数形式不经常使用，它更常见的表示形式是 n - (n &gt;&gt;&gt; 2)</div><div class="line"> private static final float LOAD_FACTOR = 0.75f;</div></pre></td></tr></table></figure>
<h2 id="Unsafe相关常量"><a href="#Unsafe相关常量" class="headerlink" title="Unsafe相关常量"></a>Unsafe相关常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// Unsafe mechanics</div><div class="line">    private static final sun.misc.Unsafe U;</div><div class="line">    private static final long SIZECTL; //sizeCtl的偏移量</div><div class="line">    private static final long TRANSFERINDEX; //transferIndex的偏移量</div><div class="line">    private static final long BASECOUNT;   //</div><div class="line">    private static final long CELLSBUSY;</div><div class="line">    private static final long CELLVALUE;</div><div class="line">    //数组中第一个元素在数组中的位置</div><div class="line">    private static final long ABASE;</div><div class="line">     //Node数组元素大小scale的二进制去除前导零后的位数</div><div class="line">    private static final int ASHIFT;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        try &#123;</div><div class="line">            U = sun.misc.Unsafe.getUnsafe();</div><div class="line">            Class&lt;?&gt; k = ConcurrentHashMap.class;</div><div class="line">    ﻿    ﻿  //获取sizeCtl的偏移量</div><div class="line">            SIZECTL = U.objectFieldOffset(k.getDeclaredField(&quot;sizeCtl&quot;)); </div><div class="line">    ﻿    ﻿  //省略代码，和上面一样获取各个变量的偏移量</div><div class="line">             ...</div><div class="line">            Class&lt;?&gt; ak = Node[].class;</div><div class="line">            //Arrays和Java别的对象一样，都有一个对象头，它是存储在实际的数据前面的。</div><div class="line">            //这个头的长度可以通过unsafe.arrayBaseOffset(T[].class) 方法来获取到，</div><div class="line">    ﻿    ﻿    ﻿ //这里T是数组元素的类型</div><div class="line">            ABASE = U.arrayBaseOffset(ak); </div><div class="line">            int scale = U.arrayIndexScale(ak); //获取数组元素的大小</div><div class="line">            if ((scale &amp; (scale - 1)) != 0) //元素大小必须是2的倍数，不知道为什么</div><div class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</div><div class="line">            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw new Error(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h1><h2 id="无锁方法"><a href="#无锁方法" class="headerlink" title="无锁方法"></a>无锁方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    //内存中直接获取tab数组张第i个元素，保证内存可见性</div><div class="line">      static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</div><div class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">    &#125;</div><div class="line">   //为tab数组的第i个元素复制，使用CAS，保证操作的原子性</div><div class="line"></div><div class="line">    static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">    &#125;</div><div class="line">   static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</div><div class="line">/**设置obj对象中offset偏移地址对应的object型field的值为指定值。这是一个有序或者</div><div class="line"> 有延迟的putObjectVolatile方法，并且不保证值的改变被其他线程立</div><div class="line"> 即看到。只有在field被&lt;code&gt;volatile&lt;/code&gt;修饰并且期望被意外修改的时候</div><div class="line">  使用才有用。*/</div><div class="line">        U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="扩容方法transfer"><a href="#扩容方法transfer" class="headerlink" title="扩容方法transfer"></a>扩容方法transfer</h2><h3 id="扩容过程解析"><a href="#扩容过程解析" class="headerlink" title="扩容过程解析"></a>扩容过程解析</h3><p>　　ConcurrentHashMap无锁多线程扩容，减少扩容时的时间消耗。单线程构建两倍容量的nextTable；允许多线程复制原table元素到nextTable。为每个内核均分任务，并保证其不小于16（常量MIN_TRANSFER_STRIDE）。<br>1）若nextTab为null，则初始化其为原table的2倍；<br>2）死循环遍历，直到finishing。</p>
<ul>
<li>节点为空，则插入ForwardingNode；</li>
<li>链表节点（fh&gt;=0），分别插入nextTable的i和i+n的位置；</li>
<li>TreeBin节点（fh&lt;0），判断是否需要untreefi，分别插入nextTable的i和i+n的位置；</li>
<li>finishing时，nextTab赋给table，更新sizeCtl为新容量的0.75倍 ，完成扩容。<br>以上说的都是单线程，多线程又是如何实现的呢？<pre><code>遍历到ForwardingNode节点((fh = f.hash) == MOVED)，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心 。由于给节点上了锁，只允许当前线程完成此节点的操作，处理完毕后，将对应值设为ForwardingNode（fwd），其他线程看到forward，直接向后遍历。如此便完成了多线程的复制工作，也解决了线程安全问题。
</code></pre></li>
</ul>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Moves and/or copies the nodes in each bin to new table. See</div><div class="line"> * above for explanation.</div><div class="line"> */</div><div class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class="line">    //n表示原数组的大小 ,stride表示每个线程或者单次循环负责节点的个数 </div><div class="line">    int n = tab.length, stride;</div><div class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</div><div class="line">    if (nextTab == null) &#123;            // 为nextTable申请空间</div><div class="line">        try &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</div><div class="line">            nextTab = nt;</div><div class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</div><div class="line">            sizeCtl = Integer.MAX_VALUE;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        nextTable = nextTab;</div><div class="line">        transferIndex = n;</div><div class="line">    &#125;</div><div class="line">    int nextn = nextTab.length;</div><div class="line">    //构建一个连节点的指针，用于标识位</div><div class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">    boolean advance = true;</div><div class="line">    //循环的关键变量，判断是否已经扩容完成</div><div class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</div><div class="line">    //i--操作保证了倒序遍历数组，bound表示新的线程或者单次循环的下边界</div><div class="line">    for (int i = 0, bound = 0;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int fh;</div><div class="line">      </div><div class="line">        while (advance) &#123;</div><div class="line">            int nextIndex, nextBound;</div><div class="line">            if (--i &gt;= bound || finishing) //循环没有到达下边界可以继续for循环</div><div class="line">                advance = false;</div><div class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123; //整个for循环过程结束</div><div class="line">                i = -1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">    ﻿    ﻿   //只有通过CAS成功更新ransferIndex才能获取到扩容的资格</div><div class="line">            else if (U.compareAndSwapInt  </div><div class="line">                     (this, TRANSFERINDEX, nextIndex,</div><div class="line">                      nextBound = (nextIndex &gt; stride ?</div><div class="line">                                   nextIndex - stride : 0))) &#123;</div><div class="line">                bound = nextBound;</div><div class="line">                i = nextIndex - 1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //i&lt;0说明已经遍历完旧的数组tab；i&gt;=n什么时候有可能呢？</div><div class="line">    ﻿   //在下面看到i=n,所以目前i最大应该是n吧,导致的原因可能是多线程</div><div class="line">        //i+n&gt;=nextn,nextn=nextTab.length，所以如果满足i+n&gt;=nextn说明已经扩容完成</div><div class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; </div><div class="line">            int sc;</div><div class="line">            if (finishing) &#123;//a</div><div class="line">                nextTable = null;</div><div class="line">                table = nextTab;</div><div class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            //利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，</div><div class="line">    ﻿    ﻿   //说明新加入一个线程参与到扩容操作,参考sizeCtl的注释</div><div class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class="line">                //如果有多个线程进行扩容，那么这个值在第二个线程以后就不会相等，</div><div class="line">    ﻿    ﻿      ﻿//因为sizeCtl已经被减1了，所以后面的线程就只能直接返回,</div><div class="line">    ﻿    ﻿    ﻿  //始终保证只有一个线程执行了 a(上面注释a)</div><div class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class="line">                    return;</div><div class="line">    ﻿    ﻿    ﻿//finishing和advance保证线程已经扩容完成了可以退出循环</div><div class="line">                finishing = advance = true;</div><div class="line">                i = n; // recheck before commit</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ﻿   //如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了</div><div class="line">        else if ((f = tabAt(tab, i)) == null)</div><div class="line">            advance = casTabAt(tab, i, null, fwd);</div><div class="line">    ﻿    //那么如果f.hash=-1的话说明该节点为ForwardingNode，说明该节点已经处理过了</div><div class="line">        else if ((fh = f.hash) == MOVED)</div><div class="line">            advance = true; // already processed</div><div class="line">        else &#123;</div><div class="line">            synchronized (f) &#123;</div><div class="line">                if (tabAt(tab, i) == f) &#123;</div><div class="line">                    Node&lt;K,V&gt; ln, hn;</div><div class="line">                    if (fh &gt;= 0) &#123;</div><div class="line">                        int runBit = fh &amp; n;</div><div class="line">                        Node&lt;K,V&gt; lastRun = f;</div><div class="line">                        //把链表分表拆分为，hash&amp;n等于0和不等于0的，</div><div class="line">    ﻿    ﻿    ﻿    ﻿    //然后分别放在新表的i和i+n位置。n一定是2的幂，这个很重要</div><div class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</div><div class="line">                            int b = p.hash &amp; n;</div><div class="line">                            if (b != runBit) &#123;</div><div class="line">                                runBit = b;</div><div class="line">                                lastRun = p;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        if (runBit == 0) &#123;</div><div class="line">                            ln = lastRun;</div><div class="line">                            hn = null;</div><div class="line">                        &#125;</div><div class="line">                        else &#123;</div><div class="line">                            hn = lastRun;</div><div class="line">                            ln = null;</div><div class="line">                        &#125;</div><div class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                            if ((ph &amp; n) == 0)</div><div class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                            else</div><div class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                        &#125;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        //把已经替换的节点的旧tab的i的位置用fwd替换，fwd包含nextTab</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;//下面红黑树基本和链表差不多</div><div class="line">                    else if (f instanceof TreeBin) &#123;</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</div><div class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</div><div class="line">                        int lc = 0, hc = 0;</div><div class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</div><div class="line">                            int h = e.hash;</div><div class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div class="line">                                (h, e.key, e.val, null, null);</div><div class="line">                            if ((h &amp; n) == 0) &#123;</div><div class="line">                                if ((p.prev = loTail) == null)</div><div class="line">                                    lo = p;</div><div class="line">                                else</div><div class="line">                                    loTail.next = p;</div><div class="line">                                loTail = p;</div><div class="line">                                ++lc;</div><div class="line">                            &#125;</div><div class="line">                            else &#123;</div><div class="line">                                if ((p.prev = hiTail) == null)</div><div class="line">                                    hi = p;</div><div class="line">                                else</div><div class="line">                                    hiTail.next = p;</div><div class="line">                                hiTail = p;</div><div class="line">                                ++hc;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        //判断扩容后是否还需要红黑树结构</div><div class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</div><div class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[红黑树和HashMap中实现]]></title>
      <url>http://baobing.github.io/2016/07/25/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%A5%E5%8F%8AHashMap/</url>
      <content type="html"><![CDATA[<p>　　本人最近在看JDK的HashMap源码，在JDK1.8中引入红黑树。引入红黑树的原因是加快hash碰撞较多情景下的查找速度。网上找到下面这篇文章感觉写的非常好，思路清晰。我会在原文章基础上做一点批注，方便日后阅读。<br>　　<a id="more"></a></p>
<blockquote>
<p><a href="http://blog.csdn.net/eric491179912/article/details/6179908" target="_blank" rel="external">http://blog.csdn.net/eric491179912/article/details/6179908</a></p>
</blockquote>
<h1 id="红黑树的基本特性"><a href="#红黑树的基本特性" class="headerlink" title="红黑树的基本特性"></a>红黑树的基本特性</h1><p>　　一定要牢记这五条特性，推导全靠这几条原则。 </p>
<ol>
<li><p>节点是红色或黑色。</p>
</li>
<li><p>根节点是黑色。</p>
</li>
<li><p>每个叶节点（NIL节点，空节点）是黑色的。<strong><em>这个限制根本没有用啊，亲 - -！</em></strong></p>
</li>
<li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
</li>
<li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
</li>
</ol>
<h1 id="红黑树上结点的插入"><a href="#红黑树上结点的插入" class="headerlink" title="红黑树上结点的插入"></a>红黑树上结点的插入</h1><p>　　<strong><em>任何一个即将插入的新结点的初始颜色都为红色。</em></strong>这一点很容易理解，因为插入黑点会增加某条路径上黑结点的数目，从而导致整棵树黑高度的不平衡。但如果新结点父结点为红色时（如图1所示），将会违返红黑树性质：一条路径上不能出现相邻的两个红色结点。这时就需要通过一系列操作来使红黑树保持平衡。</p>
<center><img src="/2016/07/25/红黑树以及HashMap/insert1.jpg" alt="图1" title="图1"></center>

<p>　　为了清楚地表示插入操作以下在结点中使用“新”字表示一个新插入的结点；使用“父”字表示新插入点的父结点；使用“叔”字表示“父”结点的兄弟结点；使用“祖”字表示“父”结点的父结点。插入操作分为以下几种情况：</p>
<h2 id="该树为空树。"><a href="#该树为空树。" class="headerlink" title="该树为空树。"></a>该树为空树。</h2><p>直接插入根结点的位置，违反性质2，把节点颜色有红改为黑即可。</p>
<h2 id="黑父"><a href="#黑父" class="headerlink" title="黑父"></a>黑父</h2><p>　　如图2所示，如果新点的父结点为黑色结点，那么插入一个红点将不会影响红黑树的平衡，此时插入操作完成。红黑树比AVL树优秀的地方之一在于黑父的情况比较常见，从而使红黑树需要旋转的几率相对AVL树来说会少一些。</p>
<center><img src="/2016/07/25/红黑树以及HashMap/insert2.jpg" alt="图2" title="图2"></center>


<h2 id="红父"><a href="#红父" class="headerlink" title="红父"></a>红父</h2><p>　　如图3所示，由于父结点为红色，此时可以判定，祖父结点必定为黑色。这时需要根据叔父结点的颜色来决定做什么样的操作。青色结点表示颜色未知。由于有可能需要根结点到新点的路径上进行多次旋转操作，而每次进行不平衡判断的起始点（<strong><em>我们可将其视为新点</em></strong>）都不一样。所以我们在此使用一个蓝色箭头指向这个起始点，并称之为判定点。<br>　　注：把一个树看成一个新的节点，继续进行旋转。这点很重要。</p>
<center><img src="/2016/07/25/红黑树以及HashMap/insert3.jpg" alt="insert3.jpg" title=""></center>


<h3 id="红叔"><a href="#红叔" class="headerlink" title="红叔"></a>红叔</h3><p>　　当叔父结点为红色时，如图4所示，无需进行旋转操作，只要将父和叔结点变为黑色，将祖父结点变为红色即可。但由于祖父结点的父结点有可能为红色，从而违反红黑树性质。此时必须将祖父结点作为新的判定点继续向上进行平衡操作。需要注意，无论“父”在“叔”的左边还是右边，无论“新”是“父”的左孩子还是右孩子，它们的操作都完全一样。</p>
<p><center><img src="/2016/07/25/红黑树以及HashMap/insert4.jpg" alt="insert4.jpg" title=""></center><br>　　注：如果祖父节点是根节点怎么办？答案是进行情景一的操作，把祖父节点变为黑色。</p>
<h3 id="黑叔"><a href="#黑叔" class="headerlink" title="黑叔"></a>黑叔</h3><p>情形1：<br><img src="/2016/07/25/红黑树以及HashMap/insert5.jpg" alt="insert5.jpg" title=""></p>
<p>情形2：<br><img src="/2016/07/25/红黑树以及HashMap/insert6.jpg" alt="insert6.jpg" title=""></p>
<p>情形3：</p>
<img src="/2016/07/25/红黑树以及HashMap/insert7.jpg" alt="insert7.jpg" title="">
<p>情形4：</p>
<img src="/2016/07/25/红黑树以及HashMap/insert8.jpg" alt="insert8.jpg" title="">
<p>　　可以观察到，当旋转完成后，新的旋转根全部为黑色，此时不需要再向上回溯进行平衡操作，插入操作完成。需要注意，上面四张图的“叔”、“1”、“2”、“3”结点有可能为黑哨兵结点。<br>　　其实红黑树的插入操作不是很难，甚至比AVL树的插入操作还更简单些。但删除操作就远远比AVL树复杂得多，下面就介绍红黑树的删除操作。
　　</p>
<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><p>主要讲解红黑树的平衡插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//LinkedHashMap.Entry&lt;K,V&gt;继承自HashMap.Node&lt;K,V&gt; </span></div><div class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; parent;<span class="comment">//parent阴阳记录父亲节点</span></div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; left;<span class="comment">//left、right其中一个记录叔叔节点</span></div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; right;</div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; prev;  <span class="comment">// needed to unlink next upon deletion</span></div><div class="line"></div><div class="line">     <span class="keyword">boolean</span> red; <span class="comment">//记录节点的颜色</span></div><div class="line"></div><div class="line">     TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</div><div class="line"></div><div class="line">         <span class="keyword">super</span>(hash, key, val, next);</div><div class="line"></div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     <span class="comment">/**</span></div><div class="line"></div><div class="line">      * 将链表转化为红黑树</div><div class="line"></div><div class="line">      */</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</div><div class="line"></div><div class="line">         TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">         <span class="comment">//遍历链表,x代表需要插入的节点</span></div><div class="line"></div><div class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</div><div class="line"></div><div class="line">             next = (TreeNode&lt;K,V&gt;)x.next;</div><div class="line"></div><div class="line">             x.left = x.right = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">             <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="comment">//树为空直接插入节点，并且节点颜色变为黑色</span></div><div class="line"></div><div class="line">                 x.parent = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                 x.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                 root = x;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                 K k = x.key;</div><div class="line"></div><div class="line">                 <span class="keyword">int</span> h = x.hash;</div><div class="line"></div><div class="line">                 Class&lt;?&gt; kc = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                 <span class="comment">//查找新节点在红黑树上的位置</span></div><div class="line"></div><div class="line">                 <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</div><div class="line"></div><div class="line">                     <span class="comment">//dir记录向左走还是向右走 ph 记录当前节点的hash值</span></div><div class="line"></div><div class="line">                     <span class="keyword">int</span> dir, ph;</div><div class="line"></div><div class="line">                     K pk = p.key;</div><div class="line"></div><div class="line"></div><div class="line">                     <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line"></div><div class="line">                         dir = -<span class="number">1</span>;</div><div class="line"></div><div class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line"></div><div class="line">                         dir = <span class="number">1</span>;</div><div class="line"></div><div class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</div><div class="line"></div><div class="line">                               (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</div><div class="line"></div><div class="line">                              (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</div><div class="line"></div><div class="line">                         <span class="comment">//哈希值相等时比较Key的大小</span></div><div class="line"></div><div class="line">                         dir = tieBreakOrder(k, pk);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                     TreeNode&lt;K,V&gt; xp = p;</div><div class="line"></div><div class="line">                     <span class="comment">//如果下一步需要到达的位置是null，就可以安放新节点</span></div><div class="line"></div><div class="line">                     <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                         x.parent = xp;</div><div class="line"></div><div class="line">                         <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</div><div class="line"></div><div class="line">                             xp.left = x;</div><div class="line"></div><div class="line">                         <span class="keyword">else</span></div><div class="line"></div><div class="line">                             xp.right = x;</div><div class="line"></div><div class="line">                         <span class="comment">//插入红黑树，并且保证红黑树的特性不被破坏</span></div><div class="line"></div><div class="line">                         root = balanceInsertion(root, x);</div><div class="line"></div><div class="line">                         <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line">         moveRootToFront(tab, root);</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line"></div><div class="line">     <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></div><div class="line"></div><div class="line">                                                 TreeNode&lt;K,V&gt; x) &#123;</div><div class="line"></div><div class="line">         x.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">         <span class="comment">//xp表示x的父节点 xpp表示x的祖父节点 xppl、xppr表示x叔叔节点</span></div><div class="line"></div><div class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</div><div class="line"></div><div class="line">             <span class="comment">//根节点直接变为黑色</span></div><div class="line">             <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</div><div class="line">                 x.red = <span class="keyword">false</span>;</div><div class="line">                 </div><div class="line">                 <span class="keyword">return</span> x;</div><div class="line">                 </div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="comment">//父亲为红色或者父节点为根节点 直接插入红色新节点</span></div><div class="line"></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                 <span class="keyword">return</span> root;</div><div class="line"></div><div class="line">             <span class="comment">//父亲节点是左节点</span></div><div class="line"></div><div class="line">             <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//父亲节点和叔叔节点是红色，则叔叔和父亲变为黑色，祖父变为红色</span></div><div class="line"></div><div class="line">                 <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</div><div class="line"></div><div class="line">                     xppr.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                     x = xpp; <span class="comment">//祖父节点作为新节点，继续平衡之路</span></div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (x == xp.right) &#123;</div><div class="line"></div><div class="line">                         root = rotateLeft(root, x = xp);</div><div class="line"></div><div class="line">                         xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                         xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                         <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                             xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                             root = rotateRight(root, xpp);</div><div class="line"></div><div class="line">                         &#125;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="keyword">else</span> &#123; <span class="comment">//父亲节点是右节点</span></div><div class="line">             <span class="comment">//父亲节点和叔叔节点是红色，则叔叔和父亲变为黑色，祖父变为红色</span></div><div class="line"></div><div class="line">                 <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</div><div class="line"></div><div class="line">                     xppl.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                     x = xpp;<span class="comment">//祖父节点作为新节点，继续平衡之路</span></div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="keyword">else</span> &#123; <span class="comment">//父亲节点和叔叔节点是红色</span></div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (x == xp.left) &#123;</div><div class="line"></div><div class="line">                         root = rotateRight(root, x = xp);</div><div class="line"></div><div class="line">                         xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                         xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                         <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                             xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                             root = rotateLeft(root, xpp);</div><div class="line"></div><div class="line">                         &#125;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashMap源码解读]]></title>
      <url>http://baobing.github.io/2016/07/25/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="关于HashMap的疑问"><a href="#关于HashMap的疑问" class="headerlink" title="关于HashMap的疑问"></a>关于HashMap的疑问</h1><ul>
<li><p>HashMap底层的数据结构，怎样解决hash碰撞。</p>
</li>
<li><p>HashMap何时扩容，扩容的过程是怎样的              </p>
</li>
<li><p>红黑树是一种怎样的数据结构</p>
<a id="more"></a>
</li>
</ul>
<h1 id="JDK8-HashMap数据结构"><a href="#JDK8-HashMap数据结构" class="headerlink" title="JDK8 HashMap数据结构"></a>JDK8 HashMap数据结构</h1><center><img src="/2016/07/25/HashMap源码解读/HashMap.png" alt="图1" title="图1"></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">       <span class="keyword">final</span> K key;</div><div class="line">       <span class="keyword">volatile</span> V val;</div><div class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</div><div class="line">      <span class="comment">//省略省略</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure>
<p>　　不难发现HashMap底层由数组、链表和红黑树三者组成。</p>
<h2 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h2><p>　　包含一个执行自身类型的引用next，显然Node类是组成链表的节点，next引用负责链接各个节点。</p>
<h2 id="table数组"><a href="#table数组" class="headerlink" title="table数组"></a>table数组</h2><p>　　Node类组成的数组，装载所有的键值对。table有以下几个特点:</p>
<ul>
<li>长度N一定为2的幂。即使指定初始长度，N一定是大于等于初始长度的2的幂（可以参考tableSizeFor函数）</li>
<li>table[i]包含的是hash&amp;(N-1)的Node节点。由于N为2的幂，hash&amp;(N-1)等价于hash%N。与运算的速度大大高于取余，这就是作者的高明之处。</li>
<li>延迟初始化，只用第一次在Map中放入元素时，才会调用这个分配空间。</li>
</ul>
<h2 id="链表和红黑树"><a href="#链表和红黑树" class="headerlink" title="链表和红黑树"></a>链表和红黑树</h2><p>　　多个元素hash&amp;(n-1)的值相同的情况称为hash碰撞。链表和红黑树这两种数据结构都是在发生hash碰撞时产生的结果。如果链表的长度大于8且table长度大于64，链表被转化为红黑树。如果红黑树的节点数量小于6，则转化为链表。 </p>
<h1 id="HashMap重要字段"><a href="#HashMap重要字段" class="headerlink" title="HashMap重要字段"></a>HashMap重要字段</h1><ul>
<li><p>Node<k,v>[] table，文章已经提到不再赘述</k,v></p>
</li>
<li><p>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4。HashMap默认初始大小为16</p>
</li>
<li><p>DEFAULT_LOAD_FACTOR = 0.75f。默认负载因子是0.75，也就是说table数组有75%非空时进行扩容。</p>
</li>
<li><p>size：记录Map中键值对个数。</p>
</li>
<li><p>threshold：记录下一次扩容的阈值。threshold = loadFactor * table.length.</p>
</li>
</ul>
<h1 id="重要的函数"><a href="#重要的函数" class="headerlink" title="重要的函数"></a>重要的函数</h1><h2 id="get操作实现函数getNode"><a href="#get操作实现函数getNode" class="headerlink" title="get操作实现函数getNode"></a>get操作实现函数getNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line"></div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line"></div><div class="line">        <span class="comment">//延迟初始化导致table可能为空</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line"></div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//hash对应table数组位置的头元素key等于查找key，直接返回头节点</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line"></div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                <span class="keyword">return</span> first;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;  </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)   <span class="comment">//头元素是一棵红黑树</span></div><div class="line"></div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line"></div><div class="line">                do &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; <span class="comment">//遍历链表直到找到hash相等 key相等的元素</span></div><div class="line"></div><div class="line">                         ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line"></div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="put操作实现函数putVal"><a href="#put操作实现函数putVal" class="headerlink" title="put操作实现函数putVal"></a>put操作实现函数putVal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"></div><div class="line">                   <span class="keyword">boolean</span> evict) &#123;</div><div class="line"></div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="comment">//第一次执行put操作时初始化table</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) </div><div class="line"></div><div class="line">            n = (tab = resize()).length;</div><div class="line"></div><div class="line">        <span class="comment">//节点填充的位置为null，直接放入新的Node节点</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;  <span class="comment">//key已经在Map中出现，直接覆盖原数字</span></div><div class="line"></div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                e = p;</div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//p是一棵红黑树</span></div><div class="line"></div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line"></div><div class="line">            <span class="keyword">else</span> &#123;               <span class="comment">//p是一个链表，将元素放置到链表末尾</span></div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">// 链表长度大于等于8，链表转化为红黑树</span></div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</div><div class="line">                            treeifyBin(tab, hash);</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    &#125;              </div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;     <span class="comment">// 相同key在链表中存在，覆盖原来节点</span></div><div class="line"></div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    p = e;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line"></div><div class="line">                V oldValue = e.value;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                    e.value = value;</div><div class="line"></div><div class="line">                afterNodeAccess(e);</div><div class="line"></div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//table数组有一个位置被占用，判断是否扩容</span></div><div class="line"></div><div class="line">        ++modCount;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line"></div><div class="line">            resize();</div><div class="line"></div><div class="line">        afterNodeInsertion(evict);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="扩容函数resize"><a href="#扩容函数resize" class="headerlink" title="扩容函数resize"></a>扩容函数resize</h2><p>1）获取新数组newTab的长度，为newTab申请空间。需要考虑容量最大边界，延迟初始化等问题。</p>
<p>2）将原数组oldTab中的节点，放入newTab中。链表和红黑树拆解问题。数组容量是2的幂，所以拆解过程很有技巧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line"></div><div class="line">        Node&lt;K,V&gt;[] oldTab = table;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldThr = threshold;  <span class="comment">//原数组阈值</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//分别记录新table容量 和 新的阈值</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line"></div><div class="line">                threshold = Integer.MAX_VALUE;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> oldTab;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line"></div><div class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line"></div><div class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// Map设置初始容量,threshold为table初始容量</span></div><div class="line"></div><div class="line">            newCap = oldThr;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line"></div><div class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line"></div><div class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">//设置初始容量时，计算新的阈值</span></div><div class="line"></div><div class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line"></div><div class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line"></div><div class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        threshold = newThr;</div><div class="line"></div><div class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line"></div><div class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line"></div><div class="line">        table = newTab;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;   <span class="comment">//遍历原始table</span></div><div class="line"></div><div class="line">                Node&lt;K,V&gt; e;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                    oldTab[j] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)    <span class="comment">// 不存在hash碰撞，只有一个节点</span></div><div class="line"></div><div class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line"></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  <span class="comment">// 红黑树</span></div><div class="line"></div><div class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line"></div><div class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    <span class="comment">//将链表分为两个链表，分割依据看下面代码</span></div><div class="line"></div><div class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; </div><div class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                        Node&lt;K,V&gt; next;</div><div class="line"></div><div class="line">                        do &#123;</div><div class="line"></div><div class="line">                            next = e.next;</div><div class="line">                            </div><div class="line"></div><div class="line"><span class="comment">/* table的capcity一定是2的幂。e.hash &amp; oldCap 结果 r只可能等于0或者oldCap</span></div><div class="line"> e.hash &amp; oldCap == 0 时，e.hash &amp; (oldCap-1) == e.hash &amp; (newCap-1)</div><div class="line">e.hash &amp; oldCap == oldCap 时,e.hash &amp; (oldCap-1)+oldCap ==e.hash&amp;(newCap-1)*/</div><div class="line"></div><div class="line"></div><div class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; </div><div class="line"></div><div class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                                    loHead = e;</div><div class="line"></div><div class="line">                                <span class="keyword">else</span></div><div class="line"></div><div class="line">                                    loTail.next = e;</div><div class="line"></div><div class="line">                                loTail = e;</div><div class="line"></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                                    hiHead = e;</div><div class="line"></div><div class="line">                                <span class="keyword">else</span></div><div class="line"></div><div class="line">                                    hiTail.next = e;</div><div class="line"></div><div class="line">                                hiTail = e;</div><div class="line"></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                            loTail.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                            newTab[j] = loHead;</div><div class="line"></div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                            hiTail.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                            newTab[j + oldCap] = hiHead;</div><div class="line"></div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> newTab;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组中第k大的数字]]></title>
      <url>http://baobing.github.io/2016/07/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>从给定长度的整数数组中，选取第K大的数字。要求时间复杂度为O(N).<br><a id="more"></a></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>1）需要查找的数组a，选取其中一个数字a<a href="start&lt;=i&lt;=end">i</a>作为Key<br>2) 小于Key的数字放在Key左侧<br>3）大于等于Key的数字放在Key右侧<br>4）如果Key的下标keyIndex等于K，返回Key；<br>5）如果keyIndex 小于K，end = keyIndex - 1，重复1）<br>6）如果keyIndex 大于K，start = keyIndex + 1，重复1）</p>
<p>　　这种求解方法是快速排序的思路演化而来。<br>　　个人想到的一个将元素依据大小放置在Key左右的方法。<br>　　使用两个辅助数组，一个保存大于Key的元素，一个保存小于Key的元素。将小于Key的元素放置在头部，将小于Key的元素放于尾部。将剩余的空间放置Key。<br>　　优点：可以得到于Key相同的所有元素，对于相同元素多的数组可以加快速度<br>　　缺点：耗时，需要辅助空间</p>
<h1 id="衍生问题"><a href="#衍生问题" class="headerlink" title="衍生问题"></a>衍生问题</h1><ul>
<li>给定整数数组中，求前K大的所有数字</li>
<li>给定整数数组中，某个的数字出现次数超过数组长度一半，找到这个数字。</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> acm;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by hubaobin on 16/7/24.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kth</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> start 开始的下标</div><div class="line">     * <span class="doctag">@param</span> end 结束的下标</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> first = start;</div><div class="line">        <span class="keyword">int</span> last = end;</div><div class="line">        <span class="comment">//选取第一个数字作为key,建议还是随机选取避免选取数字过小或者过大</span></div><div class="line">        <span class="keyword">int</span> key = a[first];</div><div class="line">        <span class="comment">//将小于key的值放在key左侧,大于等于key的值放在右侧</span></div><div class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</div><div class="line">            <span class="comment">//一定要先从后到前扫描</span></div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; a[last] &gt;= key) last--;</div><div class="line">            a[first] = a[last];</div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; a[first] &lt;= key) first++;</div><div class="line">            a[last] = a[first];</div><div class="line">        &#125;</div><div class="line">        a[first] = key;</div><div class="line">        <span class="keyword">if</span> (first == k) <span class="keyword">return</span> a[first];</div><div class="line">        <span class="keyword">if</span> (first &gt; k) <span class="keyword">return</span> getKth(a, k, start, first - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> getKth(a, k, first + <span class="number">1</span>, end);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>&#125;;</div><div class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> k;</div><div class="line">        <span class="keyword">while</span> ((k = scanner.nextInt()) != -<span class="number">1</span>) &#123;</div><div class="line">            System.out.println(getKth(a, k - <span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快速幂原理解析]]></title>
      <url>http://baobing.github.io/2016/07/22/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>求n的m次方，时间复杂度O(log(N)).不考虑大数情况。<br><a id="more"></a></p>
<h1 id="解决方法：快速幂"><a href="#解决方法：快速幂" class="headerlink" title="解决方法：快速幂"></a>解决方法：快速幂</h1><h2 id="求解方法和步骤"><a href="#求解方法和步骤" class="headerlink" title="求解方法和步骤"></a>求解方法和步骤</h2><p>1）假设n=3,m=10</p>
<p>2）将m转化为二进制为t=1010,数组形式为a={1,0,1,0}，a[i]表示m的第i位上的二进制数组。</p>
<p>3）f[i]表示m的前i个二进制数字的十进制形式。我们可以得到<strong><em> f[i+1] = (f[i]+a[i] )</em>2 *</strong> ，如：10 =((((1+0)<em>2+1)</em>2+0)<em>2+1)</em>2 。</p>
<p>4）2^3^4 = (2^3)^4 ，2^(1+2) = 2^2<em>2 ,由上面两条定理可以推得 g[i+1] = (g[i] </em>(n^a[i]))^2 。</p>
<p>其中g[i]表示 n^f[i]。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">package</span> acm;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/22.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickPower</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPower</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不能同时为0"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((m &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">                result *= n;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            result *= result;</div><div class="line"></div><div class="line">            m &gt;&gt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        System.out.println(getPower(<span class="number">2</span>, <span class="number">10</span>));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快排、递归、堆和基数四种排序方法]]></title>
      <url>http://baobing.github.io/2016/07/19/%E5%9B%9B%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>接下来文章将会讲述四种排序算法的实现和可行性证明。<strong><em>只有证明一个算法的正确性，才算理解一种算法。</em></strong><br><a id="more"></a></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1)从需要排序的数组选中一个作为Key，比Key小的放在右边，比Key大的放在左边。</p>
<p>2 )Key右侧的元素重复步骤1)</p>
<p>3)Key右侧的元素重复步骤1)</p>
<p>观察源码即可找到实现步骤一效果的方法。</p>
<h2 id="可行性证明"><a href="#可行性证明" class="headerlink" title="可行性证明"></a>可行性证明</h2><p>题设</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1)每次排序选中Key的左侧小于等于Key </div><div class="line"></div><div class="line">2)每次排序选中Key的右侧大于等于Key</div><div class="line"></div><div class="line">3)需要排序数组长度为2或3时，数据一定是升序</div></pre></td></tr></table></figure>
<p>假设数组为 a[] ，Key的下标为k，数组范围为0-n。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1)当 0&lt;=i&lt;k 时，a[i] &lt;=a[k] &amp;&amp; a[i]&lt;= a[i+1].</div><div class="line"></div><div class="line">2)当 k&lt;j&lt;=n 时，a[j] &gt;=a[k] &amp;&amp; a[j]&gt;= a[j-1].</div><div class="line"></div><div class="line">3)结合1)、2)可以推导出：当 0&lt;=l&lt;n , a[i]&lt;a[i+1]，即排序结果有序</div></pre></td></tr></table></figure>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><ul>
<li><p>优点:空间复杂度为 O(N) </p>
</li>
<li><p>缺点:时间复杂度O(Nlog(N))，但是不稳定。Key的选择很关键，选不好复杂度就会变为N的平方。</p>
</li>
<li><p>优化方法：选择数组头部中间尾部，三个元素中间值作为Key。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by baobing on 16/7/15.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        sort(<span class="number">0</span>, list.length-<span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> key = list[low];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> first = low;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> last = high;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//一定要从后往前先</span></div><div class="line"></div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; list[last] &gt;= key) &#123;</div><div class="line"></div><div class="line">                last--;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            list[first] = list[last];</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; list[first] &lt;= key) &#123;</div><div class="line"></div><div class="line">                first++;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            list[last] = list[first];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        list[first] = key;</div><div class="line"></div><div class="line">        sort(low, first - <span class="number">1</span>);</div><div class="line"></div><div class="line">        sort(first + <span class="number">1</span>, high);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        QuickSort q = <span class="keyword">new</span> QuickSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>1）将数组分为两个大小相同的数组（有可能大小相差1），继续分割数组，直到数组大小为1.</p>
<p>2）现在从同一个数组分割来的两个数组都为升序，将两个数组合并为一个升序的数组。</p>
<p>3）重复步骤 2）直到整个数组被合并</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>典型的分治算法。通过子序列的有序性，保证自身的有序性。</p>
<h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><ul>
<li><p>优点：时间复杂度为O(Nlog(N)) 并且极其稳定</p>
</li>
<li><p>缺点：空间复杂度为O(2N)),比较节省空间的场合不适用，尤其是比较大的数组</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/16.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span>[] list;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 合并两个有序的数组</div><div class="line"></div><div class="line">     * 第一个数组的起始下标为low 终止下标为mid</div><div class="line"></div><div class="line">     * 第二个数组的起始下标为mid+1 终止下标为high</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//用于保存两个数组合并结果</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="comment">//第一个数组的始末下标</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> first1 = low, end1 = mid;</div><div class="line"></div><div class="line">        <span class="comment">//第二个数组的始末下标</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> first2 = mid + <span class="number">1</span>, end2 = high;</div><div class="line"></div><div class="line">        <span class="comment">//记录临时数组的下标</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first1 &lt;= end1 &amp;&amp; first2 &lt;= end2) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (list[first1] &lt; list[first2]) &#123;</div><div class="line"></div><div class="line">                temp[k++] = list[first1++];</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                temp[k++] = list[first2++];</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//第一个数组的剩余元素放入临时数组</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first1 &lt;= end1) &#123;</div><div class="line"></div><div class="line">            temp[k++] = list[first1++];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//第二个数组的剩余元素放入临时数组</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first2 &lt;= end2) &#123;</div><div class="line"></div><div class="line">            temp[k++] = list[first2++];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//排序好的临时数组覆盖原数组</span></div><div class="line"></div><div class="line">        System.arraycopy(temp, <span class="number">0</span>, list, low, temp.length);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 排序数组</div><div class="line"></div><div class="line">     *</div><div class="line"></div><div class="line">     * <span class="doctag">@param</span> low  起始下标</div><div class="line"></div><div class="line">     * <span class="doctag">@param</span> high 末尾下标</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">        sort(low, mid);</div><div class="line"></div><div class="line">        sort(mid + <span class="number">1</span>, high);</div><div class="line"></div><div class="line">        merge(low, mid, high);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        sort(<span class="number">0</span>, list.length - <span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        MergeSort q = <span class="keyword">new</span> MergeSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>最大堆：完全二叉树，所有根节点的子节点小于等于本身</li>
</ul>
<p>1）N个节点的树，构建为最大堆。</p>
<p>2）根节点与树最后一个叶子节点交换。</p>
<p>3）除去尾部的交换节点之后的树，构造为最大堆</p>
<p>4）重负步骤2）</p>
<h2 id="优点缺点-1"><a href="#优点缺点-1" class="headerlink" title="优点缺点"></a>优点缺点</h2><ul>
<li><p>优点 复杂度O(Nlog(N)) 空间复杂度为O(N)</p>
</li>
<li><p>缺点 构建最大堆浪费不少时间</p>
</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/16.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        buildMaxHeapify();</div><div class="line"></div><div class="line">        <span class="comment">//末尾与头交换，交换后调整最大堆</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line"></div><div class="line">            swap(<span class="number">0</span>, i);</div><div class="line"></div><div class="line">            maxHeapify(i, <span class="number">0</span>);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeapify</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//没有子节点的才需要创建最大堆，从最后一个的父节点开始</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> startIndex = getParentIndex(list.length - <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">//从尾端开始创建最大堆，每次都是正确的堆</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line"></div><div class="line">            maxHeapify(list.length, i);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 创建最大堆</div><div class="line"></div><div class="line">     *</div><div class="line"></div><div class="line">     * <span class="doctag">@paramheapSize</span>需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了</div><div class="line"></div><div class="line">     * <span class="doctag">@paramindex</span>当前需要创建最大堆的位置</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//当前点与左右子节点比较</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = getChildLeftIndex(index);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> right = getChildRightIndex(index);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">int</span> largest = index;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; list[index] &lt; list[left]) &#123;</div><div class="line"></div><div class="line">            largest = left;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; list[largest] &lt; list[right]) &#123;</div><div class="line"></div><div class="line">            largest = right;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (largest != index) &#123;</div><div class="line"></div><div class="line">            swap(index, largest);</div><div class="line"></div><div class="line">            maxHeapify(heapSize, largest);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> temp = list[a];</div><div class="line"></div><div class="line">        list[a] = list[b];</div><div class="line"></div><div class="line">        list[b] = temp;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 父节点位置</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 左子节点position注意括号，加法优先级更高</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildLeftIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 右子节点position</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildRightIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        HeapSort q = <span class="keyword">new</span> HeapSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h2><p>1）将需要排序的数组list中的数字根据他们的个位数字i放到对应的数组bucket[i]的末尾。</p>
<p>2）从0-9依次将bucket中的数字放置到需要排序的数组list。</p>
<p>3）接下来是十位、百位，重复类似步骤1），指导数组list中的所有元素该位置都没有数字。</p>
<h2 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：</p>
<ul>
<li><p>时间复杂度低O(Mlog(N)).（N为排序数字个数M为最大位）对于N大M小的情况尤为突出。</p>
</li>
<li><p>可以实现相同大小的数字，依旧保持先后顺序</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>辅助空间需求要求比较大</p>
</li>
<li><p>M大N小时，性能下降</p>
</li>
<li><p>试用的排序类型比较少，整数最适合</p>
</li>
</ul>
<p>缺点</p>
<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/17.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> list[];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> <span class="comment">//d表示最大的数有多少位</span></span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">//bucket[i]用来装载需要排序的位等于i的数字</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][list.length];</div><div class="line"></div><div class="line">        <span class="comment">//idxArr[i] 表示bucket[i]填充数据个数</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] idxArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) idxArr[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> isContinue = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">//将数组放入bucket</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> divRes = list[i] / n;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (divRes &gt;= <span class="number">10</span>) isContinue = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> lsd = (divRes % <span class="number">10</span>);</div><div class="line"></div><div class="line">                bucket[lsd][idxArr[lsd]++] = list[i];</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//bucket中的数字放回原数组</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; idxArr[i]; j++) &#123;</div><div class="line"></div><div class="line">                    list[k++] = bucket[i][j];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                idxArr[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!isContinue) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            n *= <span class="number">10</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        RadixSort q = <span class="keyword">new</span> RadixSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
