<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JVM1-运行机制内存工作原理]]></title>
      <url>http://baobing.github.io/2016/08/28/JVM1-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="JVM-规范"><a href="#JVM-规范" class="headerlink" title="JVM 规范"></a>JVM 规范</h1><p>JVM可以运行除了java之外的很多语言，如groovy,jruby,scala。JVM规范包括：<br><a id="more"></a><br>1、class文件格式<br>2、数据的内部表示和存储<br>3、returnAddress 数据类型定义<br>4、invokedynamic<br>5、定义pc<br>6、堆、栈、方法区<br>7、 类型转化<br>8 、出栈入栈<br>9 、运算<br>10、流程控制<br>11、函数调用<br>12 对javaLibrary提供支持、反射、类加载、初始化类。安全、多线程、弱引用</p>
<h1 id="运行时数据区的划分"><a href="#运行时数据区的划分" class="headerlink" title="运行时数据区的划分"></a>运行时数据区的划分</h1><ul>
<li>程序计数器</li>
<li>java堆</li>
<li>java虚拟机栈</li>
<li>本地方法栈</li>
<li>方法区</li>
</ul>
<img src="/2016/08/28/JVM1-运行机制内存工作原理/pic4.png" alt="pic4.png" title="">
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>　　一块较小的内存空间，他的作用可以看做是当前线程所执行的字节码的行号指示器。线程私有的内存区域，生命周期与线程相同。<br>　　如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则个计数器值则为空。<br>　　此内存区域是唯一一个在java虚拟机规范中没有任何OutOfMemoryError情况的区域。<br>　　Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多喝处理器老说是一个内核）都只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的计数器。</p>
<h2 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a>JVM栈</h2><p>　　栈上分配 ：小对象，不存在内存逃逸的情况下，直接分配在栈上。可以自动回收，减轻GC压力，大对象或者逃逸对象无法栈上分配 。内存逃逸指被多个线程共享。</p>
<ul>
<li>执行字节码</li>
<li>线程私用</li>
<li>存储栈帧，执行java方法的调用、执行和退出</li>
<li>存在OutofMemoryError 和 stackOverFlow</li>
</ul>
<h1 id="本地方法栈NativeMethodStack"><a href="#本地方法栈NativeMethodStack" class="headerlink" title="本地方法栈NativeMethodStack"></a>本地方法栈NativeMethodStack</h1><p>　　本地方法栈与JVM栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为JVM使用到的Native方法服务</p>
<ul>
<li>线程私用</li>
<li>执行Native方法的调用、执行和退出</li>
<li>OutofMemoryError 和 stackOverFlow</li>
<li>hotspot将栈与本地方法栈合并。</li>
<li>方法结束自动释放内存</li>
</ul>
<h2 id="栈帧-stack-frame"><a href="#栈帧-stack-frame" class="headerlink" title="栈帧 stack frame"></a>栈帧 stack frame</h2><p>　　JVM栈中存储数据的内容，他被用于存储局部变量表、操作数和部分过程结果的数据结构，同时也被用来处理动态链接，方法返回值和异常分派。<br>　　包含局部变量表，操作数栈，动态链接信息，方法正常完成、异常完成信息<br>　　局部变量由如若干slot组成，长度由编译器决定。单个slot可以存储一个基本类型、reference和returnAddress的数据，两个slot可以存储一个类型为long或double的数据。reference 直接或间接的找到对象，直接或间接的找到对象在方法区中的数据类型。<br>第一个为本对象的引用地址。<br>每个方法创建一个栈帧，并且压入栈。<br>操作数栈，进行数学计算 。</p>
<h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><p>　　JVM明确要求该区域需要实现自动内存管理。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代：再细致一点的有Eden空间、FromSurvior空间，To Survivor、tenured  。从内存分配的角度来看，线程共享的Java堆中可能划分出多个私有的分配缓冲区（TLAB）。存在OutofMemoryError。</p>
<h1 id="方法区（别名-：Method-Area、Non-Heap、永久代、permanent-Gerneration）"><a href="#方法区（别名-：Method-Area、Non-Heap、永久代、permanent-Gerneration）" class="headerlink" title="方法区（别名 ：Method Area、Non-Heap、永久代、permanent Gerneration）"></a>方法区（别名 ：Method Area、Non-Heap、永久代、permanent Gerneration）</h1><ul>
<li>线程共享。</li>
<li>作用是存储Jva类的类型信息、常量、静态变量、即时编辑后的代码等数据。</li>
<li>JVM不要求该区域实现自动内存管理，常量池的回收已经类型信息的卸载</li>
<li>JDK1.2-1.6 hotspot 使用永久代与方法区 jdk1.7 使用堆 </li>
</ul>
<h2 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h2><ul>
<li>全局共享</li>
<li>方法区的一部分</li>
<li>作用是存储Java类文件常量池中的数据信息、字面量和符号引用</li>
<li>并非只有类加载使用，运行期也可以动态添加，如String.intern()</li>
</ul>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p> jdk1.4中nio被引入，目的是避免在java堆和native堆中来来回复制数据带来的性能损失。全局共享。</p>
<h1 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1><p>　　假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，这种分配方式成为“指针碰撞”。相对的分配方式成为“空闲列表”。<br>　　对象内存分配的同步：（1）采用CAS配上失败重试的方式保证更新操作的原子性（2）内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一块内存，本地线程缓冲（TLAB）。<br>　　对象头（Object Header）存放对象哈希码、对象的GC分代、类的元数据信息。</p>
<img src="/2016/08/28/JVM1-运行机制内存工作原理/pic1.png" alt="pic1.png" title="">
<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>　　对象头、实例数据、和对齐填充（Padding）。对象头包含两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等、这部分数据的长度在32位和64位，官方称它为Mark Word。25位存储哈希码、4位存储对象分代年龄、2位用于存储锁标志</p>
<p>对象的访问定位</p>
<p>（1）使用直接指针访问方式的最大好蠢就是速度更快，他节省了一次指针定位 的时间开销</p>
<img src="/2016/08/28/JVM1-运行机制内存工作原理/pic2.png" alt="pic2.png" title="">
<p>（2）使用句柄</p>
<img src="/2016/08/28/JVM1-运行机制内存工作原理/pic3.png" alt="pic3.png" title="">
<h1 id="Java反编译"><a href="#Java反编译" class="headerlink" title="Java反编译"></a>Java反编译</h1><p>javap -verbose Test01 反编译java字节码 查看java字节码</p>
<h1 id="happen-before原则（指令重排原则）"><a href="#happen-before原则（指令重排原则）" class="headerlink" title="happen-before原则（指令重排原则）"></a>happen-before原则（指令重排原则）</h1><ul>
<li>程序顺序原则：一个程序内保证语意的串行</li>
</ul>
<ul>
<li>volatile规则：volatile变量的写必须先于读 。</li>
</ul>
<ul>
<li>锁原则： 解锁必然先于加锁</li>
</ul>
<ul>
<li>传递性</li>
</ul>
<ul>
<li>线程的start方法优先于他的每一动作</li>
</ul>
<ul>
<li>线程的所有操作先于线程的中断</li>
</ul>
<ul>
<li>线程中断先于被中断线程的代码</li>
</ul>
<p>﻿- 构造函数先于finalize()</p>
<h1 id="解释运行"><a href="#解释运行" class="headerlink" title="解释运行"></a>解释运行</h1><ul>
<li>解释执行以解释方式运行字节码</li>
</ul>
<ul>
<li>解释执行的意思是读一句执行一句</li>
</ul>
<h1 id="编译运行JIT"><a href="#编译运行JIT" class="headerlink" title="编译运行JIT"></a>编译运行JIT</h1><ul>
<li>将字节码编译成机器码</li>
</ul>
<ul>
<li>直接执行机器码 </li>
</ul>
<ul>
<li>运行时编译</li>
</ul>
<ul>
<li>速度快十倍</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM11-Jetty简介]]></title>
      <url>http://baobing.github.io/2016/08/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM11-Jetty/</url>
      <content type="html"><![CDATA[<p>简要的介绍了Jetty的启动流程。对象池是一个很新颖的概念，与线程池有所区别。<br><a id="more"></a></p>
<h1 id="创建Server"><a href="#创建Server" class="headerlink" title="创建Server"></a>创建Server</h1><h2 id="初始化线程池"><a href="#初始化线程池" class="headerlink" title="初始化线程池"></a>初始化线程池</h2><p>使用QueuedThreadpool实现SizedThreadPool  </p>
<h2 id="初始化ServerConnector"><a href="#初始化ServerConnector" class="headerlink" title="初始化ServerConnector"></a>初始化ServerConnector</h2><ul>
<li>初始化SecheduledExecutorScheduler</li>
<li><p>初始化ByteBufferPool （相当于对象池，减少GC），创建对象的效率是很高的，回收很低。不能使用sycronized同步，效率太低，必须使用无锁。<br>ArrayByteBufferPool。大小不一定相同，池中保存很多大小不同的对象。<br>列外处理：如果社情的ByteBuffer过大或者过小无法在Pool中满足，则可以申请陈宫，但无法归还给Pool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public ArrayByteBufferPool(int minSize,int increment,int maxSize)</div><div class="line">direct[] = </div><div class="line">indirect[] = </div><div class="line">Queue&lt;ByteBuffer&gt; = new ConcurrentLinkedQueue&lt;&gt;();</div><div class="line">//1取得合适的Bucket 2从Bucket中取得ByteBuffer 3不存在创建</div><div class="line">acquire()</div><div class="line">//1取得合适的Bucket 2清空Buffer 3归还Pool </div><div class="line">release()</div></pre></td></tr></table></figure>
</li>
<li><p>ConnectionFactory维护<br>用于创建链接，比如Accept后，需要创建一个表示链接的对象</p>
</li>
<li><p>获取cpu数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cores = Runtime.getRuntime().availableProcessors();</div></pre></td></tr></table></figure>
</li>
<li><p>更新acceptor数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">acceptors = Math.max(1,Math.min(4,cores/8));</div></pre></td></tr></table></figure>
</li>
<li><p>创建acceptor线程组</p>
</li>
<li>初始化ServerConnectorManger<br>继承自<br>保存selector线程数量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.min(4,Runtime.getRuntime().availableProcessors()/2)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="设置port"><a href="#设置port" class="headerlink" title="设置port"></a>设置port</h2><h2 id="关联Server和Connector"><a href="#关联Server和Connector" class="headerlink" title="关联Server和Connector"></a>关联Server和Connector</h2><h1 id="Server-start"><a href="#Server-start" class="headerlink" title="Server.start"></a>Server.start</h1><h2 id="设置启动状态"><a href="#设置启动状态" class="headerlink" title="设置启动状态"></a>设置启动状态</h2><h2 id="启动过程doStart"><a href="#启动过程doStart" class="headerlink" title="启动过程doStart"></a>启动过程doStart</h2><ul>
<li>注册ShutdownMonitor 远程控制接口</li>
<li>获取线程池</li>
<li>设置selector数量<br>累计所有connector的需要</li>
<li>计算所需的所有线程数量<br>如果大于默认的200则中断程序</li>
<li>维护Bean<br>启动QueudThreadPool：创建线程 设置线程的属性 启动线程<br>启动WebAppContext</li>
<li>启动Connector<br>取得ConnectionFactory<br>创建selector线程并启动<br>创建Acceptor线程 设置线程名字优先级，将线程放入acceptors 监听端口<br>没有Acceptor的情况<h2 id="启动完毕"><a href="#启动完毕" class="headerlink" title="启动完毕"></a>启动完毕</h2><h1 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h1><h2 id="Accept成功"><a href="#Accept成功" class="headerlink" title="Accept成功"></a>Accept成功</h2></li>
<li>设置为非阻塞模式</li>
<li>配置Socket</li>
<li>正式处理<br>选择可用ManagedSelector线程<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private ManagedSelector chooseSelector()&#123;</div><div class="line">    //没有使用原子整数，不必担心因为多线程安全导致的问题</div><div class="line">    long s = _selectorIndex++;</div><div class="line">    int index = (int) (s % getSelectorCount());</div><div class="line">    return _selectors[index]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>ManagedSelector处理<br>提交任务 加入到ConcurrentArrayQueue队列</p>
<h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>ManagedSelector.run()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void runChanges()&#123;</div><div class="line">    Runnable change;</div><div class="line">    while((change = _changes.poll())!=null)</div><div class="line">        runChange(change);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>select()<br>处理SelectionKey</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM8-NIO和AIO]]></title>
      <url>http://baobing.github.io/2016/08/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM8-NIO%E5%92%8CAIO/</url>
      <content type="html"><![CDATA[<blockquote>
<p>圣人不死，大盗不止——庄子·胠箧</p>
</blockquote>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>New I/O的简称，与旧式的基于流的I/O方法相对。<br><a id="more"></a></p>
<ul>
<li>NIO是基于块(Block)的，它以块为基本单位处理数据</li>
<li>为所有的原始类型提供缓存（Buffer）支持</li>
<li>增加通道（Channel）对象，作为新的原始I/O抽象</li>
<li>支持文件锁（.lock文件作为一把锁）和内存映射文件的文件访问接口</li>
<li>提供了基于Selector的异步网络I/O<h2 id="Buffer和Channel"><a href="#Buffer和Channel" class="headerlink" title="Buffer和Channel"></a>Buffer和Channel</h2>file-&gt;channel-&gt;buffer-&gt;byte<br>file-&gt;channel-&gt;buffer-&gt;channel-&gt;file<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nioCopyFile</span><span class="params">(String resource, String destination)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(resource);</div><div class="line">    FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(destination);</div><div class="line">    FileChannel inputChannel = inputStream.getChannel();</div><div class="line">    FileChannel outputChannel = outputStream.getChannel();</div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">    <span class="keyword">int</span> len;</div><div class="line">    <span class="keyword">while</span>((len = inputChannel.read(buffer)) != -<span class="number">1</span>)&#123;</div><div class="line">        buffer.flip();</div><div class="line">        outputChannel.write(buffer);</div><div class="line">        buffer.clear();</div><div class="line">    &#125;</div><div class="line">    inputChannel.close();</div><div class="line">    outputChannel.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Buffer三个参数"><a href="#Buffer三个参数" class="headerlink" title="Buffer三个参数"></a>Buffer三个参数</h2><ul>
<li>position </li>
<li>capacity </li>
<li>limit</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>写模式</th>
<th>读模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置</td>
<td>当前缓冲区的位置，将从position的下一个位置写数据</td>
<td></td>
<td>当前缓冲区读取的位置，将从此位置后，读取数据</td>
</tr>
<tr>
<td>容量</td>
<td>缓冲区上限</td>
<td>缓冲区上限</td>
</tr>
<tr>
<td>上限</td>
<td>通常和容量相等</td>
<td>可读取的总容量和上次写入的数据量相等</td>
</tr>
</tbody>
</table>
<h2 id="Buffer操作"><a href="#Buffer操作" class="headerlink" title="Buffer操作"></a>Buffer操作</h2><p>Buffer.flip：通常将buffer从写模式转化为读模式<br>Buffer.rewind：将position设置为0，并且清楚标志位（mark）<br>Buffer.clear：将position设置0，同时将limit设置为capacity的大小，并清除标志位mark</p>
<h2 id="文件映射到内存"><a href="#文件映射到内存" class="headerlink" title="文件映射到内存"></a>文件映射到内存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nioFileToRandom</span><span class="params">(String resource)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(resource,<span class="string">"rw"</span>);</div><div class="line">    FileChannel fc = raf.getChannel();</div><div class="line">    MappedByteBuffer mappedByteBuffer = fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,raf.length());</div><div class="line">    <span class="keyword">while</span> ((mappedByteBuffer.hasRemaining()))&#123;</div><div class="line">        System.out.println((<span class="keyword">char</span>)mappedByteBuffer.get());</div><div class="line">    &#125;</div><div class="line">    mappedByteBuffer.put(<span class="number">0</span>,(<span class="keyword">byte</span>)<span class="number">98</span>);</div><div class="line">    raf.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="SocketServer编写简单服务器"><a href="#SocketServer编写简单服务器" class="headerlink" title="SocketServer编写简单服务器"></a>SocketServer编写简单服务器</h2><p>缺点： </p>
<ul>
<li>为每一个客户端使用一个线程，如果客户端出现延时等异常，线程可能会被占用很长时间。因为数据的准备和读取都在这个线程中。</li>
<li>此时，如果客户端数量众多，可能会消耗大量的系统资源。</li>
</ul>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>select() 无数据阻塞，有数据返回selectionKey。SelectionKey便是Selector和Channel的关系。从SelectionKey中得到Channel（数据已经准备），并读取数据。<br>selectNow() 没有数据返回0,<br>一个线程监控大量的客户端线程，减少数据准备对业务处理线程影响<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by baobing on 2016/8/23.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadNio</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Socket,Long&gt; timeStat = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> LinkedList&lt;ByteBuffer&gt; outputQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="function"><span class="keyword">public</span> LinkedList <span class="title">getOutputQueue</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> outputQueue;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(ByteBuffer byteBuffer)</span></span>&#123;</div><div class="line">            outputQueue.addFirst(byteBuffer);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HandlerMsg</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        SelectionKey selectionKey;</div><div class="line">        ByteBuffer byteBuffer;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HandlerMsg</span><span class="params">(SelectionKey selectionKey, ByteBuffer byteBuffer)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.selectionKey = selectionKey;</div><div class="line">            <span class="keyword">this</span>.byteBuffer = byteBuffer;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            EchoClient echoClient = (EchoClient) selectionKey.attachment();</div><div class="line">            echoClient.enqueue(byteBuffer);</div><div class="line">            <span class="comment">//修改兴趣事件</span></div><div class="line">            selectionKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</div><div class="line">            selector.wakeup();</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line">    <span class="keyword">private</span> ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span>  <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        selector = SelectorProvider.provider().openSelector();</div><div class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class="line">        <span class="comment">//非阻塞 需要监听事件</span></div><div class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>);</div><div class="line">        serverSocketChannel.socket().bind(address);</div><div class="line">        <span class="comment">//感兴趣的事件进行注册</span></div><div class="line">        SelectionKey selectionKey = serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">            selector.select();</div><div class="line">            Set readyKeys = selector.selectedKeys();</div><div class="line">            Iterator iterator = readyKeys.iterator();</div><div class="line">            <span class="keyword">long</span> e = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">                SelectionKey key = (SelectionKey) iterator.next();</div><div class="line">                iterator.remove();</div><div class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</div><div class="line">                    doAccept(selectionKey);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isValid() &amp;&amp; selectionKey.isReadable())&#123;</div><div class="line">                    doRead(selectionKey);</div><div class="line">                &#125;  <span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isValid() &amp;&amp; selectionKey.isWritable())&#123;</div><div class="line">                    doWrite(selectionKey);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAccept</span><span class="params">(SelectionKey selectionKey)</span></span>&#123;</div><div class="line">        ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</div><div class="line">        SocketChannel clientChannel ;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            clientChannel = server.accept();</div><div class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            <span class="comment">//注册读取事件</span></div><div class="line">            SelectionKey clientKey = clientChannel.register(selector,SelectionKey.OP_READ);</div><div class="line">            clientKey.attach(<span class="keyword">new</span> EchoClient());</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SelectionKey selectionKey)</span></span>&#123;</div><div class="line">        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</div><div class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> len = socketChannel.read(byteBuffer);</div><div class="line">            <span class="keyword">if</span>(len == -<span class="number">1</span>) <span class="keyword">return</span> ;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        byteBuffer.flip();</div><div class="line">        executorService.execute(<span class="keyword">new</span> HandlerMsg(selectionKey,byteBuffer));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SelectionKey selectionKey)</span></span>&#123;</div><div class="line">        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</div><div class="line">        EchoClient echoClient = (EchoClient) selectionKey.attachment();</div><div class="line">        LinkedList&lt;ByteBuffer&gt; outputQueue = echoClient.getOutputQueue();</div><div class="line">        ByteBuffer byteBuffer = outputQueue.getLast();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> len = socketChannel.write(byteBuffer);</div><div class="line">            <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</div><div class="line">                disconnet();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(byteBuffer.remaining() == <span class="number">0</span>)&#123;</div><div class="line">                outputQueue.removeLast();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(outputQueue.size() == <span class="number">0</span>)&#123;</div><div class="line">            selectionKey.interestOps(SelectionKey.OP_READ);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            MultiThreadNio server = <span class="keyword">new</span> MultiThreadNio();</div><div class="line">            server.startServer();</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">            System.out.println(<span class="string">"exception caught,program exiting..."</span>);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="网络编程AIO"><a href="#网络编程AIO" class="headerlink" title="网络编程AIO"></a>网络编程AIO</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>数据读取完毕通知业务线程，使用回调函数的形式</li>
<li>AIO不加快IO的读写速度，只是改变线程对IO的处理方式，从而提升性能。<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2></li>
</ul>
<img src="/2016/08/27/并发编程/GYM8-NIO和AIO/AIOcode.jpg" alt="使用示例" title="使用示例">]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ReentrantLock源码分析]]></title>
      <url>http://baobing.github.io/2016/08/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>重入锁是java级别的锁。查看重入锁源码还是应该先阅读AbstractQueuedSynchronizer源码。</p>
<blockquote>
<p><a target="_blank" href="http://baobing.github.io/2016/08/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%881%EF%BC%89/">AbstractQueuedSynchronizer解析（1）</a><br><a target="_blank" href="http://baobing.github.io/2016/08/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%882%EF%BC%89/">AbstractQueuedSynchronizer解析（2）</a></p>
</blockquote>
<a id="more"></a>
<h1 id="ReentrantLock类概述"><a href="#ReentrantLock类概述" class="headerlink" title="ReentrantLock类概述"></a>ReentrantLock类概述</h1><p>　　互斥的重入锁，与sychronized拥有相同的行为，但是它也有扩展的功能。最后一个持有锁的线程拥有重入锁。线程通过调用lock方法获取重入锁。如果当前线程已经持有锁将立刻返回。可以通过调用isHeldByCurrentThread方法检查锁是否被占有。</p>
<p>　　这个类的构造器允许传入fairness参数。设置这个参数为true的时候，等待锁时间最长的线程将得到获取锁的权利。否则不会保证特定的获取锁的顺序。公平锁的性能会稍微低一点，但是它会保证每个线程都不会处于饥饿现象。机制一点，公平锁平不能保证线程按照计划的顺序执行。</p>
<p>　　重入锁最多可以被同一个线程2147483647递归持有（每次持有锁都不释放锁）</p>
<h1 id="非公平锁获取锁"><a href="#非公平锁获取锁" class="headerlink" title="非公平锁获取锁"></a>非公平锁获取锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">﻿    ﻿ <span class="comment">//直接获取锁，不进行排队</span></div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line"></div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="comment">//失败之后再次获取锁</span></div><div class="line"></div><div class="line">            acquire(<span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非公平锁tryAcquire的业务逻辑由nonfairTryAcquire实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line"></div><div class="line">      <span class="keyword">int</span> c = getState();</div><div class="line"></div><div class="line">    ﻿       <span class="comment">//锁未被任何线程占据</span></div><div class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line"></div><div class="line">              setExclusiveOwnerThread(current);</div><div class="line"></div><div class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">      &#125; <span class="comment">//锁之前被当前线程占据，设置state为锁被当前线程重入次数</span></div><div class="line">    ﻿    ﻿    <span class="comment">//没有使用原子操作，没有同步，因为保证对state的操作只有一个线程</span></div><div class="line">    ﻿    ﻿    <span class="comment">//而且state被volatile修饰，内存可见性一定能保证</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line"></div><div class="line">          <span class="keyword">int</span> nextc = c + acquires;</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line"></div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"></div><div class="line">          setState(nextc);</div><div class="line"></div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="公平锁获取锁"><a href="#公平锁获取锁" class="headerlink" title="公平锁获取锁"></a>公平锁获取锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">﻿    <span class="comment">// 等待队列为空即可获得锁，否则加入等待队列</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line"></div><div class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line"></div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;<span class="comment">//锁之前被当前线程占据，设置state为锁被当前线程重入次数</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line"></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line"></div><div class="line">            setState(nextc);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h1><p>只有持有锁的线程才能释放锁，改变state字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> c = getState() - releases;</div><div class="line"></div><div class="line">    ﻿    ﻿    <span class="comment">//必须持有锁才能释放</span></div><div class="line">      <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line"></div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line"></div><div class="line">      <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">          free = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">    ﻿    ﻿    <span class="comment">//只有持有锁的线程才能改变state字段，不能担心线程安全</span></div><div class="line">      setState(c);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> free;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ThreadPoolExecutor源码解析]]></title>
      <url>http://baobing.github.io/2016/08/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>　　线程池的使用范围实在是太广了，很多组件的底层使用线程池创建、管理线程。之前有一篇关于线程池使用，增强的文章:<a href="/2016/08/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM4-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">GYM4-线程池</a><br><a id="more"></a></p>
<h1 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//保存线程运行状态和线程数量两个重要信息，采用一个数字保存多个信息的目的</span></div><div class="line"><span class="comment">//是保证多个信息的并发安全 </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="comment">//这个队列持有所有还为运行的任务。使用isEmpty判断队列是否为空。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</div><div class="line"></div><div class="line"><span class="comment">//保存所有的工作线程，只有持有mainLock锁的才能有操作</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//如果为false，空闲的核心线程仍然可以存活</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</div><div class="line"></div><div class="line"> <span class="comment">//除非allowCoreThreadTimeOut为真，否则这个值代表最小的一直存活的</span></div><div class="line"> <span class="comment">//工作线程的数量.</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</div><div class="line"></div><div class="line"> <span class="comment">//最大可获得线程数量，只有持有mainLock锁才能操作</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</div><div class="line"></div><div class="line"> <span class="comment">//空闲线程的超时时间以纳秒计时。线程数量大于corePoolSize时并且</span></div><div class="line"> <span class="comment">//allowCoreThreadTimeOut为真，线程超时时间才能工作</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</div><div class="line"></div><div class="line"> <span class="comment">//工作线程集合以及相关记录变量的锁。使用锁而不是并发set是因为，</span></div><div class="line"> <span class="comment">//可以避免一些不必要的中断。简化了相关的记录变量 例如largestPoolSize。</span></div><div class="line"> <span class="comment">// shutdown 和shutdownNow方法都需要持有锁，目的是去报分别检查</span></div><div class="line"> <span class="comment">//中断权限和是否正在中断工作线程仍能平稳运行</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"> <span class="comment">//终结使用的condition</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</div><div class="line"></div><div class="line"> <span class="comment">//完成任务的数量，持有mainLock可以修改</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</div><div class="line"></div><div class="line"> <span class="comment">//所有的线程由threadFactory创建，设置线程name，Deamon等</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</div><div class="line"></div><div class="line"> <span class="comment">//线程池饱和时的拒绝策略一共四种 ，可以参看《GYM4-线程池》</span></div><div class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</div></pre></td></tr></table></figure>
<h1 id="execute操作"><a href="#execute操作" class="headerlink" title="execute操作"></a>execute操作</h1><p>　　Executor接口定义的方法，执行提交的任务。执行任务的具体线程可能是新创建的也可能是已经存在的。如果线程池关闭或者容量达到上限，RejectedExecutionHandler持有拒绝策略。　　<br>任务提交分为三个步骤：<br>　　1.正在运行的线程数量小于corePoolSize，尝试创建一个新的线程执行当前任务。调用addWorker方法，它会使用原子操作检查runState和workerCount。当无法执行提交任务时，返回false。<br>　　2.如果成功的入队，我们仍然需要检查我们可以让它入队（因为存在最后一个线程结束的可能），或者进入这个方法时线程池关闭。<br>　　3.如果进入任务队列失败，我们尝试创建一个新的线程。如果失败，一定是线程池是关闭或者饱和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"></div><div class="line">       <span class="keyword">int</span> c = ctl.get();</div><div class="line"></div><div class="line">       <span class="comment">//正在线程数量小于小于核心线程数</span></div><div class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line"></div><div class="line">         <span class="comment">//添加新的线程不一定成功，没有使用锁导致可能性比较多</span></div><div class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line"></div><div class="line">               <span class="keyword">return</span>;</div><div class="line"></div><div class="line">           c = ctl.get();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">      <span class="comment">//创建新的线程失败，加入阻塞队列</span></div><div class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line"></div><div class="line">           <span class="keyword">int</span> recheck = ctl.get();</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line"></div><div class="line">               reject(command);</div><div class="line"></div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line"></div><div class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">       &#125;<span class="comment">//入队失败或线程池关闭，创建新的线程，创建失败拒绝当前任务</span></div><div class="line"></div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line"></div><div class="line">           reject(command);</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="addWroker操作"><a href="#addWroker操作" class="headerlink" title="addWroker操作"></a>addWroker操作</h1><p>　　根据当前线程池的装填和给定的边界（核心、最大线程数）检查时候能够创建新的工作线程。如果创建成功调整工作线程的数量，创建一个新的线程运行当前任务。因为线程池关闭或者正在关闭导致的线程创建失败返回false。不管是因为线程工厂返回null还是因为异常（典型是线程启动时的OutOfMemoryError），我们都要回滚。<br>java中的标签：</p>
<ul>
<li>break lable 跳转到标签所在的循环，并且跳过循环</li>
<li>continue lable 跳转到标签所在的循环，并且继续执行循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line"></div><div class="line">        retry:</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> c = ctl.get();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            <span class="comment">// 阻塞队列是否为空</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line"></div><div class="line">                ! (rs == SHUTDOWN &amp;&amp;</div><div class="line"></div><div class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line"></div><div class="line">                   ! workQueue.isEmpty()))</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">//一直尝试将工作线程数量加一</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">            <span class="comment">//如果工作线程数量大于允许的最大线程数量返回false</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line"></div><div class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line"></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">//尝试工作线程数量加一。成功跳出最外层循环，失败往下走</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line"></div><div class="line">                    <span class="keyword">break</span> retry;</div><div class="line"></div><div class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line"></div><div class="line">            <span class="comment">//状态发生改变返回第一次循环</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line"></div><div class="line">                    <span class="keyword">continue</span> retry;</div><div class="line"></div><div class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        Worker w = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">          <span class="comment">//创建新的工作线程</span></div><div class="line"></div><div class="line">            w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> Thread t = w.thread;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//获取锁并将Worker加入集合</span></div><div class="line"></div><div class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line"></div><div class="line">                mainLock.lock();</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">                    <span class="comment">// Recheck while holding lock.</span></div><div class="line"></div><div class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></div><div class="line"></div><div class="line">                    <span class="comment">// shut down before lock acquired.</span></div><div class="line"></div><div class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line"></div><div class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line"></div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line"></div><div class="line">                        workers.add(w);</div><div class="line"></div><div class="line">                        <span class="keyword">int</span> s = workers.size();</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line"></div><div class="line">                            largestPoolSize = s;</div><div class="line"></div><div class="line">                        workerAdded = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">                    mainLock.unlock();</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            <span class="comment">//添加成功启动线程</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line"></div><div class="line">                    t.start();</div><div class="line"></div><div class="line">                    workerStarted = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (! workerStarted)</div><div class="line"></div><div class="line">                addWorkerFailed(w);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> workerStarted;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="Worker子类"><a href="#Worker子类" class="headerlink" title="Worker子类"></a>Worker子类</h1><p>持有运行任务的线程。继承自AbstractQueuedSynchronizer，实现了非重入的锁，保证工作线程的线程安全。参考<a href="2016/08/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%881%EF%BC%89/">AbstractQueuedSynchronizer解析（1）</a></p>
<p>同时Worker实现Runnable接口，也就是说他会作为一个任务被执行，而执行这个任务的线程就是Woker自身包含的Thread字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//工作线程</span></div><div class="line"></div><div class="line"> <span class="keyword">final</span> Thread thread;</div><div class="line"></div><div class="line"><span class="comment">//初始的任务可能为空</span></div><div class="line"></div><div class="line"> Runnable firstTask;</div><div class="line"></div><div class="line"> Worker(Runnable firstTask) &#123;</div><div class="line"></div><div class="line">     setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></div><div class="line"></div><div class="line">     <span class="keyword">this</span>.firstTask = firstTask;</div><div class="line"></div><div class="line"> <span class="comment">//线程运行的runnable就是Woker自身定义的run方法</span></div><div class="line"></div><div class="line">     <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">//thread属性将要运行的任务</span></div><div class="line"></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">     runWorker(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="runWoker方法"><a href="#runWoker方法" class="headerlink" title="runWoker方法"></a>runWoker方法</h2><p>工作线程不断从队列中获取任务并且执行他们，下面是对应的几个问题：<br>1.一开始执行firstTask，之后从阻塞队列中获取。如果获得的任务为null说明线程池状态或者参数发生改变，当前工作者应该被清理。<br>2.任务执行前持有锁是为了阻止其他线程中断正在执行的任务，除非线程器停止，线程不会被中断。<br>3.调用beforeExecute可能产生异常，这种情况下我们会杀死线程而不是继续执行任务。<br>4.如果任务报错，我们执行afterExecute方法。<br>5.afterExecute方法异常，线程被杀死。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line"></div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line"></div><div class="line">        Runnable task = w.firstTask;</div><div class="line"></div><div class="line">        w.firstTask = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">           <span class="comment">//初始任务为空的话，从队列中获取任务</span></div><div class="line"></div><div class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                w.lock();</div><div class="line"></div><div class="line">             <span class="comment">//线程池停止，确保线程中断，否则相反。recheck的目的</span></div><div class="line"></div><div class="line">            <span class="comment">//是处理shutdownNow方法清理中断的竞争问题。</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line"></div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line"></div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line"></div><div class="line">                    !wt.isInterrupted())</div><div class="line"></div><div class="line">                    wt.interrupt();</div><div class="line"></div><div class="line">             <span class="comment">//调用beforeExecute、run、afterExecute三个方法</span></div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">                    beforeExecute(wt, task);</div><div class="line"></div><div class="line">                    Throwable thrown = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">                        task.run();</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line"></div><div class="line">                        thrown = x; <span class="keyword">throw</span> x;</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line"></div><div class="line">                        thrown = x; <span class="keyword">throw</span> x;</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line"></div><div class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">                        afterExecute(task, thrown);</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">                    task = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    w.completedTasks++;</div><div class="line"></div><div class="line">                    w.unlock();</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            completedAbruptly = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AbstractQueuedSynchronizer解析（2）]]></title>
      <url>http://baobing.github.io/2016/08/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>针对性重复练习。持续做你不会做的事。</p>
</blockquote>
<a id="more"></a>
<h1 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h1><p>　　Node节点组成的队列是CLH(Craig, Landin, and Hagersten)的变种。CLH通常作为自旋锁使用。我们将它作为阻塞同步器使用，但是前驱节点持有线程的控制信息的策略是相同的。每个节点中的状态字段保存线程的阻塞信息。前驱节点释放时，当前节点将得到通知信号。每个队列中的节点作为specific-notification-style监视器，持有唯一的等待线程。队列中的第一个线程有机会尝试获取锁，但是不保证一定成功获得（非公平锁），它只是给了线程竞争的权利，所以被释放的竞争者可能再次等待。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     +------+  prev +-----+       +-----+</div><div class="line">head |      | &lt;---- |     | &lt;---- |     |  tail</div><div class="line">     +------+       +-----+       +-----+</div></pre></td></tr></table></figure></p>
<p>　　进入到CLH队列，你只需要一个原子操作将它拼接在队列尾部。出队，你只需要重置头部节点。<br>插入CLH队列需要一个放入尾部的原子操作，因此存在一个指针指向队中和非队中的分界点。出队需要更新“head”指针。CLH队列需要花费大量的工作决定队首能否成功获取锁，还需要花费一部分时间处理超时和中断导致的任务取消。<br>　　pre指针链接的链表主要保存取消节点。如果一个节点已经取消，它的后继指针被连接到<br>一个未取消的前驱节点。<br>　　我们使用next指针的链接的链表实现阻塞队列机制。每个节点内部保存线程的id，所以一个前驱节点通过遍历next指针查找下一个应该被唤醒的节点。确认后继者过程必须避免新入队节点设置next指针的并发竞争。</p>
<h2 id="Node源码"><a href="#Node源码" class="headerlink" title="Node源码"></a>Node源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">//需要注意的是下面两个节点都是静态属性，用来表示当前共享还是独占模式</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 状态字段 ，只有一下几种值</div><div class="line">    * SIGNAL：当前节点后继者被阻塞（通过park方法）。节点被释放或者取消时，</div><div class="line">    * 后继节点必须被唤醒。为了避免竞争，获取方法，acquire 方法的过程必须是：</div><div class="line">    * 首先获取一个锁释放信号量；然后使用原子操作获取锁；最后获取失败阻塞线程。</div><div class="line">    * CANCELLED:  当前节点因为超市或者中断被取消。节点永远不会离开</div><div class="line">    * 这个状态。尤其取消的线程节点不会再次被阻塞。</div><div class="line">    * CONDITION:节点处于Condition队列。状态值改变前，它不会被用作同步队列</div><div class="line">    * 的节点，这个时候状态值被设置为0</div><div class="line">    * PROPAGATE：共享锁被释放时，把这个信号传递给其他节点。及时其他操作被</div><div class="line">    * 干扰doReleaseShared操作仍然能够传递。</div><div class="line">    * 0:          None of the above</div><div class="line">    * 为负数时，表示当前节点不需要被唤醒。这个字段的初始值是0。</div><div class="line">    */</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 参考waitStatus字段，连接到一个前驱节点。入队时赋值，出队设置为null。</div><div class="line">    * 在前驱节点取消时，我们将当前节点链接到一个永远不会取消的节，</div><div class="line">    *  head节点永远不会取消。只有被成功获取锁的节点才能变为head节点。</div><div class="line">    * 取消的节点不可能成功</div><div class="line">    */</div><div class="line">    <span class="keyword">volatile</span> Node prev;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 链接到后继节点，在它释放的时候唤醒后继节点。入队时复制，</div><div class="line">     * 绕过取消的前驱节点时被修改，出队时被设置为null。直到节点成功加入</div><div class="line">     * 到对位，enq操作才会为它的前驱节点赋值。说以看到next字段为null</div><div class="line">     * 的节点不意味着他是队尾。 However, if a next field appears</div><div class="line">     * to be null, we can scan prev's from the tail to double-check. 、</div><div class="line">     * 取消节点的nex字段被设置为它自身 而不是null，这样有利于isOnSyncQueue</div><div class="line">     * 操作。</div><div class="line">     */</div><div class="line">    <span class="keyword">volatile</span> Node next;</div><div class="line"></div><div class="line">    <span class="comment">//拥有当前结点的线程。</span></div><div class="line">    <span class="keyword">volatile</span> Thread thread;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 链接等待condition的下一个节点，或者特定值 SHARED。</div><div class="line">     * 因为condition队列只有在独占模式下才会持有。再次获取锁的时候转变。</div><div class="line">     */</div><div class="line">    Node nextWaiter;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="addWaiter入队操作"><a href="#addWaiter入队操作" class="headerlink" title="addWaiter入队操作"></a>addWaiter入队操作</h1><p>　　利用当前线程和给定的模式创建Node节点并且入队。head和tail字段的初始化在这个操作中完成。初始化过程：</p>
<ul>
<li>如果tail字段为null，生成一个新的Node节点。</li>
<li>head和tail指向这个新节点。</li>
<li>新的节点waitStatus为0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line"></div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line"></div><div class="line">    Node pred = tail;</div><div class="line"></div><div class="line">    <span class="comment">//tail为null，说明tail第一次被初始化</span></div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">        node.prev = pred;</div><div class="line"></div><div class="line">        <span class="comment">//cas操作设置node为tail，失败进入enq</span></div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line"></div><div class="line">            pred.next = node;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> node;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    enq(node);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> node;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//多个线程加入到队尾，或者tail未被初始化。</span></div><div class="line">    <span class="comment">//cas操作可能失败，必须使用循环保证最终成功。</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line"></div><div class="line">        Node t = tail;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//尾部为null，初始化tail</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line"></div><div class="line">                tail = head;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            node.prev = t;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line"></div><div class="line">                t.next = node;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> t;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="acquire独占模式获取锁操作"><a href="#acquire独占模式获取锁操作" class="headerlink" title="acquire独占模式获取锁操作"></a>acquire独占模式获取锁操作</h1><p>　　子类通过调用这个方法获取锁。取得锁的规则有tryAcquire方法持有，子类重写这个方法而且不会阻塞线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// tryAcquire返回false，那么就加入阻塞队列阻塞线程，并等待前继结点释放锁。</span></div><div class="line">    <span class="comment">// acquireQueued返回true说明线程应该被中断</span></div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line"></div><div class="line">        <span class="comment">// acquireQueued返回true，说明当前线程被中断唤醒后获取到锁，</span></div><div class="line">        <span class="comment">// 重置其interrupt，status为true。</span></div><div class="line">        selfInterrupt();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　tryAcquire失败线程会加入队列 线程可能会反复的被阻塞和唤醒直到tryAcquire成功，这是因为线程可能被中断， 而acquireQueued方法中会保证忽视中断，只有tryAcquire成功了才返回。<br>　　中断版本的独占获取是acquireInterruptibly方法，doAcquireInterruptibly这个方法中如果线程被中断则acquireInterruptibly会抛出InterruptedException异常。addWaiter方法只是入队操作，acquireQueued方法是主要逻辑，需要重点理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 自旋re-check</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line"></div><div class="line">            <span class="comment">// 前继是head,说明next就是node了，则尝试获取锁。</span></div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 前继出队，node成为head</span></div><div class="line">                setHead(node);</div><div class="line"></div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line"></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// p != head 或者 p == head但是tryAcquire失败了，那么</span></div><div class="line">            <span class="comment">// 应该阻塞当前线程等待前继唤醒。需要设置前继的waitStaus为SIGNAL</span></div><div class="line">            <span class="comment">// parkAndCheckInterrupt返回可能是前继unpark或线程被中断。</span></div><div class="line">            <span class="comment">// parkAndCheckInterrupt返回值代表线程是否被中断</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</div><div class="line"></div><div class="line">                <span class="comment">// 说明当前线程是被中断唤醒的。</span></div><div class="line">                <span class="comment">//注意：线程被中断之后会继续走到if处去判断，也就是会忽视中断。</span></div><div class="line">                <span class="comment">// 除非碰巧线程中断后acquire成功了，那么根据Java的最佳实践，</span></div><div class="line">                <span class="comment">// 需要重新设置线程的中断状态（acquire.selfInterrupt）。</span></div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 出现异常</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line"></div><div class="line">            cancelAcquire(node);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>shouldParkAfterFailedAcquire方法的作用是：</p>
<ul>
<li>确定后继是否需要park;</li>
<li>跳过被取消的结点;</li>
<li>设置前继的waitStatus为SIGNAL.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line"></div><div class="line">    ﻿<span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line"></div><div class="line">	<span class="comment">// 前继结点已经准备好unpark其后继了，所以后继可以安全的park</span></div><div class="line">    ﻿<span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line"></div><div class="line">        ﻿<span class="comment">/*</span></div><div class="line">        ﻿ * This node has already set status asking a release to signal it,</div><div class="line">       ﻿  * so it can safely park.</div><div class="line">      ﻿   */</div><div class="line"></div><div class="line">        ﻿<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    ﻿<span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">// CANCELLED</span></div><div class="line"></div><div class="line">    ﻿    <span class="comment">// 跳过被取消的结点。</span></div><div class="line">    ﻿    do &#123;</div><div class="line"></div><div class="line">    ﻿        node.prev = pred = pred.prev;</div><div class="line"></div><div class="line">     ﻿   &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line"></div><div class="line">    ﻿    pred.next = node;    ﻿</div><div class="line"></div><div class="line">    ﻿&#125; <span class="keyword">else</span> &#123;<span class="comment">// 0 或 PROPAGATE (CONDITION用在ConditonObject，这里不会是这个值)</span></div><div class="line"></div><div class="line">       ﻿ <span class="comment">/**</span></div><div class="line">         ﻿* waitStatus 等于0（初始化）或PROPAGATE。说明线程还没有park，会先重试 </div><div class="line">        ﻿ * 确定无法acquire到再park。</div><div class="line">       ﻿  */</div><div class="line">       ﻿ <span class="comment">// 更新pred结点waitStatus为SIGNAL    ﻿</span></div><div class="line">       ﻿ compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line"></div><div class="line">    ﻿&#125;</div><div class="line"></div><div class="line">    ﻿<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程被唤醒只可能是：被unpark，被中断或伪唤醒。被中断会设置interrupted，acquire方法返回前会 selfInterrupt重置下线程的中断状态，如果是伪唤醒的话会for循环re-check。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="独占模式释放"><a href="#独占模式释放" class="headerlink" title="独占模式释放"></a>独占模式释放</h1><p>比较简单只要直接唤醒后续结点就可以了，后续结点会从parkAndCheckInterrupt方法中返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// tryReease由子类实现，通过设置state值来达到同步的效果。</span></div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line"></div><div class="line">        Node h = head;</div><div class="line"></div><div class="line">        <span class="comment">// waitStatus为0说明是初始化的空队列</span></div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line"></div><div class="line">            <span class="comment">// 唤醒后续的结点</span></div><div class="line">            unparkSuccessor(h);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * If status is negative (i.e., possibly needing signal) try</div><div class="line">         * to clear in anticipation of signalling.  It is OK if this</div><div class="line">         * fails or if status is changed by waiting thread.</div><div class="line">         */</div><div class="line">        <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line"></div><div class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Thread to unpark is held in successor, which is normally</div><div class="line">         * just the next node.  But if cancelled or apparently null,</div><div class="line">         * traverse backwards from tail to find the actual</div><div class="line">         * non-cancelled successor.</div><div class="line">         */</div><div class="line"></div><div class="line">        Node s = node.next;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            s = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line"></div><div class="line">                    s = t;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line"></div><div class="line">            LockSupport.unpark(s.thread);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="acquireShared共享获取模式"><a href="#acquireShared共享获取模式" class="headerlink" title="acquireShared共享获取模式"></a>acquireShared共享获取模式</h1><p>获取共享锁过程与独占模式基本相同。<br>－ 尝试获取加入队列失败加入队列<br>－ 如果是队首再次获取锁<br>－ 再次失败挂起当前线程，等待被唤醒。<br>与独占模式不同的是成功获取共享锁之后调用setHeadAndPropagate，继续向后遍历队列，寻找相邻的共享节点给予锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="comment">//如果没有许可了则入队等待</span></div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        doAcquireShared(arg);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 添加队列</span></div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 等待前继释放并传递</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">// 尝试获取</span></div><div class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 获取成功则前继出队，跟独占不同的是</span></div><div class="line">                    <span class="comment">// 会往后面结点传播唤醒的操作，保证剩下等待的线程能够尽快 获取到剩下的许可。</span></div><div class="line">                    setHeadAndPropagate(node, r);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    <span class="keyword">if</span> (interrupted)</div><div class="line">                        selfInterrupt();</div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// p != head || r &lt; 0</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setHeadAndPropagate方法会将node设置为head。如果当前结点acquire到了之后发现还有许可可以被获取，则继续释放自己的后继， 后继会将这个操作传递下去。这就是PROPAGATE状态的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</div><div class="line">    Node h = head; <span class="comment">// Record old head for check below</span></div><div class="line">    setHead(node);</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 以下情况尝试唤醒后继的结点：</div><div class="line">     * propagate &gt; 0说明许可还有能够继续被线程acquire;</div><div class="line">     * 或者之前的head被设置为PROPAGATE(PROPAGATE可以被转换为SIGNAL)说明需要往后传递;</div><div class="line">     * 或者为null,我们还不确定什么情况。</div><div class="line">     * 并且后继结点是共享模式或者为如上为null。</div><div class="line">     * 上面的检查有点保守，在有多个线程竞争获取/释放的时候可能会导致不必要的唤醒。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</div><div class="line">        Node s = node.next;</div><div class="line">        <span class="comment">// 后继结是共享模式或者s == null（不知道什么情况）</span></div><div class="line">        <span class="comment">// 如果后继是独占模式，那么即使剩下的许可大于0也不会继续往后传递唤醒操作</span></div><div class="line">        <span class="comment">// 即使后面有结点是共享模式。</span></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</div><div class="line">            <span class="comment">// 唤醒后继结点</span></div><div class="line">            doReleaseShared();</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="comment">// 队列不为空且有后继结点</span></div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="comment">// 不管是共享还是独占只有结点状态为SIGNAL才尝试唤醒后继结点</span></div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="comment">// 将waitStatus设置为0</span></div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></div><div class="line">                unparkSuccessor(h);<span class="comment">// 唤醒后继结点</span></div><div class="line">                <span class="comment">// 如果状态为0则更新状态为PROPAGATE，更新失败则重试</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果过程中head被修改了则重试。</span></div><div class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>参考文章：<a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-AbstractQueuedSynchronizer.html" target="_blank" rel="external">http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-AbstractQueuedSynchronizer.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AbstractQueuedSynchronizer解析（1）]]></title>
      <url>http://baobing.github.io/2016/08/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AbstractQueuedSynchronizer%E8%A7%A3%E6%9E%90%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>不以文害辞,不以辞害志;以意逆志，是为得之。——孟子</p>
</blockquote>
<p>　最近在看ThreadPoolExecutor类的源码。我发现其中一个重要的子类Woker继承自AbstractQueuedSynchronizer（简称AQS）。AQS帮助Woker类轻松实现一个非重入的排它锁。不看不知道一看吓一跳，竟然有11个类继承自AQS，而且这些类都是并发包下面使用频率很高的类。这足以说明这个类的含金量，值得认真研究一下。<br>　<a id="more"></a></p>
<img src="/2016/08/19/并发编程/AbstractQueuedSynchronizer解析（1）/AQSimplement.png" alt="AQS子类" title="AQS子类">
<h1 id="源码注释"><a href="#源码注释" class="headerlink" title="源码注释"></a>源码注释</h1><p>　　为实现依赖于等待队列的阻塞锁和相关同步器（信号量、事件）提供一个框架。此类的设计目标是成为依靠单个原子整形数值来表示状态的大多数同步器的基础。子类必须定义更改此状态的方法，并定义哪种状态对于此对象意味着被获取或被释放。实现这些条件之后，此类中的其他方法就可以实现所有排队和阻塞机制。子类可以维护其他状态字段，但是只有原子更新整形值的应用方法（涉及到同步）被追踪，以下是这三个应用方法 getState()、setState(int) 和compareAndSetState(int, int)。</p>
<p>　　应该将子类定义为非公共内部帮助类，可用它们来实现其内部类的同步属性。AbstractQueuedSynchronizer类 没有实现任何同步接口。而是定义了诸如acquireInterruptibly(int) 之类的方法，在适当的时候可以通过具体的锁和相关同步器调用它们，以达到同步的目的。</p>
<p>　　此类支持默认的独占 模式和共享 模式任何一种方式，也可以同时支持两种模式。处于独占模式下，其他线程不可能再成功获取锁。在共享模式下，多个线程获可能成功获得锁。此类只是机械地感知到在共享模式下成功获取某一锁时，下一个等待线程（如果存在）也必须确定是否可以成功获取该锁。处于不同模式下的等待线程可以共享相同的 FIFO 队列。通常，子类只支持其中一种模式，但两种模式都可以在ReadWriteLock 中发挥作用。只支持独占模式或者只支持共享模式的子类不必定义未使用模式的方法。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>AQS简核心是通过一个共享变量来同步状态，变量的状态由子类去维护，而AQS框架做的是：</p>
<ul>
<li>线程阻塞队列的维护</li>
<li>线程阻塞和唤醒。</li>
</ul>
<p>　　共享变量的修改都是通过CAS操作完成的。AbstractQueuedSynchronizer类是一个典型的模板方法类。它的主要方法是acquire和release。  acquire方法用来获取锁，返回true说明线程获取成功继续执行，一旦返回false则线程加入到等待队列中，等待被唤醒，release方法用来释放锁。 一般来说实现的时候这两个方法被封装为lock和unlock方法。  </p>
<p>下面这4个方法由子类去实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></div></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor-Worker"><a href="#ThreadPoolExecutor-Worker" class="headerlink" title="ThreadPoolExecutor.Worker"></a>ThreadPoolExecutor.Worker</h2><p>下面就来看一下以下Worker的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line">     * Worker类为正在运行任务的线程维护中断状态控制，以及其他次要的工作。该类</div><div class="line"></div><div class="line">     * 通过继承AbstractQueuedSynchronizer类,环绕任务执行加锁，简化锁地获取与释放</div><div class="line"></div><div class="line">     * 过程。不使用中断旨在唤醒唤醒一个等待任务的线程，而不是一个正在运行的任务线程。</div><div class="line"></div><div class="line">     * 我们实现一个简单的不可重入锁,而不是直接使用互斥锁ReentrantLock。因为我们</div><div class="line"></div><div class="line">     * 不希望当他们调用线程池控制方法如setCorePoolSize时，工作者的任务的锁被再次获取。</div><div class="line"></div><div class="line">     * 为了抑制线程真正启动前中断，我们初始化锁的状态为负值，开始时变为正值。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">        <span class="comment">// Lock methods    state是父类AbstractQueuedSynchronizer的字段</span></div><div class="line"></div><div class="line">        <span class="comment">// The value 0 represents the unlocked state.</span></div><div class="line"></div><div class="line">        <span class="comment">// The value 1 represents the locked state.</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//尝试获取当前的worker。重载父类方法，父类中不支持该方法。</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line"></div><div class="line">                setExclusiveOwnerThread(Thread.currentThread());</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//释放当前的worker</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line"></div><div class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line"></div><div class="line">            setState(<span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取失败放入队列，并且线程被中断</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            Thread t;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">                    t.interrupt();</div><div class="line"></div><div class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//原子操作改变锁的状态</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// See below for intrinsics setup to support this</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM4-线程池]]></title>
      <url>http://baobing.github.io/2016/08/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM4-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<h1 id="1、线程池"><a href="#1、线程池" class="headerlink" title="1、线程池"></a>1、线程池</h1><p>优点：将更多的精力放在业务上，不必操心线程的创建和销毁。节省线程创建销毁的时间。<br><a id="more"></a></p>
<h2 id="手写简易ThreadPool"><a href="#手写简易ThreadPool" class="headerlink" title="手写简易ThreadPool"></a>手写简易ThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyThreadPool instance = <span class="keyword">new</span> MyThreadPool();</div><div class="line">    <span class="keyword">private</span> List&lt;Worker&gt; idleThreads;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShutDown =<span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadPool</span><span class="params">()</span></span>&#123;</div><div class="line">        idleThreads = <span class="keyword">new</span> Vector&lt;Worker&gt;(<span class="number">10</span>);</div><div class="line">        threadCounter = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCreatedThreadCount</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> threadCounter;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> MyThreadPool <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> instance;&#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">repool</span><span class="params">(Worker repoolingThread)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(!isShutDown) repoolingThread.shutDown();</div><div class="line">        <span class="keyword">else</span> idleThreads.add(repoolingThread);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span></span>&#123;</div><div class="line">        isShutDown = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span>(Worker worker : idleThreads)  worker.shutDown();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Runnable target)</span></span>&#123;</div><div class="line">        Worker thread = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(idleThreads.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> lastIndex = idleThreads.size()-<span class="number">1</span>;</div><div class="line">            thread = (Worker) idleThreads.get(lastIndex);</div><div class="line">            idleThreads.remove(lastIndex);</div><div class="line">            thread.setTarget(target);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> MyThreadPool pool;</div><div class="line">        <span class="keyword">private</span> Runnable target;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isIdle = <span class="keyword">false</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span>  <span class="title">Worker</span><span class="params">(Runnable target, String name , MyThreadPool pool)</span></span>&#123;</div><div class="line">            <span class="keyword">super</span>(name);</div><div class="line">            <span class="keyword">this</span>.pool = pool;</div><div class="line">            <span class="keyword">this</span>.target =target;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> Runnable <span class="title">getTarget</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  target;&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Runnable target)</span></span>&#123;<span class="keyword">this</span>.target = target;&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIdle</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> isIdle;&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.isShutdown = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">while</span> (!isShutdown)&#123;</div><div class="line">                isIdle =<span class="keyword">false</span>;</div><div class="line">                <span class="keyword">if</span>(target != <span class="keyword">null</span>) target.run();</div><div class="line">                isIdle = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    pool.repool(<span class="keyword">this</span>);</div><div class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</div><div class="line">                        wait();</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="线程池重要接口"><a href="#线程池重要接口" class="headerlink" title="线程池重要接口"></a>线程池重要接口</h1><img src="/2016/08/12/并发编程/GYM4-线程池/ExcutorService.jpg" alt="图一" title="图一">
<h2 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h2><p>　　执行已提交的 Runnable 任务的对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法。通常使用 Executor 而不是显式地创建线程。例如，可能会使用以下方法，而不是为一组任务中的每个任务调用 new Thread(new(RunnableTask())).start()：</p>
<h2 id="ExecuteService"><a href="#ExecuteService" class="headerlink" title="ExecuteService"></a>ExecuteService</h2><p>　　Executor提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。<br>　　可以关闭 ExecutorService，这将导致其拒绝新任务。提供两个方法来关闭 ExecutorService。shutdown() 方法在终止前允许执行以前提交的任务，而 shutdownNow() 方法阻止等待任务启动并试图停止当前正在执行的任务。在终止时，执行程序没有任务在执行，也没有任务在等待执行，并且无法提交新任务。应该关闭未使用的 ExecutorService 以允许回收其资源。<br>　　通过创建并返回一个可用于取消执行和/或等待完成的 Future，方法 submit 扩展了基本方法 Executor.execute(java.lang.Runnable)。方法 invokeAny 和 invokeAll 是批量执行的最常用形式，它们执行任务 collection，然后等待至少一个，或全部任务完成（可使用 ExecutorCompletionService 类来编写这些方法的自定义变体）。</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>　　类提供了用于此包中所提供的执行程序服务的工厂方法。</p>
<h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><h2 id="ThreadPoolExecutor-参数"><a href="#ThreadPoolExecutor-参数" class="headerlink" title="ThreadPoolExecutor 参数"></a>ThreadPoolExecutor 参数</h2><p>Executors.ThreadPoolExecutor的参数不同实现不同的线程池<br>1）corePoolSize 核心线程池标准数量<br>2）maximumPoolSize 线程池最大尺寸<br>3）keepAliceTime 超过标准数量，空闲线程存活时间<br>4）TimeUnit 时间单位<br>5）BlockingQueue<runnable> 保存没有执行的线程<br>6）RejectedExecutionHandler 持有拒绝策略，非必填<br>7）ThreadFactory</runnable></p>
<h2 id="不同参数的不同线程池"><a href="#不同参数的不同线程池" class="headerlink" title="不同参数的不同线程池"></a>不同参数的不同线程池</h2><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>(n,n,0, SECONDS,LinkedBlockingQueue<runnable>)</runnable></p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>(1,1,0L,s,LinkedBlockingQueue<runnable>)</runnable></p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>(0,MAX,60,SECONDS,SychronousQueue)<br>SynchronousQueue 容量为零，60s后线程被销毁,容量可扩张</p>
<h3 id="newSingleThreadExecutor-1"><a href="#newSingleThreadExecutor-1" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">    executorService.scheduleWithFixedDelay(</div><div class="line">            <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName());</div><div class="line">                &#125;</div><div class="line">            &#125;,<span class="number">2</span>,<span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadPoolExecutor的子类ScheduledThreadPoolExecutor实现</p>
<p>##　ExecutorServeice<br>submit();提交Callable 返回Future<br>execute();提交Runnbale 不返回</p>
<h1 id="线程池的扩展"><a href="#线程池的扩展" class="headerlink" title="线程池的扩展"></a>线程池的扩展</h1><h2 id="增强接口"><a href="#增强接口" class="headerlink" title="增强接口"></a>增强接口</h2><ul>
<li>beforeExecute()</li>
<li>afterExecute()</li>
<li>terminated()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ExecutorService service = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>, TimeUnit.SECONDS,</div><div class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"ready "</span> + ((MyTask) r).name);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">        service.execute(<span class="keyword">new</span> MyTask(String.valueOf(i)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##　拒绝策略<br>缓冲队列不可能无限大，防止任务十分繁重导致的内存溢出和其他错误。<br>RejectedExecutionHandler接口持有拒绝策略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的实现类主要有以下几种</p>
<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p>直接拒绝任务，拒绝任务时会抛出RejectedExecutorException</p>
<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>丢弃任务，什么都不做</p>
<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>调用线程池的线程完成任务，不再使用线程池中的线程。直接调用请求Runnable的run()方法。</p>
<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p> 重线程池队列中选取最老的线程丢弃</p>
<h2 id="自定义线程工厂"><a href="#自定义线程工厂" class="headerlink" title="自定义线程工厂"></a>自定义线程工厂</h2><p>ThreadFactory接口。构建新的线程。实现者同时也初始化优先级，线程名称，守护状态等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</div><div class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="ThreadPoolExecutor-1"><a href="#ThreadPoolExecutor-1" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><h2 id="ctl属性"><a href="#ctl属性" class="headerlink" title="ctl属性"></a>ctl属性</h2><p>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));<br>后28为表示线程数量前四位表示线程装填,最高的三位表示不同的状态：</p>
<ul>
<li>111 RUNNING 正在运行</li>
<li>000 SHUTDOWN 不再接收任务，队列中任务继续处理</li>
<li>001 STOP 不接受新的任务忙不处理队列中的任务，中断正在处理的任务</li>
<li>010 TIDYING 整理 所有线程终结，workerCount设置为0， terminated()方法运行的过渡状态</li>
<li>011 TERMINATED terminated()方法运行完毕<br>剩下的29位表示有效线程的数量</li>
</ul>
<h2 id="execut"><a href="#execut" class="headerlink" title="execut()"></a>execut()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"><span class="comment">/* 如果正在运行的线程小于corePoolSize 。尝试创建新的线程执行当前任务。 调用addWroker方法时，</span></div><div class="line">     会利用原子操作检查运行状态和有效线程数量 ，以防止之不应该添加线程时发生失败警告*/</div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line"><span class="comment">/* 没有使用锁进行同步，加入工作线程和加入队列函数必须进行再次检查。*/</span></div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="comment">//双重检查，如果线程池关闭，则移除加入的任务</span></div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;<span class="comment">//加入队列失败则开启新的线程，不受核心线程数限制，而是最大线程数限制</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Fork-Join-线程池"><a href="#Fork-Join-线程池" class="headerlink" title="Fork/Join 线程池"></a>Fork/Join 线程池</h1><p>将大任务分成小任务，最终将结果整理,分治思想。等待子任务完成。每个子任务不一定需要创建新的线程，而是利用线程中的线程。<br>fork 拆分任务。join等待任务完成。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>从性能角度看，Fork/Join适合处理子任务比较复杂的情况。否则的话开辟线程的时间开销会比大于分治节省的时间，得不偿失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.start = start;</div><div class="line">        <span class="keyword">this</span>.end = end;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">compute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (end - start &lt;= <span class="number">10000</span>)&#123;</div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i= start;i&lt;=end;i++) sum += i;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">            CountTask left = <span class="keyword">new</span> CountTask(start,mid);</div><div class="line">            CountTask right = <span class="keyword">new</span> CountTask(mid+<span class="number">1</span>,end);</div><div class="line">            <span class="comment">//执行子任务</span></div><div class="line">            left.fork();</div><div class="line">            right.fork();</div><div class="line">            <span class="comment">//等待子任务完成</span></div><div class="line">            sum = (<span class="keyword">int</span>)left.join() +  (<span class="keyword">int</span>)right.join();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    Long start = System.currentTimeMillis();</div><div class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</div><div class="line">    CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, n);</div><div class="line">    Future result = forkJoinPool.submit(task);</div><div class="line">    System.out.println(result.get());</div><div class="line">    Long mid = System.currentTimeMillis();</div><div class="line">    System.out.println(mid - start);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,sum = <span class="number">0</span>; i &lt;= n; i++) sum += i;</div><div class="line">    System.out.println(System.currentTimeMillis() - mid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h2><h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><h3 id="ctl属性-1"><a href="#ctl属性-1" class="headerlink" title="ctl属性"></a>ctl属性</h3><p>　　使用一个long型整数保存五个变量，AC（16位保存活跃线程数减去并行度）、TC（16位保存总共的线程数减去并行度）、ST（1位保存线程池是否终结）、EC（15位保存栈顶端ForkJoinTask的eventCount）、ID（15位记录栈顶端ForkJoinTask的poolIndex属性）<br>　　使用一个long型整数表示5个变量并不会节省很多空间，而且大大降低了代码的可读性。仍然这么用的目的是同时保持五个变量的线程安全和并发性能。通过与无锁操作配合提升性能。</p>
<h3 id="scan"><a href="#scan" class="headerlink" title="scan()"></a>scan()</h3><h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker()"></a>runWorker()</h3><h3 id="帮助策略"><a href="#帮助策略" class="headerlink" title="帮助策略"></a>帮助策略</h3><p>自己从top取 别人从Base取 减少冲突。均匀分配任务。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>RecursiveAction 无返回值<br>RecursiveTask    有返回值</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SynchronousQueue源码解析]]></title>
      <url>http://baobing.github.io/2016/08/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/SynchronousQueue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h1><p>　　SychronousQueue类的大部分代码都交给Transfer内部类的两个子类ThransferQueue和ThransferStack完成。我只写关于ThransferStack的代码。<br>　　<a id="more"></a></p>
<p>这两个子类使用非阻塞无锁操作实现，理解起来有些困难。无锁是提高性能的重要手段，与此同时它让代码变得复杂。接下来要自己动手写无锁操作，增加对无锁操作的理解</p>
<blockquote>
<p><a href="http://www.tuicool.com/articles/aYrEZf" target="_blank" rel="external">http://www.tuicool.com/articles/aYrEZf</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。队列的头 是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），SynchronousQueue 作为一个空 collection。此队列不允许 null元素。</p>
<p>　　同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p>
<p>　　对于正在等待的生产者和使用者线程而言，此类支持可选的公平排序策略。默认情况下不保证这种排序。但是，使用公平设置为 true 所构造的队列可保证线程以 FIFO 的顺序进行访问。</p>
<h2 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h2><p> public E take() throws InterruptedException {</p>
<pre><code>    E e = transferer.transfer(null, false, 0);

    if (e != null)

        return e;

    Thread.interrupted();

    throw new InterruptedException();

}
</code></pre><h2 id="TransferStack类"><a href="#TransferStack类" class="headerlink" title="TransferStack类"></a>TransferStack类</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static final int REQUEST    = 0; //代表未完成的消费者</div><div class="line"></div><div class="line">static final int DATA       = 1;     //代表未完成的生产者</div><div class="line"></div><div class="line">static final int FULFILLING = 2; //已经完成状态</div><div class="line"></div><div class="line">volatile SNode head;               //栈的顶端</div></pre></td></tr></table></figure>
<h3 id="transfer操作"><a href="#transfer操作" class="headerlink" title="transfer操作"></a>transfer操作</h3><p>图片是粗略的过程，很多东西无法表示，还是看源码。无锁操作还是要看好几遍才能领会作者的意图，加油吧少年！！</p>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * 放置或者获取一个节点</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></div><div class="line"></div><div class="line">    <span class="comment">//节点e为null，代表这是一个消费者，否则它是一个生产者</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line"></div><div class="line">        SNode h = head;</div><div class="line"></div><div class="line">        <span class="comment">//同为消费者或者生产者</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait 不允许等待</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())<span class="comment">//栈顶节点请求已取消</span></div><div class="line"></div><div class="line">                    casHead(h, h.next);     <span class="comment">// pop cancelled node</span></div><div class="line"></div><div class="line">                <span class="keyword">else</span></div><div class="line"></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="comment">//允许等待，尝试将e设置为栈顶，失败就继续循环尝试。</span></div><div class="line"></div><div class="line">            <span class="comment">//如果栈顶元素正在处理，说明栈顶元素找到自己匹配对象（看不懂跳过）</span></div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</div><div class="line"></div><div class="line">                <span class="comment">//返回s的匹配元素</span></div><div class="line"></div><div class="line">                SNode m = awaitFulfill(s, timed, nanos);</div><div class="line"></div><div class="line">                <span class="comment">//m == s 说明被取消，等待时间截止未出现匹配元素</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></div><div class="line"></div><div class="line">                    clean(s);</div><div class="line"></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//新的节点覆盖s节点，移除s</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</div><div class="line"></div><div class="line">                    casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></div><div class="line"></div><div class="line">                <span class="comment">//返回生产者的item</span></div><div class="line"></div><div class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></div><div class="line"></div><div class="line">            <span class="comment">//颜色不同且栈顶元素未被处理</span></div><div class="line"></div><div class="line">            <span class="comment">//栈顶元素被取消，移除栈顶元素</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></div><div class="line"></div><div class="line">                casHead(h, h.next);         <span class="comment">// pop and retry</span></div><div class="line"></div><div class="line">            <span class="comment">//将s放入栈顶，并且设置为正在处理</span></div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</div><div class="line"></div><div class="line">    ﻿    ﻿    ﻿    ﻿    ﻿<span class="comment">//栈中元素有可能时间到达，所以要循环遍历</span></div><div class="line"></div><div class="line">                <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></div><div class="line"></div><div class="line">                    SNode m = s.next;       <span class="comment">// m is s's match</span></div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></div><div class="line"></div><div class="line">                        casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></div><div class="line"></div><div class="line">                        s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    SNode mn = m.next;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) &#123;</div><div class="line"></div><div class="line">                        casHead(s, mn);     <span class="comment">// pop both s and m</span></div><div class="line"></div><div class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></div><div class="line"></div><div class="line">                        s.casNext(m, mn);   <span class="comment">// help unlink</span></div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></div><div class="line"></div><div class="line">            <span class="comment">//栈顶元素正在处理，帮助栈顶处理</span></div><div class="line"></div><div class="line">            SNode m = h.next;               <span class="comment">// m is h's match</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></div><div class="line"></div><div class="line">                casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></div><div class="line"></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                SNode mn = m.next;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></div><div class="line"></div><div class="line">                    casHead(h, mn);         <span class="comment">// pop both h and m</span></div><div class="line"></div><div class="line">                <span class="keyword">else</span>                        <span class="comment">// lost match</span></div><div class="line"></div><div class="line">                    h.casNext(m, mn);       <span class="comment">// help unlink</span></div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="awaitFulfill操作"><a href="#awaitFulfill操作" class="headerlink" title="awaitFulfill操作"></a>awaitFulfill操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">//计算等待终结时间，naoTime()函数更加精确</span></div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</div><div class="line"></div><div class="line">            Thread w = Thread.currentThread();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> spins = (shouldSpin(s) ?</div><div class="line"></div><div class="line">                         (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (w.isInterrupted()) <span class="comment">//线程中断，取消s节点</span></div><div class="line"></div><div class="line">                    s.tryCancel();</div><div class="line"></div><div class="line">                SNode m = s.match;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (m != <span class="keyword">null</span>) <span class="comment">//匹配成功返回</span></div><div class="line"></div><div class="line">                    <span class="keyword">return</span> m;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (timed) &#123;</div><div class="line"></div><div class="line">                    nanos = deadline - System.nanoTime();</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123; <span class="comment">//截止时间到达，取消当前线程的SNode</span></div><div class="line"></div><div class="line">                        s.tryCancel();</div><div class="line"></div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//线程挂起</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</div><div class="line"></div><div class="line">﻿                    spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</div><div class="line"></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                    s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></div><div class="line"></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!timed) <span class="comment">//无限期等待</span></div><div class="line"></div><div class="line">                    LockSupport.park(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</div><div class="line"></div><div class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PriorityBlockingQueue源码解析]]></title>
      <url>http://baobing.github.io/2016/08/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/PriorityBlockingQueue/</url>
      <content type="html"><![CDATA[<pre><code>优先阻塞队列，一定会涉及优先队列的实现,而且是平衡优先队列。一起看看Doug Lea大师是怎么做的。
</code></pre><a id="more"></a>
<h1 id="PriorityBlockingQueue和"><a href="#PriorityBlockingQueue和" class="headerlink" title="PriorityBlockingQueue和"></a>PriorityBlockingQueue和</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　一个无界阻塞队列，它使用与类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致 OutOfMemoryError）。此类不允许使用 null 元素。依赖自然顺序的优先级队列也不允许插入不可比较的对象（这样做会导致抛出 ClassCastException）。</p>
<p>　　此类及其迭代器可以实现 Collection 和 Iterator 接口的所有可选 方法。iterator() 方法中提供的迭代器并不 保证以特定的顺序遍历 PriorityBlockingQueue 的元素。如果需要有序地进行遍历，则应考虑使用 Arrays.sort(pq.toArray())。此外，可以使用方法 drainTo 按优先级顺序移除 全部或部分元素，并将它们放在另一个 collection 中。</p>
<p>　　在此类上进行的操作不保证具有同等优先级的元素的顺序。如果需要实施某一排序，那么可以定义自定义类或者比较器，比较器可使用修改键断开主优先级值之间的联系。例如，以下是应用先进先出 (first-in-first-out) 规则断开可比较元素之间联系的一个类。要使用该类，则需要插入一个新的FIFOEntry(anEntry) 来替换普通的条目对象。</p>
<p>##属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//优先队列用平衡二叉堆表示：queue[n] queue[2*n+1]和queue[2*(n+1)]。最小堆。</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</div><div class="line"></div><div class="line"><span class="comment">//优先队列元素个数</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"><span class="comment">//比较器</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</div><div class="line"></div><div class="line"><span class="comment">//所有public方法的锁</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</div><div class="line"></div><div class="line"><span class="comment">//分配自旋锁通过CAS获取</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</div><div class="line"></div><div class="line"><span class="comment">//兼容以前的版本，序列化和反序列化使用</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</div></pre></td></tr></table></figure>
<h2 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</div><div class="line"></div><div class="line">        offer(e); <span class="comment">// never need to block</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line"></div><div class="line">        lock.lock();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n, cap;</div><div class="line"></div><div class="line">        Object[] array;</div><div class="line"></div><div class="line">        <span class="comment">//优先队列数组装满需要扩容，扩容可能失败，需要循环</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</div><div class="line"></div><div class="line">            tryGrow(array, cap);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</div><div class="line"></div><div class="line">           <span class="comment">//将元素插入优先队列</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                siftUpComparable(n, e, array);</div><div class="line"></div><div class="line">            <span class="keyword">else</span></div><div class="line"></div><div class="line">                siftUpUsingComparator(n, e, array, cmp);</div><div class="line"></div><div class="line">            size = n + <span class="number">1</span>;</div><div class="line"></div><div class="line">            notEmpty.signal();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">            lock.unlock();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="comment">//优先队列扩容。考虑到有可能扩容过程中有消费线程获取元素，可以在不扩容</span></div><div class="line"></div><div class="line"><span class="comment">//的前提下继续使用队列。增加吞吐量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="comment">//我猜是为了消费者线程可以继续消费，增加并发量</span></div><div class="line"></div><div class="line">        lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></div><div class="line"></div><div class="line">        Object[] newArray = <span class="keyword">null</span>; </div><div class="line"></div><div class="line">       <span class="comment">//获取到偏向锁标志位的才能扩容，使用CAS操作</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</div><div class="line"></div><div class="line">            UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</div><div class="line"></div><div class="line">                                     <span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123; <span class="comment">//oldCap容量小于64扩展一倍加二，其他情况扩展一半</span></div><div class="line"></div><div class="line">                <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</div><div class="line"></div><div class="line">                                       (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></div><div class="line"></div><div class="line">                                       (oldCap &gt;&gt; <span class="number">1</span>));<span class="comment">//边界检查还是很重要的防止内存泄漏</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></div><div class="line"></div><div class="line">                    <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</div><div class="line"></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line"></div><div class="line">                    newCap = MAX_ARRAY_SIZE;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</div><div class="line"></div><div class="line">                    newArray = <span class="keyword">new</span> Object[newCap];</div><div class="line"></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">                allocationSpinLock = <span class="number">0</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;<span class="comment">//其他线程还是有机会提前扩容新的数组</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></div><div class="line"></div><div class="line">            Thread.yield();</div><div class="line"></div><div class="line">        lock.lock(); <span class="comment">//数组copy</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</div><div class="line"></div><div class="line">            queue = newArray;</div><div class="line"></div><div class="line">            System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//优先队列（最小堆）平衡插入。k代表数组中元素个数。</span></div><div class="line"></div><div class="line">   <span class="comment">//插入过程，将元素放在平衡堆的最后一个位置，父节点大于当前节点</span></div><div class="line"></div><div class="line">   <span class="comment">//交换位置，递归重复这个过程。</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</div><div class="line"></div><div class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//父节点下标</span></div><div class="line"></div><div class="line">            Object e = array[parent];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>) <span class="comment">//大于父节点循环终止</span></div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            array[k] = e;</div><div class="line"></div><div class="line">            k = parent;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        array[k] = key;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="take-操作"><a href="#take-操作" class="headerlink" title="take 操作"></a>take 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line"></div><div class="line">    lock.lockInterruptibly();</div><div class="line"></div><div class="line">    E result;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">            notEmpty.await();</div><div class="line"></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">        lock.unlock();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//持有锁才可以访问，堆中第一个元素为最小</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        Object[] array = queue;</div><div class="line"></div><div class="line">        E result = (E) array[<span class="number">0</span>];</div><div class="line"></div><div class="line">        E x = (E) array[n];</div><div class="line"></div><div class="line">        array[n] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</div><div class="line"></div><div class="line">        <span class="keyword">else</span></div><div class="line"></div><div class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</div><div class="line"></div><div class="line">        size = n;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//堆的头元素被去掉，头元素作为Z，选取头元素较小的子节点占据头结点位置。</span></div><div class="line"></div><div class="line"><span class="comment">//将头元素较小子节点作为Z重复这个过程，直到Z小于队列最后一个元素key，</span></div><div class="line"></div><div class="line"><span class="comment">//或者Z没有子节点。将key放置到Z的位置。</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></div><div class="line"></div><div class="line">            Object c = array[child];</div><div class="line"></div><div class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp;  <span class="comment">//左子节点大于右子节点</span></div><div class="line"></div><div class="line">                ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</div><div class="line"></div><div class="line">                c = array[child = right]; <span class="comment">//c等于两个子节点中的较小值</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)<span class="comment">//如果key小于c停止循环</span></div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            array[k] = c;</div><div class="line"></div><div class="line">            k = child;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        array[k] = key;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>　　一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。队列的头 是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），SynchronousQueue 作为一个空 collection。此队列不允许 null元素。</p>
<p>　　同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p>
<p>　　对于正在等待的生产者和使用者线程而言，此类支持可选的公平排序策略。默认情况下不保证这种排序。但是，使用公平设置为 true 所构造的队列可保证线程以 FIFO 的顺序进行访问。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ArrayBlockingQueue和LinkedBlockingQueue]]></title>
      <url>http://baobing.github.io/2016/08/03/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ArrayBlockingQueue%E5%92%8CLinkedBlockingQueue/</url>
      <content type="html"><![CDATA[<p>两点疑问没有解决：</p>
<p>1、为什么ArrayBlockingQueue不使用takeLock、putLock的双锁机制？使用这种锁分离的策略明显效率更高。</p>
<p>2、为什么判断是否存在剩余空间，使用while 而不是if？难道作者怕出现意外，但是什么时候会出现意外呢？<br><a id="more"></a></p>
<h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p>　　一个数组组成的有界阻塞队列，保持队列基本特性先进先出。<br>　　此类对等待的生产者线程和使用者线程进行排序的公平策略选项提供支持。默认情况下，不保证是这种排序策略。通过将fairness设置为true构造的队列允许按照FIFO顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。公平性的保证是通过ReentrantLock的公平锁实现。阻塞超时通过Condition的awaitNanos实现。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//保存队列的数组，循环使用数组。泛型是不能使用数组</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> Object[] items; </div><div class="line"></div><div class="line">    <span class="keyword">int</span> takeIndex;<span class="comment">//下一次移除元素所在下标</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> putIndex; <span class="comment">//下一次添加元素所在下标</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> count;      <span class="comment">//队列中元素数量</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> ReentrantLock lock; <span class="comment">//重入锁保证线程安全</span></div><div class="line"></div><div class="line">    <span class="comment">//Condition的await相当于Object提供的wait</span></div><div class="line"></div><div class="line">    <span class="comment">//signals相当于notify方法</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty; <span class="comment">//获取元素线程使用</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull; <span class="comment">//放置元素线程使用</span></div></pre></td></tr></table></figure>
<h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        checkNotNull(e); <span class="comment">//不能放入null</span></div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; </div><div class="line"></div><div class="line">        lock.lockInterruptibly(); <span class="comment">//中断异常交给调用者处理</span></div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">//整个数组被填满，线程阻塞。为什么用while而不用if语句？</span></div><div class="line"></div><div class="line">        <span class="comment">//难道是为了方式被唤醒时队列再次被填满。但是当前线程占用锁，</span></div><div class="line"></div><div class="line">        <span class="comment">//不可能有其他线程调用put方法并且成功添加元素。</span></div><div class="line"></div><div class="line">         <span class="comment">//想想肯定有不使用lock的方法添加元素成功。</span></div><div class="line"></div><div class="line">         <span class="comment">//如果真有这样的方法它一定不是线程安全的。往下看吧- -!</span></div><div class="line"></div><div class="line">            <span class="keyword">while</span> (count == items.length)</div><div class="line"></div><div class="line">                notFull.await();</div><div class="line"></div><div class="line">            enqueue(e);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">            lock.unlock();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//插入元素到指定位置，放置下标前移，发出非空信号量 。持有锁才能调用</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line"></div><div class="line">        items[putIndex] = x;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (++putIndex == items.length)<span class="comment">//循环使用数组</span></div><div class="line"></div><div class="line">            putIndex = <span class="number">0</span>;</div><div class="line"></div><div class="line">        count++;</div><div class="line"></div><div class="line">        notEmpty.signal();<span class="comment">//发出非空信号</span></div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line"></div><div class="line">        lock.lockInterruptibly();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;<span class="comment">//队列为空等待</span></div><div class="line"></div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line"></div><div class="line">                notEmpty.await();</div><div class="line"></div><div class="line">            <span class="keyword">return</span> dequeue();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">            lock.unlock();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line"></div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"></div><div class="line">        E x = (E) items[takeIndex]; <span class="comment">//Object转泛型</span></div><div class="line"></div><div class="line">        items[takeIndex] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (++takeIndex == items.length)<span class="comment">//循环数组</span></div><div class="line"></div><div class="line">            takeIndex = <span class="number">0</span>;</div><div class="line"></div><div class="line">        count--;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</div><div class="line"></div><div class="line">            itrs.elementDequeued();</div><div class="line"></div><div class="line">        notFull.signal();<span class="comment">//发出非空通知</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> x;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="drainTo操作"><a href="#drainTo操作" class="headerlink" title="drainTo操作"></a>drainTo操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</div><div class="line"></div><div class="line">       checkNotNull(c);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (c == <span class="keyword">this</span>)</div><div class="line"></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</div><div class="line"></div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">       <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line"></div><div class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line"></div><div class="line">       lock.lock();</div><div class="line"></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">           <span class="keyword">int</span> n = Math.min(maxElements, count);</div><div class="line"></div><div class="line">           <span class="keyword">int</span> take = takeIndex;</div><div class="line"></div><div class="line">           <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">               <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">//有add存在不能保证n的正确性</span></div><div class="line"></div><div class="line">                   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"></div><div class="line">                   E x = (E) items[take];</div><div class="line"></div><div class="line">                   c.add(x);</div><div class="line"></div><div class="line">                   items[take] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (++take == items.length)<span class="comment">//循环添加</span></div><div class="line"></div><div class="line">                       take = <span class="number">0</span>;</div><div class="line"></div><div class="line">                   i++;</div><div class="line"></div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="keyword">return</span> n;</div><div class="line"></div><div class="line">           &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">               <span class="comment">// Restore invariants even if c.add() threw</span></div><div class="line"></div><div class="line">               <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">                   count -= i;</div><div class="line"></div><div class="line">                   takeIndex = take;<span class="comment">//下一次获取元素的位置</span></div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                       <span class="keyword">if</span> (count == <span class="number">0</span>)</div><div class="line"></div><div class="line">                           itrs.queueIsEmpty();</div><div class="line"></div><div class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; take)</div><div class="line"></div><div class="line">                           itrs.takeIndexWrapped();</div><div class="line"></div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); i--)</div><div class="line"></div><div class="line">                       notFull.signal();<span class="comment">//取走多个元素可以发出多个未满信号</span></div><div class="line"></div><div class="line">               &#125;</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">           lock.unlock();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>　　一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO（先进先出）排序元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。链表动态分配空间可以处理更多的节点，但是动态分配空间会两份一些时间。<br>　　可选的容量范围构造方法参数作为防止队列过度扩展的一种方法。如果未指定容量，则它等于 Integer.MAX_VALUE。除非插入节点会使队列超出容量，否则每次插入后会动态地创建链接节点。<br>与ArrayBlockingQueue的不同点1）一个使用数组，固定大小，一个使用链表,非固定大小，最大是int最大值2）LinkedBlockingQueue使用锁分离策略，正类包含takeLock和putLock两把锁，提高了并发效率。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private final int capacity;//记录队列容量</div><div class="line"></div><div class="line">//使用原子整数记录当前队列中元素的个数</div><div class="line"></div><div class="line">private final AtomicInteger count = new AtomicInteger();</div><div class="line"></div><div class="line">transient Node&lt;E&gt; head;//头部元素</div><div class="line"></div><div class="line">private transient Node&lt;E&gt; last;//尾部元素</div><div class="line"></div><div class="line">//获取头部元素锁和</div><div class="line"></div><div class="line">private final ReentrantLock takeLock = new ReentrantLock();</div><div class="line"></div><div class="line">private final Condition notEmpty = takeLock.newCondition();</div><div class="line"></div><div class="line">  //插入尾部元素锁</div><div class="line"></div><div class="line">private final ReentrantLock putLock = new ReentrantLock();</div><div class="line"></div><div class="line">private final Condition notFull = putLock.newCondition();</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public LinkedBlockingQueue(int capacity) &#123;</div><div class="line"></div><div class="line">    if (capacity &lt;= 0) throw new IllegalArgumentException();</div><div class="line"></div><div class="line">    this.capacity = capacity;</div><div class="line"></div><div class="line">    last = head = new Node&lt;E&gt;(null);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看出初始化的时候LBQ含有一个Node节点,头指针和尾指针都指向它，count=0。也就是说LBQ一直包含一个多余的Node节点。</p>
<h2 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line"></div><div class="line">       if (e == null) throw new NullPointerException();</div><div class="line"></div><div class="line">       int c = -1;</div><div class="line"></div><div class="line">       Node&lt;E&gt; node = new Node&lt;E&gt;(e);</div><div class="line"></div><div class="line">       final ReentrantLock putLock = this.putLock;</div><div class="line"></div><div class="line">      //putLock锁住以后队列中元素个数只会减小不会增大</div><div class="line"></div><div class="line">       final AtomicInteger count = this.count;</div><div class="line"></div><div class="line">       putLock.lockInterruptibly();//锁住put锁</div><div class="line"></div><div class="line">       try &#123;</div><div class="line"></div><div class="line">           while (count.get() == capacity) &#123;</div><div class="line"></div><div class="line">               notFull.await();</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">           enqueue(node);</div><div class="line"></div><div class="line">       //原子操作保证take与put不会导致线程安全问题</div><div class="line"></div><div class="line">           c = count.getAndIncrement();</div><div class="line"></div><div class="line">           if (c + 1 &lt; capacity)</div><div class="line"></div><div class="line">               notFull.signal();</div><div class="line"></div><div class="line">       &#125; finally &#123;</div><div class="line"></div><div class="line">           putLock.unlock();</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (c == 0)</div><div class="line"></div><div class="line">           signalNotEmpty();</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   private void enqueue(Node&lt;E&gt; node) &#123;</div><div class="line"></div><div class="line">       last = last.next = node;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>需要公平机制来避免消费者、生产者饥饿，这时使用ABQ再好不过了。</p>
</li>
<li><p>如果队列的大小是有界的话，首选还是ABQ，ABQ的性能更好，不需要申请空间。否则还是LBQ吧！LBQ可以接受突入起来的大量生产者。</p>
</li>
<li>阻塞队列的效率某些场景的效率会低于非阻塞，下一次再写关于非阻塞队列CourrentLinkedQueue</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BlockingQueue接口]]></title>
      <url>http://baobing.github.io/2016/08/03/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/BlockingQueue%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>　　支持两个附加操作的 Queue，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。<br>　　<a id="more"></a><br>　　BlockingQueue 不接受 null 元素。试图 add、put 或 offer 一个 null 元素时，某些实现会抛出 NullPointerException。null 被用作指示 poll 操作失败的警戒值。<br>　　BlockingQueue 可以是限定容量的。它在任意给定时间都可以有一个 remainingCapacity，超出此容量，便无法无阻塞地 put 附加元素。没有任何内部容量约束的 BlockingQueue 总是报告 Integer.MAX_VALUE 的剩余容量。<br>　　BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。<br>　　BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和 removeAll）没有 必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，addAll(c) 有可能失败（抛出一个异常）。<br>　　BlockingQueue 实质上不 支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的 end-of-stream 或 poison 对象，并根据使用者获取这些对象的时间来对它们进行解释。</p>
<p>队列为空或者队列没有空间时的处理：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:right">返回特殊值</th>
<th style="text-align:right">阻塞</th>
<th style="text-align:right">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:right">offer(e)</td>
<td style="text-align:right">put(e)</td>
<td style="text-align:right">offer(e,time,unit)</td>
</tr>
<tr>
<td>删除</td>
<td style="text-align:center">remove()</td>
<td style="text-align:right">poll()</td>
<td style="text-align:right">take()</td>
<td style="text-align:right">poll(time,unit)</td>
</tr>
<tr>
<td>查看</td>
<td style="text-align:center">element()</td>
<td style="text-align:right">peek()</td>
<td style="text-align:right">不可用</td>
<td style="text-align:right">不可用</td>
</tr>
</tbody>
</table>
<h2 id="源码加注解"><a href="#源码加注解" class="headerlink" title="源码加注解"></a>源码加注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，</div><div class="line"></div><div class="line">     * 如果当前没有可用的     空间，则抛出 IllegalStateException。</div><div class="line"></div><div class="line">     * 当使用有容量限制的队列时，通常首选 offer。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，</div><div class="line"></div><div class="line">     * 如果当前没有可用的空间，则返回 false。当使用有容量限制的队列时，此方法通</div><div class="line"></div><div class="line">     * 常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 将指定元素插入此队列中，将等待可用的空间（如果有必要）。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 将指定元素插入此队列中，在到达指定的等待时间前等待可用的空间（如果有必要）。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的</div><div class="line"></div><div class="line">     * 附加元素数量；如果没有内部限制，则返回 Integer.MAX_VALUE。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 从此队列中移除指定元素的单个实例（如果存在）。更确切地讲，</div><div class="line"></div><div class="line">     * 如果此队列包含一个或多个满足 o.equals(e) 的元素 e，则移除</div><div class="line"></div><div class="line">     * 该元素。如果此队列包含指定元素（或者此队列由于调用而发生</div><div class="line"></div><div class="line">     * 更改），则返回 true。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 如果此队列包含指定元素，则返回 true。更确切地讲，当且仅当此</div><div class="line"></div><div class="line">     * 队列至少包含一个满足 o.equals(e) 的元素 e时，返回 true。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</div><div class="line"></div><div class="line">     * 此操作可能比反复轮询此队列更有效。在试图向 collection c 中添加元素</div><div class="line"></div><div class="line">     * 没有成功时，可能导致在抛出相关异常时，元素会同时在两个 collection</div><div class="line"></div><div class="line">     * 中出现，或者在其中一个 collection 中出现，也可能在两个 collection </div><div class="line"></div><div class="line">     * 中都不出现。如果试图将一个队列放入自身队列中，则会导致</div><div class="line"></div><div class="line">     * IllegalArgumentException 异常。此外，如果正在进行此操作时修改</div><div class="line"></div><div class="line">     * 指定的 collection，则此操作行为是不确定的。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 </div><div class="line"></div><div class="line">     * collection 中。与上个函数相同。</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="/2016/08/03/ArrayBlockingQueue和LinkedBlockingQueue/">BlockingQueue实现类1:ArrayBlockingQueue和LinkedBlockingQueue</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM3-无锁]]></title>
      <url>http://baobing.github.io/2016/07/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM3-%E6%97%A0%E9%94%81/</url>
      <content type="html"><![CDATA[<h1 id="CAS-compare-and-swap"><a href="#CAS-compare-and-swap" class="headerlink" title="CAS compare and swap"></a>CAS compare and swap</h1><p>线程切换线程8w个时钟周期。对于竞争不激烈的情况，使用循环使用CAS开销更小。<br>无锁操作在并发比较少的情况下效率高，但不要迷恋无锁。<br>CAS是CPU指令级别的原子操作，一条指令完成比较赋值过程，不用担心并发问题。<br><a id="more"></a></p>
<h1 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h1><p>AtomicInteger 部分源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></div><div class="line"><span class="comment">//只有bootstrap加载器加载的类才能获取Unsafe的实例，其他类只能用反射获取</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line"><span class="comment">//valueOffset 代表需要更新的字段在对象中的偏移量，类似于c中的指针，获取需要更新字段的内存地址</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Unsafe 部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//valueOffset 代表需要更新的字段在对象中的偏移量，类似于c中的指针，获取需要更新字段的内存地址</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1,<span class="keyword">long</span> valueOffset, expect, update)</span></span>;</div><div class="line"><span class="comment">//不断zi'x</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> var5;</div><div class="line">    do &#123;</div><div class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</div><div class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> var5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h1><p>　　可以修饰任意类型的变量，是的变量操作变为院子操作<br>AtomicReference<string> stringAtomicReference = new AtomicReference&lt;&gt;();</string></p>
<h1 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h1><p>　　与AtomicReference功能相似，不同点是AtomicStampedReference可以解决过程相关的情景。过程敏感的情景试用。<br>　　假设一个活动只能给每个用户充值一次10元钱，用户可以消费。假设用户A充值以后立马消费10元，AtomicReference还会认为只消费了一次。<br>　　<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AtomicStampedReference&lt;Integer&gt; money = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line"><span class="keyword">int</span> stamp = money.getStamp();</div><div class="line">money.compareAndSet(<span class="number">0</span>,<span class="number">10</span>,stamp,stamp+<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>AtomicStampedReference部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> T reference;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.reference = reference;</div><div class="line">        <span class="keyword">this</span>.stamp = stamp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</div><div class="line"><span class="comment">//构造函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;</div><div class="line">    pair = Pair.of(initialRef, initialStamp);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference, V   newReference,</span></span></div><div class="line">                             <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp) &#123;</div><div class="line">    Pair&lt;V&gt; current = pair;</div><div class="line">    <span class="keyword">return</span> expectedReference == current.reference &amp;&amp;</div><div class="line">        expectedStamp == current.stamp &amp;&amp;</div><div class="line">        ((newReference == current.reference &amp;&amp;</div><div class="line">          newStamp == current.stamp) ||</div><div class="line">         casPair(current, Pair.of(newReference, newStamp)));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h1><p>原子操作的整数数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AtomicIntegerArray array = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</div><div class="line"><span class="comment">//下标为2的位置加一</span></div><div class="line">array.getAndIncrement(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[].class);</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shift;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</div><div class="line"></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</div><div class="line">    <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</div><div class="line">    shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + i);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> byteOffset(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="comment">// Visibility guaranteed by final field guarantees</span></div><div class="line">    <span class="keyword">this</span>.array = array.clone();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(array, checkedByteOffset(i), delta);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h1><p>AtomicIntegerFieldUpdater辅助一个类，用类似静态方法的方式，实现变量的原子操作。优点在于不必改变变量的类型，即可享受原子变量的好处。如果是已有代码修改，将会大大减少代码的修改量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> id = <span class="number">0</span> ;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> score = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">"score"</span>);</div><div class="line">Candidate candidate = <span class="keyword">new</span> Candidate();</div><div class="line">scoreUpdater.incrementAndGet(candidate);</div></pre></td></tr></table></figure>
<p>AtomicIntegerFieldUpdater部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicLongFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></div><div class="line">                                                       String fieldName) &#123;</div><div class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</div><div class="line">    <span class="keyword">if</span> (AtomicLong.VM_SUPPORTS_LONG_CAS)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CASUpdater&lt;U&gt;(tclass, fieldName, caller);</div><div class="line">    <span class="keyword">else</span>  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LockedUpdater&lt;U&gt;(tclass, fieldName, caller);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LockFreeVector"><a href="#LockFreeVector" class="headerlink" title="LockFreeVector"></a>LockFreeVector</h2><p>无锁数组，amino框架提供</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一桶的大小为8 </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> First_BUCKET_SIZE = <span class="number">8</span>;</div><div class="line"><span class="comment">//采用二维数组做扩展，每个一维数组的大小都不同 sizeOf(buke[i+1]) = sizeOf( buket[i]) *2</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt; buckets;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDescriptor</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">   <span class="keyword">public</span> E odlV; </div><div class="line">   <span class="keyword">public</span> E newV;</div><div class="line">   <span class="keyword">public</span> AtomicReferenceArray&lt;E&gt; addr; <span class="comment">//操作地址</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">int</span> addr_ind;<span class="comment">//地址的index</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WriteDesciptor</span><span class="params">(AtomicReferenceArray&lt;E&gt; addr,<span class="keyword">int</span> addr_ind, E oldV,E newV)</span></span>&#123;</div><div class="line">      <span class="keyword">this</span>.addr = addr;</div><div class="line">   <span class="keyword">this</span>.addr_ind =addr_ind;</div><div class="line">      <span class="keyword">this</span>.oldV = oldV;</div><div class="line">      <span class="keyword">this</span>.newV = newV;</div><div class="line">   &#125; </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span></span>&#123;</div><div class="line">addr.compareAndSet()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(E e)</span></span>&#123;</div><div class="line">Desciptor</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM2-Java内存模型和三个概念]]></title>
      <url>http://baobing.github.io/2016/07/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM2-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>GYM是葛一鸣老师的简写。GYM系列文章都是观看葛老师课程的个人笔记。<br><a id="more"></a></p>
<blockquote>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
<h1 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h1><h2 id="高速缓存带来的不一致问题"><a href="#高速缓存带来的不一致问题" class="headerlink" title="高速缓存带来的不一致问题"></a>高速缓存带来的不一致问题</h2><p>　　计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
</blockquote>
<p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = i + 1;</div></pre></td></tr></table></figure></p>
<p>　　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>　　在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通常来说有以下2种解决方法：<br>1）通过在总线加LOCK#锁的方式<br>2）通过缓存一致性协议</p>
<p>　　因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。</p>
<p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。所以就出现了缓存一致性协议。最出名的就是Intel<strong><em> 的MESI协议</em></strong>，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h1 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>一个很经典的例子就是银行账户转账问题：<br>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。假设从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。所以这两个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//线程1执行的代码</div><div class="line">int i = 0;</div><div class="line">i = 10;</div><div class="line"> </div><div class="line">//线程2执行的代码</div><div class="line">j = i;</div></pre></td></tr></table></figure></p>
<p>　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。<br>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.<br>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h4><p>有序性：即程序执行的顺序按照代码的先后顺序执行。<br>举个简单的例子，看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int i = 0;             </div><div class="line">boolean flag = false;</div><div class="line">i = 1;                //语句1 </div><div class="line">flag = true;          //语句2</div></pre></td></tr></table></figure></p>
<p>　　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。<br>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。<br>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 10;    //语句1</div><div class="line">int r = 2;    //语句2</div><div class="line">a = a + 3;    //语句3</div><div class="line">r = a*a;     //语句4</div></pre></td></tr></table></figure></p>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3<br>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。<br>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//线程1:</div><div class="line">context = loadContext();   //语句1</div><div class="line">inited = true;             //语句2</div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p>
<p>　　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。<br>　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>　　下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。<br>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。<br>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。<br>举个简单的例子：<br>　　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。<br>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h2 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h2><p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。<br>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = 10;         //语句1</div><div class="line">y = x;         //语句2</div><div class="line">x++;           //语句3</div><div class="line">x = x + 1;     //语句4</div></pre></td></tr></table></figure></p>
<p>　　其实只有语句1是原子性操作，其他三个语句都不是原子性操作。<br>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。<br>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。<br>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。<br>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h2 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h2><p>对于可见性，Java提供了volatile关键字来保证可见性。<br>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br><strong><em>happens-before原则（先行发生原则）</em></strong><br>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>这8条原则摘自《深入理解Java虚拟机》。<br>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。<br>下面我们来解释一下前4条规则：<br>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。<br>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。<br>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。<br>　　第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h1 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h1><h2 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。<br>先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//线程1</div><div class="line">boolean stop = false;</div><div class="line">while(!stop)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">//线程2</div><div class="line">stop = true;</div></pre></td></tr></table></figure>
<p>　<br>　<br>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。<br>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。<br>　　但是用volatile修饰之后就变得不一样了：<br>第一：使用volatile关键字会强制将修改的值立即写入主存；<br>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。<br>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。<br>那么线程1读取到的就是最新的正确的值。</p>
<h2 id="volatile保证原子性吗？"><a href="#volatile保证原子性吗？" class="headerlink" title="volatile保证原子性吗？"></a>volatile保证原子性吗？</h2><p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。<br>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：<br>　　假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。<br>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。那么两个线程分别进行了一次自增操作后，inc只增加了1。<br>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。<br>把上面的代码改成以下任何一种都可以达到效果：<br>采用synchronized：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public  int inc = 0;</div><div class="line"> </div><div class="line">    public synchronized void increase() &#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">        for(int i=0;i&lt;10;i++)&#123;</div><div class="line">            new Thread()&#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    for(int j=0;j&lt;1000;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="volatile能保证有序性吗？"><a href="#volatile能保证有序性吗？" class="headerlink" title="volatile能保证有序性吗？"></a>volatile能保证有序性吗？</h2><p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。<br>volatile关键字禁止指令重排序有两层意思：<br>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br>可能上面说的比较绕，举个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//x、y为非volatile变量</div><div class="line">//flag为volatile变量</div><div class="line"> </div><div class="line">x = 2;        //语句1</div><div class="line">y = 0;        //语句2</div><div class="line">flag = true;  //语句3</div><div class="line">x = 4;         //语句4</div><div class="line">y = -1;       //语句5</div></pre></td></tr></table></figure></p>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。<br>那么我们回到前面举的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//线程1:</div><div class="line">context = loadContext();   //语句1</div><div class="line">inited = true;             //语句2</div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。<br>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h2 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h2><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>2）它会强制将对缓存的修改操作立即写入主存；<br>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。<br>内存屏障可以被分为以下几种类型<br>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p>
<p>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。<br>为了实现上一章中讨论的JSR-133的规定，Java编译器会这样使用内存屏障。</p>
<p>内存屏障示意表</p>
<p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障。<br>x.finalField = v; StoreStore; sharedRef = x;</p>
<h1 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h1><p>　　通常来说，使用volatile必须具备以下2个条件：<br>1）对变量的写操作不依赖于当前值<br>2）该变量没有包含在具有其他变量的不变式中<br>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<h2 id="状态标记量"><a href="#状态标记量" class="headerlink" title="状态标记量"></a>状态标记量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">volatile boolean flag = false;</div><div class="line"> </div><div class="line">while(!flag)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public void setFlag() &#123;</div><div class="line">    flag = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">volatile boolean inited = false;</div><div class="line">//线程1:</div><div class="line">context = loadContext(); </div><div class="line">inited = true;           </div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<h2 id="double-check"><a href="#double-check" class="headerlink" title="double check"></a>double check</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">    private volatile static Singleton instance = null;</div><div class="line"> </div><div class="line">    private Singleton() &#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        if(instance==null) &#123;</div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                if(instance==null)</div><div class="line">                    instance = new Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>29</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GYM1-并发基础和Thread类详解]]></title>
      <url>http://baobing.github.io/2016/07/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GYM1-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%92%8CThread%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>GYM是葛一鸣老师的简写。GYM系列文章都是观看葛老师课程的个人笔记。<br><a id="more"></a></p>
<h1 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h1><p>1.发挥多处理器的强大能力<br>2.代码责任单一，方便调试<br>3.异步事件的简化处理,防止客户端阻塞<br>4.响应更灵敏的用户界面</p>
<h1 id="多线程危害"><a href="#多线程危害" class="headerlink" title="多线程危害"></a>多线程危害</h1><p>1.线程安全性可能是非常复杂的，线程执行顺序是不可预测的，竞争条件，脏读。<br>2.活跃性问题：某件正确的事情最终会发生，死锁。<br>3.性能问题：context Switch 切换、影响性能。</p>
<h1 id="java线程状态"><a href="#java线程状态" class="headerlink" title="java线程状态"></a>java线程状态</h1><p>1.New：状态 已经分配内存，无cpu时间<br>2.Runable： 资源已经全部分配，可能在已经分配cpu时间<br>3.blocked：进入临界区，被挂起<br>4.waiting：等他其他线程唤醒，或者定时唤醒<br>5.terminated：终止状态<br>x\</p>
<h1 id="java线程的操作"><a href="#java线程的操作" class="headerlink" title="java线程的操作"></a>java线程的操作</h1><ul>
<li>Thread的start()在新的线程中调用run()方法，单纯吊用run()方法不会开启一个新的线程。</li>
<li>两种方法新建：<br>（1）传递一个实现Runable的类；<br>（2）重载Thread的run()方法；</li>
<li>每个线程都拥有自己的名字；<h1 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h1></li>
<li>thread.stop() 不建议使用，过于暴力，直接终止，可能导致数据的不一致，。</li>
<li>thread.interruput() 中断线程，只是给相应的线程打招呼，并不会真的终端线程</li>
<li>thread.isInterruput() 判断线程是否被中断，采取相应的措施</li>
<li>thread.sleep() InterruptedException<br>在sleep过程中其他线程发送中断请求 ，可以在catch中做出中断处理。<br>中断异常的时候清空中断标志位，catch中需要重新设置中断标志，while中使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">static class InterruptedThread implements Runnable &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        while (true) &#123;</div><div class="line">            if (Thread.currentThread().isInterrupted()) &#123;</div><div class="line">                System.out.println(&quot;i am breaking&quot;);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(&quot;i want to sleep&quot;);</div><div class="line">                Thread.sleep(5000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                System.out.println(&quot;someone interrupt me&quot;);</div><div class="line">            //恢复中断标志位</div><div class="line">                Thread.currentThread().interrupt();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException&#123;</div><div class="line">    Thread thread = new Thread(new InterruptedThread(), &quot;t1&quot;);</div><div class="line">    thread.start();</div><div class="line">    Thread.sleep(7000);</div><div class="line">    thread.interrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>输出结果：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i want to sleep</div><div class="line">i want to sleep</div><div class="line">someone interrupt me</div><div class="line">i am breaking</div></pre></td></tr></table></figure></p>
<h1 id="六、线程挂起和继续执行"><a href="#六、线程挂起和继续执行" class="headerlink" title="六、线程挂起和继续执行"></a>六、线程挂起和继续执行</h1><p>不建议使用，resume()发生在suspend之前时，线程无法释放锁处于runnable转台</p>
<ul>
<li>tread.suspend() 占用锁不释放</li>
<li>thread.resume()  重启线程</li>
</ul>
<h1 id="七、等待和谦让（debugger、测试可能使用）"><a href="#七、等待和谦让（debugger、测试可能使用）" class="headerlink" title="七、等待和谦让（debugger、测试可能使用）"></a>七、等待和谦让（debugger、测试可能使用）</h1><ul>
<li>thread.yield() 释放当前线程的cpu时间，但是还是继续竞争，</li>
<li>thread.join()等待线程结束<br>调用线程等待join函数的所属线程结束<h2 id="join实现代码"><a href="#join实现代码" class="headerlink" title="join实现代码"></a>join实现代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public final synchronized void join(long millis)</div><div class="line">    throws InterruptedException &#123;</div><div class="line">        long base = System.currentTimeMillis();</div><div class="line">        long now = 0;</div><div class="line">        if (millis &lt; 0) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class="line">        &#125;</div><div class="line">        if (millis == 0) &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                wait(0);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                long delay = millis - now;</div><div class="line">                if (delay &lt;= 0) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                wait(delay);</div><div class="line">                now = System.currentTimeMillis() - base;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>在后台默默完成一些系统性的服务，如GC、JIT理解为守护线程<br>setDeamon();在start之前设置<br>如果没有业务线程守护线程也会死掉。</p>
<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p>setPriority(Thread.MAX_PRORITY)<br>高优先级程序不一定就能一直抢占cpu时间，只是几率高一些</p>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><ul>
<li>synchronized<br>（1）指定加锁对象<br>（2）修饰实例方法：相当于当前对象加锁<br>（3）直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁</li>
<li>object.wait()、object.notify()、notifyAll()<pre><code>没有获得监视器之前不能使用wait(),会释放当前线程的监视器，通知其他线程执行；
notify之后不会立即启动wait方法，拿到锁之后可以继续执行wait之后的事情。唤醒所有等待监视器的线程中的其中一个线程。notifyAll唤醒所有的线程，去争用监视器。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">    public static Boolean flag = true;</div><div class="line"></div><div class="line">    public static class Task implements Runnable &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">            //必须获取监视器才能用wait 会排数InterruptedException</div><div class="line">                synchronized (flag) &#123;</div><div class="line">                    System.out.println(&quot;im ready to wait&quot;);</div><div class="line">                    flag.wait();</div><div class="line">                    System.out.println(&quot;someone notify me&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        new Thread(new Task()).start();</div><div class="line">        Thread.sleep(5000);</div><div class="line">        synchronized (flag) &#123;</div><div class="line">            TestWaitNotify.flag.notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">输出结果  </div><div class="line">/**</div><div class="line">  *im ready to wait</div><div class="line">  *someone notify me</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ul>
<p>﻿</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组中只出现一次的数字]]></title>
      <url>http://baobing.github.io/2016/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个整型数组里除了两个数字之外，其他的数字都出现两次。请写程序找出这两个只出现一次的数字。要求时间复杂度为O(n),空间复杂度为O（1）。<br>{2，4，3，6，3，2，5，5} 结果为4，6。<br><a id="more"></a></p>
<h1 id="异或运算的特性"><a href="#异或运算的特性" class="headerlink" title="异或运算的特性"></a>异或运算的特性</h1><ol>
<li>交换律 a^b = b^a</li>
<li>结合律 a^b^c = a^(b^c)</li>
<li>a^a = 0</li>
<li>0^a = a</li>
<li>a^b^a = a^a^b = b</li>
<li>如果a^b = 1 != 0，则a与b的二进制形式的个位是不相同的</li>
</ol>
<h1 id="结题思路"><a href="#结题思路" class="headerlink" title="结题思路"></a>结题思路</h1><h2 id="只有一个数字只出现一次"><a href="#只有一个数字只出现一次" class="headerlink" title="只有一个数字只出现一次"></a>只有一个数字只出现一次</h2><p>题目如果改为只有一个出现一次的数字。<br>根据特性5，我们只需要把所有的数字一起异或就会得到这个只出现一次的数字N.<br>N = 0^A[0]^A[1]^A[2]….</p>
<h2 id="两个数字只出现一次"><a href="#两个数字只出现一次" class="headerlink" title="两个数字只出现一次"></a>两个数字只出现一次</h2><p>1) x = n^m = 0^A[0]^A[1]^A[2]….<br>根据特性6我们知道如果n,m不相等.他们异或的结果的二进制形式的每一位都代表n，m二进制对应位不相同。例如两个二进制数字a,b异或：10011^11011 = 1000 , 二进制结果中只有第四位数字等于1，则a，b的第四位不同。<br>2）挑选所有元素异或结果x的其中一个为1的位置不变，其他位置变为0，得到y.假设x的二进制形式为10110，y=10000.<br>3）每个元素与y进行与运算，结果为等于y的是一组，结果不为y的是一组。n和m一定不在同一组。<br>4）问题转化为只有一个数字只出现一次</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestXor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getArrXorResult</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</div><div class="line">            result ^= arr[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getXOne</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (l = <span class="number">0</span>; x &gt;&gt; <span class="number">1</span> != <span class="number">0</span>; l++) &#123;</div><div class="line">            x &gt;&gt;= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; l;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</div><div class="line">        <span class="comment">//分别装载两个分组</span></div><div class="line">        <span class="keyword">int</span>[] arr0 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</div><div class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</div><div class="line">        <span class="keyword">int</span> x = getArrXorResult(arr, <span class="number">0</span>, arr.length);</div><div class="line">        <span class="comment">//获取异或结果二进制结果是1的最大的那个</span></div><div class="line">        <span class="keyword">int</span> y = getXOne(x);</div><div class="line">        <span class="keyword">int</span> index0 = <span class="number">0</span>, index1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> ((arr[i] &amp; y) == y) &#123;</div><div class="line">                arr0[index0++] = arr[i];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                arr1[index1++] = arr[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> n = getArrXorResult(arr0, <span class="number">0</span>, index0);</div><div class="line">        <span class="keyword">int</span> m = getArrXorResult(arr1, <span class="number">0</span>, index1);</div><div class="line">        System.out.println(<span class="string">"n="</span> + n + <span class="string">" m="</span> + m);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组排成最小的数]]></title>
      <url>http://baobing.github.io/2016/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>　　输入一个正整数数组，每个元素都不相等，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如数组{3，32，321},则打印出这3个数字能排成的最小数字321323.（《剑指Offer》P177）<br><a id="more"></a><br>　　贪心算法的题目，找到解决办法不能，难得是给出正确性证明。书中给出了证明，前半段讲的很好，不过后半段不是很满意。
　　</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>1）将数组中所有数字转化为字符串，组成新的数组Str<br>2）对所有字符串排序。 return Str[i]+Str[j]&lt;Str[j]+Str[i]</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStringComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> (o1.toString() + o2.toString()).compareTo(o2.toString() + o1.toString());</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">32</span>, <span class="number">321</span>&#125;;</div><div class="line">     List&lt;Integer&gt; list = Arrays.asList(arr);</div><div class="line">     Collections.sort(list, <span class="keyword">new</span> MinStringComparator());</div><div class="line">     StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">100</span>);</div><div class="line">     <span class="keyword">for</span> (Integer e : list) &#123;</div><div class="line">         stringBuilder.append(e);</div><div class="line">     &#125;</div><div class="line">     System.out.println(stringBuilder.toString());</div></pre></td></tr></table></figure>
<h1 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h1><h2 id="排序关系有效性证明"><a href="#排序关系有效性证明" class="headerlink" title="排序关系有效性证明"></a>排序关系有效性证明</h2><p>一个有效的比较规则一定满足自反性、对称性和传递性。<br>1）自反性：显然有 aa = aa,所以a等于a。<br>2）传递性：如果a小于b，则ab<ba。所以ba>ab,因此b大于a。<br>3）传递性：假设a小于b，ab&lt;ba. b小于c，bc&lt;cb<br>a的十进制为m位，b的十进制为n位，c的十进制为k位</ba。所以ba></p>
<img src="/2016/07/28/数据结构与算法/数组排成最小的数/transitivity.png" alt="传递性证明过程" title="传递性证明过程">
<p>因此 a小于b，b小于c，a必定小于c</p>
<h2 id="最终证明"><a href="#最终证明" class="headerlink" title="最终证明"></a>最终证明</h2><p>排序关系证明是很重要的前提。正面证明很困难，使用反证法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">假设存在一个序列A小于序列B。</div><div class="line">1）假设B[i] = A[j],我们可以一直向前或者向后移动B[i]直到B[i]到达位置j。B序列中的每一个元素都按照这种方法移动即可得到A序列。</div><div class="line">2）现在我没减缓这个移动过程，每次只移动一个特定的元素B[i]一步直到B[i]到达位置j，而且一次只移动一步。可就是说经过一次移动序列B(0)：B[0]...B[i-1]B[i]...变为B(1):[0]...B[i]B[i-1]...。 B(l)代表序列B经历过l次移动。</div><div class="line">3)因为B[i-1]B[i]&lt;B[i]B[i-1]（这一点需要排序关系证明的支持才能成立），所以B[0]...B[i-1]B[i]...&lt;[0]...B[i]B[i-1]...</div><div class="line">4）因为B[i]B[i+1]&lt;B[i+1]B[i]（这一点需要排序关系证明的支持才能成立），所以B[0]...B[i-1]B[i]...&lt;[0]...B[i]B[i-1]...</div><div class="line">5)因为B(0)&lt;B(1)&lt;B(2)&lt;...&lt;B(x)=A(0)，所以B&lt;A</div><div class="line">这与题设不相符，所以假设不成立。也就是说A是最小的序列</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap源码解析]]></title>
      <url>http://baobing.github.io/2016/07/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>　　 JDK1.8中，ConcurrentHashMap的源码竟然有6300行,作者是大名鼎鼎Doug Lea（感谢开源让我离大神可以这么近，不过代码风格明显没打算交给他人维护）。本文只讲述扩容相关的内容，其他操作就放弃了。文章参考一下别人的文章，主要是以下两篇文章：<br>　　 <a id="more"></a></p>
<blockquote>
<p><a href="http://blog.csdn.net/u010887744/article/details/51002358" target="_blank" rel="external">http://blog.csdn.net/u010887744/article/details/51002358</a><br><a href="http://www.cnblogs.com/huaizuo/p/5413069.html" target="_blank" rel="external">http://www.cnblogs.com/huaizuo/p/5413069.html</a><br>　　友情提示：看ConcurrentHashMap源码还是需要一些Java并发编程的了解，比如内存可见性、原子性、顺序性、无锁。另一点就是先阅读HashMap的源码。</p>
<h1 id="JDK8-HashMap数据结构"><a href="#JDK8-HashMap数据结构" class="headerlink" title="JDK8 HashMap数据结构"></a>JDK8 HashMap数据结构</h1></blockquote>
<p><center></center></p>
<p><center>图1</center><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;</div><div class="line">        final K key;</div><div class="line">        volatile V val;</div><div class="line">        volatile Node&lt;K,V&gt; next;</div><div class="line">       //省略省略</div><div class="line">&#125;</div><div class="line"> transient volatile Node&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure></p>
<p>　　HashMap底层由数组、链表和红黑树三者组成。我们从图1和源码大改也可以推断出来。首先是HashMap使用Node组成的数组table装载所有的键值对，再者HashMap发生Hash值碰撞使用链表将它们连起来，最后是某个链表长度大于指定值链表转化为红黑树。   </p>
<h1 id="重要的常量"><a href="#重要的常量" class="headerlink" title="重要的常量"></a>重要的常量</h1><h2 id="基本常量"><a href="#基本常量" class="headerlink" title="基本常量"></a>基本常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> transient volatile Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line"> //扩容时使用，其他时候为null</div><div class="line"> private transient volatile Node&lt;K,V&gt;[] nextTable;</div><div class="line"></div><div class="line"> //基础计数器，主要用于无争用，同时也作为table数组初始化的回退记录</div><div class="line"> private transient volatile long baseCount;</div><div class="line"></div><div class="line"> //table数组初始化和扩容的控制标志。为负数时，table数组正在扩容或初始化，</div><div class="line"> //-1代表初始化，其他负数表示 -（1+参数扩容的线程数量）。当table为null时，</div><div class="line"> //sizeCtl持有扩容的阈值，0为默认值。</div><div class="line"> private transient volatile int sizeCtl;</div><div class="line"></div><div class="line">//table扩容时 每个线程最少需要处理的元素数量。看不懂就跳过去，下同</div><div class="line"> private static final int MIN_TRANSFER_STRIDE = 16;</div><div class="line"></div><div class="line"> //当table扩容时，transferIndex持有下一个线程或者下次循环可以处理的数组界限</div><div class="line"> private transient volatile int transferIndex;</div><div class="line"></div><div class="line"> //table数组的默认长度</div><div class="line"> private static final int DEFAULT_CAPACITY = 16;</div><div class="line"></div><div class="line"> //table数组的负载因子. 小数形式不经常使用，它更常见的表示形式是 n - (n &gt;&gt;&gt; 2)</div><div class="line"> private static final float LOAD_FACTOR = 0.75f;</div></pre></td></tr></table></figure>
<h2 id="Unsafe相关常量"><a href="#Unsafe相关常量" class="headerlink" title="Unsafe相关常量"></a>Unsafe相关常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// Unsafe mechanics</div><div class="line">    private static final sun.misc.Unsafe U;</div><div class="line">    private static final long SIZECTL; //sizeCtl的偏移量</div><div class="line">    private static final long TRANSFERINDEX; //transferIndex的偏移量</div><div class="line">    private static final long BASECOUNT;   //</div><div class="line">    private static final long CELLSBUSY;</div><div class="line">    private static final long CELLVALUE;</div><div class="line">    //数组中第一个元素在数组中的位置</div><div class="line">    private static final long ABASE;</div><div class="line">     //Node数组元素大小scale的二进制去除前导零后的位数</div><div class="line">    private static final int ASHIFT;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        try &#123;</div><div class="line">            U = sun.misc.Unsafe.getUnsafe();</div><div class="line">            Class&lt;?&gt; k = ConcurrentHashMap.class;</div><div class="line">    ﻿    ﻿  //获取sizeCtl的偏移量</div><div class="line">            SIZECTL = U.objectFieldOffset(k.getDeclaredField(&quot;sizeCtl&quot;)); </div><div class="line">    ﻿    ﻿  //省略代码，和上面一样获取各个变量的偏移量</div><div class="line">             ...</div><div class="line">            Class&lt;?&gt; ak = Node[].class;</div><div class="line">            //Arrays和Java别的对象一样，都有一个对象头，它是存储在实际的数据前面的。</div><div class="line">            //这个头的长度可以通过unsafe.arrayBaseOffset(T[].class) 方法来获取到，</div><div class="line">    ﻿    ﻿    ﻿ //这里T是数组元素的类型</div><div class="line">            ABASE = U.arrayBaseOffset(ak); </div><div class="line">            int scale = U.arrayIndexScale(ak); //获取数组元素的大小</div><div class="line">            if ((scale &amp; (scale - 1)) != 0) //元素大小必须是2的倍数，不知道为什么</div><div class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</div><div class="line">            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw new Error(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h1><h2 id="无锁方法"><a href="#无锁方法" class="headerlink" title="无锁方法"></a>无锁方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    //内存中直接获取tab数组张第i个元素，保证内存可见性</div><div class="line">      static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</div><div class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">    &#125;</div><div class="line">   //为tab数组的第i个元素复制，使用CAS，保证操作的原子性</div><div class="line"></div><div class="line">    static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">    &#125;</div><div class="line">   static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</div><div class="line">/**设置obj对象中offset偏移地址对应的object型field的值为指定值。这是一个有序或者</div><div class="line"> 有延迟的putObjectVolatile方法，并且不保证值的改变被其他线程立</div><div class="line"> 即看到。只有在field被&lt;code&gt;volatile&lt;/code&gt;修饰并且期望被意外修改的时候</div><div class="line">  使用才有用。*/</div><div class="line">        U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="扩容方法transfer"><a href="#扩容方法transfer" class="headerlink" title="扩容方法transfer"></a>扩容方法transfer</h2><h3 id="扩容过程解析"><a href="#扩容过程解析" class="headerlink" title="扩容过程解析"></a>扩容过程解析</h3><p>　　ConcurrentHashMap无锁多线程扩容，减少扩容时的时间消耗。单线程构建两倍容量的nextTable；允许多线程复制原table元素到nextTable。为每个内核均分任务，并保证其不小于16（常量MIN_TRANSFER_STRIDE）。<br>1）若nextTab为null，则初始化其为原table的2倍；<br>2）死循环遍历，直到finishing。</p>
<ul>
<li>节点为空，则插入ForwardingNode；</li>
<li>链表节点（fh&gt;=0），分别插入nextTable的i和i+n的位置；</li>
<li>TreeBin节点（fh&lt;0），判断是否需要untreefi，分别插入nextTable的i和i+n的位置；</li>
<li>finishing时，nextTab赋给table，更新sizeCtl为新容量的0.75倍 ，完成扩容。<br>以上说的都是单线程，多线程又是如何实现的呢？<pre><code>遍历到ForwardingNode节点((fh = f.hash) == MOVED)，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心 。由于给节点上了锁，只允许当前线程完成此节点的操作，处理完毕后，将对应值设为ForwardingNode（fwd），其他线程看到forward，直接向后遍历。如此便完成了多线程的复制工作，也解决了线程安全问题。
</code></pre></li>
</ul>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Moves and/or copies the nodes in each bin to new table. See</div><div class="line"> * above for explanation.</div><div class="line"> */</div><div class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class="line">    //n表示原数组的大小 ,stride表示每个线程或者单次循环负责节点的个数 </div><div class="line">    int n = tab.length, stride;</div><div class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</div><div class="line">    if (nextTab == null) &#123;            // 为nextTable申请空间</div><div class="line">        try &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</div><div class="line">            nextTab = nt;</div><div class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</div><div class="line">            sizeCtl = Integer.MAX_VALUE;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        nextTable = nextTab;</div><div class="line">        transferIndex = n;</div><div class="line">    &#125;</div><div class="line">    int nextn = nextTab.length;</div><div class="line">    //构建一个连节点的指针，用于标识位</div><div class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">    boolean advance = true;</div><div class="line">    //循环的关键变量，判断是否已经扩容完成</div><div class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</div><div class="line">    //i--操作保证了倒序遍历数组，bound表示新的线程或者单次循环的下边界</div><div class="line">    for (int i = 0, bound = 0;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int fh;</div><div class="line">      </div><div class="line">        while (advance) &#123;</div><div class="line">            int nextIndex, nextBound;</div><div class="line">            if (--i &gt;= bound || finishing) //循环没有到达下边界可以继续for循环</div><div class="line">                advance = false;</div><div class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123; //整个for循环过程结束</div><div class="line">                i = -1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">    ﻿    ﻿   //只有通过CAS成功更新ransferIndex才能获取到扩容的资格</div><div class="line">            else if (U.compareAndSwapInt  </div><div class="line">                     (this, TRANSFERINDEX, nextIndex,</div><div class="line">                      nextBound = (nextIndex &gt; stride ?</div><div class="line">                                   nextIndex - stride : 0))) &#123;</div><div class="line">                bound = nextBound;</div><div class="line">                i = nextIndex - 1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //i&lt;0说明已经遍历完旧的数组tab；i&gt;=n什么时候有可能呢？</div><div class="line">    ﻿   //在下面看到i=n,所以目前i最大应该是n吧,导致的原因可能是多线程</div><div class="line">        //i+n&gt;=nextn,nextn=nextTab.length，所以如果满足i+n&gt;=nextn说明已经扩容完成</div><div class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; </div><div class="line">            int sc;</div><div class="line">            if (finishing) &#123;//a</div><div class="line">                nextTable = null;</div><div class="line">                table = nextTab;</div><div class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            //利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，</div><div class="line">    ﻿    ﻿   //说明新加入一个线程参与到扩容操作,参考sizeCtl的注释</div><div class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class="line">                //如果有多个线程进行扩容，那么这个值在第二个线程以后就不会相等，</div><div class="line">    ﻿    ﻿      ﻿//因为sizeCtl已经被减1了，所以后面的线程就只能直接返回,</div><div class="line">    ﻿    ﻿    ﻿  //始终保证只有一个线程执行了 a(上面注释a)</div><div class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class="line">                    return;</div><div class="line">    ﻿    ﻿    ﻿//finishing和advance保证线程已经扩容完成了可以退出循环</div><div class="line">                finishing = advance = true;</div><div class="line">                i = n; // recheck before commit</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ﻿   //如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了</div><div class="line">        else if ((f = tabAt(tab, i)) == null)</div><div class="line">            advance = casTabAt(tab, i, null, fwd);</div><div class="line">    ﻿    //那么如果f.hash=-1的话说明该节点为ForwardingNode，说明该节点已经处理过了</div><div class="line">        else if ((fh = f.hash) == MOVED)</div><div class="line">            advance = true; // already processed</div><div class="line">        else &#123;</div><div class="line">            synchronized (f) &#123;</div><div class="line">                if (tabAt(tab, i) == f) &#123;</div><div class="line">                    Node&lt;K,V&gt; ln, hn;</div><div class="line">                    if (fh &gt;= 0) &#123;</div><div class="line">                        int runBit = fh &amp; n;</div><div class="line">                        Node&lt;K,V&gt; lastRun = f;</div><div class="line">                        //把链表分表拆分为，hash&amp;n等于0和不等于0的，</div><div class="line">    ﻿    ﻿    ﻿    ﻿    //然后分别放在新表的i和i+n位置。n一定是2的幂，这个很重要</div><div class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</div><div class="line">                            int b = p.hash &amp; n;</div><div class="line">                            if (b != runBit) &#123;</div><div class="line">                                runBit = b;</div><div class="line">                                lastRun = p;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        if (runBit == 0) &#123;</div><div class="line">                            ln = lastRun;</div><div class="line">                            hn = null;</div><div class="line">                        &#125;</div><div class="line">                        else &#123;</div><div class="line">                            hn = lastRun;</div><div class="line">                            ln = null;</div><div class="line">                        &#125;</div><div class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                            if ((ph &amp; n) == 0)</div><div class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                            else</div><div class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                        &#125;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        //把已经替换的节点的旧tab的i的位置用fwd替换，fwd包含nextTab</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;//下面红黑树基本和链表差不多</div><div class="line">                    else if (f instanceof TreeBin) &#123;</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</div><div class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</div><div class="line">                        int lc = 0, hc = 0;</div><div class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</div><div class="line">                            int h = e.hash;</div><div class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div class="line">                                (h, e.key, e.val, null, null);</div><div class="line">                            if ((h &amp; n) == 0) &#123;</div><div class="line">                                if ((p.prev = loTail) == null)</div><div class="line">                                    lo = p;</div><div class="line">                                else</div><div class="line">                                    loTail.next = p;</div><div class="line">                                loTail = p;</div><div class="line">                                ++lc;</div><div class="line">                            &#125;</div><div class="line">                            else &#123;</div><div class="line">                                if ((p.prev = hiTail) == null)</div><div class="line">                                    hi = p;</div><div class="line">                                else</div><div class="line">                                    hiTail.next = p;</div><div class="line">                                hiTail = p;</div><div class="line">                                ++hc;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        //判断扩容后是否还需要红黑树结构</div><div class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</div><div class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[红黑树和HashMap中实现]]></title>
      <url>http://baobing.github.io/2016/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%A5%E5%8F%8AHashMap/</url>
      <content type="html"><![CDATA[<p>　　本人最近在看JDK的HashMap源码，在JDK1.8中引入红黑树。引入红黑树的原因是加快hash碰撞较多情景下的查找速度。网上找到下面这篇文章感觉写的非常好，思路清晰。我会在原文章基础上做一点批注，方便日后阅读。<br>　　<a id="more"></a></p>
<blockquote>
<p><a href="http://blog.csdn.net/eric491179912/article/details/6179908" target="_blank" rel="external">http://blog.csdn.net/eric491179912/article/details/6179908</a></p>
</blockquote>
<h1 id="红黑树的基本特性"><a href="#红黑树的基本特性" class="headerlink" title="红黑树的基本特性"></a>红黑树的基本特性</h1><p>　　一定要牢记这五条特性，推导全靠这几条原则。 </p>
<ol>
<li><p>节点是红色或黑色。</p>
</li>
<li><p>根节点是黑色。</p>
</li>
<li><p>每个叶节点（NIL节点，空节点）是黑色的。<strong><em>这个限制根本没有用啊，亲 - -！</em></strong></p>
</li>
<li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
</li>
<li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
</li>
</ol>
<h1 id="红黑树上结点的插入"><a href="#红黑树上结点的插入" class="headerlink" title="红黑树上结点的插入"></a>红黑树上结点的插入</h1><p>　　<strong><em>任何一个即将插入的新结点的初始颜色都为红色。</em></strong>这一点很容易理解，因为插入黑点会增加某条路径上黑结点的数目，从而导致整棵树黑高度的不平衡。但如果新结点父结点为红色时（如图1所示），将会违返红黑树性质：一条路径上不能出现相邻的两个红色结点。这时就需要通过一系列操作来使红黑树保持平衡。</p>
<img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert1.jpg" alt="图1" title="图1">
<p>　　为了清楚地表示插入操作以下在结点中使用“新”字表示一个新插入的结点；使用“父”字表示新插入点的父结点；使用“叔”字表示“父”结点的兄弟结点；使用“祖”字表示“父”结点的父结点。插入操作分为以下几种情况：</p>
<h2 id="该树为空树。"><a href="#该树为空树。" class="headerlink" title="该树为空树。"></a>该树为空树。</h2><p>直接插入根结点的位置，违反性质2，把节点颜色有红改为黑即可。</p>
<h2 id="黑父"><a href="#黑父" class="headerlink" title="黑父"></a>黑父</h2><p>　　如图2所示，如果新点的父结点为黑色结点，那么插入一个红点将不会影响红黑树的平衡，此时插入操作完成。红黑树比AVL树优秀的地方之一在于黑父的情况比较常见，从而使红黑树需要旋转的几率相对AVL树来说会少一些。</p>
<center><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert2.jpg" alt="图2" title="图2"></center>


<h2 id="红父"><a href="#红父" class="headerlink" title="红父"></a>红父</h2><p>　　如图3所示，由于父结点为红色，此时可以判定，祖父结点必定为黑色。这时需要根据叔父结点的颜色来决定做什么样的操作。青色结点表示颜色未知。由于有可能需要根结点到新点的路径上进行多次旋转操作，而每次进行不平衡判断的起始点（<strong><em>我们可将其视为新点</em></strong>）都不一样。所以我们在此使用一个蓝色箭头指向这个起始点，并称之为判定点。<br>　　注：把一个树看成一个新的节点，继续进行旋转。这点很重要。</p>
<center><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert3.jpg" alt="insert3.jpg" title=""></center>


<h3 id="红叔"><a href="#红叔" class="headerlink" title="红叔"></a>红叔</h3><p>　　当叔父结点为红色时，如图4所示，无需进行旋转操作，只要将父和叔结点变为黑色，将祖父结点变为红色即可。但由于祖父结点的父结点有可能为红色，从而违反红黑树性质。此时必须将祖父结点作为新的判定点继续向上进行平衡操作。需要注意，无论“父”在“叔”的左边还是右边，无论“新”是“父”的左孩子还是右孩子，它们的操作都完全一样。</p>
<p><center><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert4.jpg" alt="insert4.jpg" title=""></center><br>　　注：如果祖父节点是根节点怎么办？答案是进行情景一的操作，把祖父节点变为黑色。</p>
<h3 id="黑叔"><a href="#黑叔" class="headerlink" title="黑叔"></a>黑叔</h3><p>情形1：<br><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert5.jpg" alt="insert5.jpg" title=""></p>
<p>情形2：<br><img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert6.jpg" alt="insert6.jpg" title=""></p>
<p>情形3：</p>
<img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert7.jpg" alt="insert7.jpg" title="">
<p>情形4：</p>
<img src="/2016/07/25/数据结构与算法/红黑树以及HashMap/insert8.jpg" alt="insert8.jpg" title="">
<p>　　可以观察到，当旋转完成后，新的旋转根全部为黑色，此时不需要再向上回溯进行平衡操作，插入操作完成。需要注意，上面四张图的“叔”、“1”、“2”、“3”结点有可能为黑哨兵结点。<br>　　其实红黑树的插入操作不是很难，甚至比AVL树的插入操作还更简单些。但删除操作就远远比AVL树复杂得多，下面就介绍红黑树的删除操作。
　　</p>
<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><p>主要讲解红黑树的平衡插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//LinkedHashMap.Entry&lt;K,V&gt;继承自HashMap.Node&lt;K,V&gt; </span></div><div class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; parent;<span class="comment">//parent阴阳记录父亲节点</span></div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; left;<span class="comment">//left、right其中一个记录叔叔节点</span></div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; right;</div><div class="line"></div><div class="line">     TreeNode&lt;K,V&gt; prev;  <span class="comment">// needed to unlink next upon deletion</span></div><div class="line"></div><div class="line">     <span class="keyword">boolean</span> red; <span class="comment">//记录节点的颜色</span></div><div class="line"></div><div class="line">     TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</div><div class="line"></div><div class="line">         <span class="keyword">super</span>(hash, key, val, next);</div><div class="line"></div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     <span class="comment">/**</span></div><div class="line"></div><div class="line">      * 将链表转化为红黑树</div><div class="line"></div><div class="line">      */</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</div><div class="line"></div><div class="line">         TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">         <span class="comment">//遍历链表,x代表需要插入的节点</span></div><div class="line"></div><div class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</div><div class="line"></div><div class="line">             next = (TreeNode&lt;K,V&gt;)x.next;</div><div class="line"></div><div class="line">             x.left = x.right = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">             <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="comment">//树为空直接插入节点，并且节点颜色变为黑色</span></div><div class="line"></div><div class="line">                 x.parent = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                 x.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                 root = x;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                 K k = x.key;</div><div class="line"></div><div class="line">                 <span class="keyword">int</span> h = x.hash;</div><div class="line"></div><div class="line">                 Class&lt;?&gt; kc = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                 <span class="comment">//查找新节点在红黑树上的位置</span></div><div class="line"></div><div class="line">                 <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</div><div class="line"></div><div class="line">                     <span class="comment">//dir记录向左走还是向右走 ph 记录当前节点的hash值</span></div><div class="line"></div><div class="line">                     <span class="keyword">int</span> dir, ph;</div><div class="line"></div><div class="line">                     K pk = p.key;</div><div class="line"></div><div class="line"></div><div class="line">                     <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line"></div><div class="line">                         dir = -<span class="number">1</span>;</div><div class="line"></div><div class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line"></div><div class="line">                         dir = <span class="number">1</span>;</div><div class="line"></div><div class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</div><div class="line"></div><div class="line">                               (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</div><div class="line"></div><div class="line">                              (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</div><div class="line"></div><div class="line">                         <span class="comment">//哈希值相等时比较Key的大小</span></div><div class="line"></div><div class="line">                         dir = tieBreakOrder(k, pk);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                     TreeNode&lt;K,V&gt; xp = p;</div><div class="line"></div><div class="line">                     <span class="comment">//如果下一步需要到达的位置是null，就可以安放新节点</span></div><div class="line"></div><div class="line">                     <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                         x.parent = xp;</div><div class="line"></div><div class="line">                         <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</div><div class="line"></div><div class="line">                             xp.left = x;</div><div class="line"></div><div class="line">                         <span class="keyword">else</span></div><div class="line"></div><div class="line">                             xp.right = x;</div><div class="line"></div><div class="line">                         <span class="comment">//插入红黑树，并且保证红黑树的特性不被破坏</span></div><div class="line"></div><div class="line">                         root = balanceInsertion(root, x);</div><div class="line"></div><div class="line">                         <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line">         moveRootToFront(tab, root);</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line"></div><div class="line">     <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></div><div class="line"></div><div class="line">                                                 TreeNode&lt;K,V&gt; x) &#123;</div><div class="line"></div><div class="line">         x.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">         <span class="comment">//xp表示x的父节点 xpp表示x的祖父节点 xppl、xppr表示x叔叔节点</span></div><div class="line"></div><div class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</div><div class="line"></div><div class="line">             <span class="comment">//根节点直接变为黑色</span></div><div class="line">             <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</div><div class="line">                 x.red = <span class="keyword">false</span>;</div><div class="line">                 </div><div class="line">                 <span class="keyword">return</span> x;</div><div class="line">                 </div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="comment">//父亲为红色或者父节点为根节点 直接插入红色新节点</span></div><div class="line"></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                 <span class="keyword">return</span> root;</div><div class="line"></div><div class="line">             <span class="comment">//父亲节点是左节点</span></div><div class="line"></div><div class="line">             <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//父亲节点和叔叔节点是红色，则叔叔和父亲变为黑色，祖父变为红色</span></div><div class="line"></div><div class="line">                 <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</div><div class="line"></div><div class="line">                     xppr.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                     x = xpp; <span class="comment">//祖父节点作为新节点，继续平衡之路</span></div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (x == xp.right) &#123;</div><div class="line"></div><div class="line">                         root = rotateLeft(root, x = xp);</div><div class="line"></div><div class="line">                         xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                         xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                         <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                             xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                             root = rotateRight(root, xpp);</div><div class="line"></div><div class="line">                         &#125;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="keyword">else</span> &#123; <span class="comment">//父亲节点是右节点</span></div><div class="line">             <span class="comment">//父亲节点和叔叔节点是红色，则叔叔和父亲变为黑色，祖父变为红色</span></div><div class="line"></div><div class="line">                 <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</div><div class="line"></div><div class="line">                     xppl.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                     xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                     x = xpp;<span class="comment">//祖父节点作为新节点，继续平衡之路</span></div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="keyword">else</span> &#123; <span class="comment">//父亲节点和叔叔节点是红色</span></div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (x == xp.left) &#123;</div><div class="line"></div><div class="line">                         root = rotateRight(root, x = xp);</div><div class="line"></div><div class="line">                         xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                         xp.red = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                         <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                             xpp.red = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                             root = rotateLeft(root, xpp);</div><div class="line"></div><div class="line">                         &#125;</div><div class="line"></div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line"></div><div class="line">             &#125;</div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashMap源码解读]]></title>
      <url>http://baobing.github.io/2016/07/25/Java%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="关于HashMap的疑问"><a href="#关于HashMap的疑问" class="headerlink" title="关于HashMap的疑问"></a>关于HashMap的疑问</h1><ul>
<li><p>HashMap底层的数据结构，怎样解决hash碰撞。</p>
</li>
<li><p>HashMap何时扩容，扩容的过程是怎样的              </p>
</li>
<li><p>红黑树是一种怎样的数据结构</p>
<a id="more"></a>
</li>
</ul>
<h1 id="JDK8-HashMap数据结构"><a href="#JDK8-HashMap数据结构" class="headerlink" title="JDK8 HashMap数据结构"></a>JDK8 HashMap数据结构</h1><center><img src="/2016/07/25/Java基础/HashMap源码解读/HashMap.png" alt="图1" title="图1"></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">       <span class="keyword">final</span> K key;</div><div class="line">       <span class="keyword">volatile</span> V val;</div><div class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</div><div class="line">      <span class="comment">//省略省略</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure>
<p>　　不难发现HashMap底层由数组、链表和红黑树三者组成。</p>
<h2 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h2><p>　　包含一个执行自身类型的引用next，显然Node类是组成链表的节点，next引用负责链接各个节点。</p>
<h2 id="table数组"><a href="#table数组" class="headerlink" title="table数组"></a>table数组</h2><p>　　Node类组成的数组，装载所有的键值对。table有以下几个特点:</p>
<ul>
<li>长度N一定为2的幂。即使指定初始长度，N一定是大于等于初始长度的2的幂（可以参考tableSizeFor函数）</li>
<li>table[i]包含的是hash&amp;(N-1)的Node节点。由于N为2的幂，hash&amp;(N-1)等价于hash%N。与运算的速度大大高于取余，这就是作者的高明之处。</li>
<li>延迟初始化，只用第一次在Map中放入元素时，才会调用这个分配空间。</li>
</ul>
<h2 id="链表和红黑树"><a href="#链表和红黑树" class="headerlink" title="链表和红黑树"></a>链表和红黑树</h2><p>　　多个元素hash&amp;(n-1)的值相同的情况称为hash碰撞。链表和红黑树这两种数据结构都是在发生hash碰撞时产生的结果。如果链表的长度大于8且table长度大于64，链表被转化为红黑树。如果红黑树的节点数量小于6，则转化为链表。 </p>
<h1 id="HashMap重要字段"><a href="#HashMap重要字段" class="headerlink" title="HashMap重要字段"></a>HashMap重要字段</h1><ul>
<li><p>Node<k,v>[] table，文章已经提到不再赘述</k,v></p>
</li>
<li><p>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4。HashMap默认初始大小为16</p>
</li>
<li><p>DEFAULT_LOAD_FACTOR = 0.75f。默认负载因子是0.75，也就是说table数组有75%非空时进行扩容。</p>
</li>
<li><p>size：记录Map中键值对个数。</p>
</li>
<li><p>threshold：记录下一次扩容的阈值。threshold = loadFactor * table.length.</p>
</li>
</ul>
<h1 id="重要的函数"><a href="#重要的函数" class="headerlink" title="重要的函数"></a>重要的函数</h1><h2 id="get操作实现函数getNode"><a href="#get操作实现函数getNode" class="headerlink" title="get操作实现函数getNode"></a>get操作实现函数getNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line"></div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line"></div><div class="line">        <span class="comment">//延迟初始化导致table可能为空</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line"></div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//hash对应table数组位置的头元素key等于查找key，直接返回头节点</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line"></div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                <span class="keyword">return</span> first;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;  </div><div class="line"></div><div class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)   <span class="comment">//头元素是一棵红黑树</span></div><div class="line"></div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line"></div><div class="line">                do &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; <span class="comment">//遍历链表直到找到hash相等 key相等的元素</span></div><div class="line"></div><div class="line">                         ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line"></div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="put操作实现函数putVal"><a href="#put操作实现函数putVal" class="headerlink" title="put操作实现函数putVal"></a>put操作实现函数putVal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"></div><div class="line">                   <span class="keyword">boolean</span> evict) &#123;</div><div class="line"></div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="comment">//第一次执行put操作时初始化table</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) </div><div class="line"></div><div class="line">            n = (tab = resize()).length;</div><div class="line"></div><div class="line">        <span class="comment">//节点填充的位置为null，直接放入新的Node节点</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;  <span class="comment">//key已经在Map中出现，直接覆盖原数字</span></div><div class="line"></div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                e = p;</div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//p是一棵红黑树</span></div><div class="line"></div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line"></div><div class="line">            <span class="keyword">else</span> &#123;               <span class="comment">//p是一个链表，将元素放置到链表末尾</span></div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">// 链表长度大于等于8，链表转化为红黑树</span></div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</div><div class="line">                            treeifyBin(tab, hash);</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    &#125;              </div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;     <span class="comment">// 相同key在链表中存在，覆盖原来节点</span></div><div class="line"></div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    p = e;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line"></div><div class="line">                V oldValue = e.value;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                    e.value = value;</div><div class="line"></div><div class="line">                afterNodeAccess(e);</div><div class="line"></div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//table数组有一个位置被占用，判断是否扩容</span></div><div class="line"></div><div class="line">        ++modCount;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line"></div><div class="line">            resize();</div><div class="line"></div><div class="line">        afterNodeInsertion(evict);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="扩容函数resize"><a href="#扩容函数resize" class="headerlink" title="扩容函数resize"></a>扩容函数resize</h2><p>1）获取新数组newTab的长度，为newTab申请空间。需要考虑容量最大边界，延迟初始化等问题。</p>
<p>2）将原数组oldTab中的节点，放入newTab中。链表和红黑树拆解问题。数组容量是2的幂，所以拆解过程很有技巧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line"></div><div class="line">        Node&lt;K,V&gt;[] oldTab = table;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldThr = threshold;  <span class="comment">//原数组阈值</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//分别记录新table容量 和 新的阈值</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line"></div><div class="line">                threshold = Integer.MAX_VALUE;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> oldTab;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line"></div><div class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line"></div><div class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// Map设置初始容量,threshold为table初始容量</span></div><div class="line"></div><div class="line">            newCap = oldThr;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line"></div><div class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line"></div><div class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">//设置初始容量时，计算新的阈值</span></div><div class="line"></div><div class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line"></div><div class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line"></div><div class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        threshold = newThr;</div><div class="line"></div><div class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line"></div><div class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line"></div><div class="line">        table = newTab;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;   <span class="comment">//遍历原始table</span></div><div class="line"></div><div class="line">                Node&lt;K,V&gt; e;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                    oldTab[j] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)    <span class="comment">// 不存在hash碰撞，只有一个节点</span></div><div class="line"></div><div class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line"></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  <span class="comment">// 红黑树</span></div><div class="line"></div><div class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line"></div><div class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    <span class="comment">//将链表分为两个链表，分割依据看下面代码</span></div><div class="line"></div><div class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; </div><div class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                        Node&lt;K,V&gt; next;</div><div class="line"></div><div class="line">                        do &#123;</div><div class="line"></div><div class="line">                            next = e.next;</div><div class="line">                            </div><div class="line"></div><div class="line"><span class="comment">/* table的capcity一定是2的幂。e.hash &amp; oldCap 结果 r只可能等于0或者oldCap</span></div><div class="line"> e.hash &amp; oldCap == 0 时，e.hash &amp; (oldCap-1) == e.hash &amp; (newCap-1)</div><div class="line">e.hash &amp; oldCap == oldCap 时,e.hash &amp; (oldCap-1)+oldCap ==e.hash&amp;(newCap-1)*/</div><div class="line"></div><div class="line"></div><div class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; </div><div class="line"></div><div class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                                    loHead = e;</div><div class="line"></div><div class="line">                                <span class="keyword">else</span></div><div class="line"></div><div class="line">                                    loTail.next = e;</div><div class="line"></div><div class="line">                                loTail = e;</div><div class="line"></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line"></div><div class="line">                                    hiHead = e;</div><div class="line"></div><div class="line">                                <span class="keyword">else</span></div><div class="line"></div><div class="line">                                    hiTail.next = e;</div><div class="line"></div><div class="line">                                hiTail = e;</div><div class="line"></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                            loTail.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                            newTab[j] = loHead;</div><div class="line"></div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                            hiTail.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                            newTab[j + oldCap] = hiHead;</div><div class="line"></div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> newTab;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组中第k大的数字]]></title>
      <url>http://baobing.github.io/2016/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>从给定长度的整数数组中，选取第K大的数字。要求时间复杂度为O(N).<br><a id="more"></a></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>1）需要查找的数组a，选取其中一个数字a<a href="start&lt;=i&lt;=end">i</a>作为Key<br>2) 小于Key的数字放在Key左侧<br>3）大于等于Key的数字放在Key右侧<br>4）如果Key的下标keyIndex等于K，返回Key；<br>5）如果keyIndex 小于K，end = keyIndex - 1，重复1）<br>6）如果keyIndex 大于K，start = keyIndex + 1，重复1）</p>
<p>　　这种求解方法是快速排序的思路演化而来。<br>　　个人想到的一个将元素依据大小放置在Key左右的方法。<br>　　使用两个辅助数组，一个保存大于Key的元素，一个保存小于Key的元素。将小于Key的元素放置在头部，将小于Key的元素放于尾部。将剩余的空间放置Key。<br>　　优点：可以得到于Key相同的所有元素，对于相同元素多的数组可以加快速度<br>　　缺点：耗时，需要辅助空间</p>
<h1 id="衍生问题"><a href="#衍生问题" class="headerlink" title="衍生问题"></a>衍生问题</h1><ul>
<li>给定整数数组中，求前K大的所有数字</li>
<li>给定整数数组中，某个的数字出现次数超过数组长度一半，找到这个数字。</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> acm;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by hubaobin on 16/7/24.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kth</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> start 开始的下标</div><div class="line">     * <span class="doctag">@param</span> end 结束的下标</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> first = start;</div><div class="line">        <span class="keyword">int</span> last = end;</div><div class="line">        <span class="comment">//选取第一个数字作为key,建议还是随机选取避免选取数字过小或者过大</span></div><div class="line">        <span class="keyword">int</span> key = a[first];</div><div class="line">        <span class="comment">//将小于key的值放在key左侧,大于等于key的值放在右侧</span></div><div class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</div><div class="line">            <span class="comment">//一定要先从后到前扫描</span></div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; a[last] &gt;= key) last--;</div><div class="line">            a[first] = a[last];</div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; a[first] &lt;= key) first++;</div><div class="line">            a[last] = a[first];</div><div class="line">        &#125;</div><div class="line">        a[first] = key;</div><div class="line">        <span class="keyword">if</span> (first == k) <span class="keyword">return</span> a[first];</div><div class="line">        <span class="keyword">if</span> (first &gt; k) <span class="keyword">return</span> getKth(a, k, start, first - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> getKth(a, k, first + <span class="number">1</span>, end);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>&#125;;</div><div class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> k;</div><div class="line">        <span class="keyword">while</span> ((k = scanner.nextInt()) != -<span class="number">1</span>) &#123;</div><div class="line">            System.out.println(getKth(a, k - <span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快速幂原理解析]]></title>
      <url>http://baobing.github.io/2016/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>求n的m次方，时间复杂度O(log(N)).不考虑大数情况。<br><a id="more"></a></p>
<h1 id="解决方法：快速幂"><a href="#解决方法：快速幂" class="headerlink" title="解决方法：快速幂"></a>解决方法：快速幂</h1><h2 id="求解方法和步骤"><a href="#求解方法和步骤" class="headerlink" title="求解方法和步骤"></a>求解方法和步骤</h2><p>1）假设n=3,m=10</p>
<p>2）将m转化为二进制为t=1010,数组形式为a={1,0,1,0}，a[i]表示m的第i位上的二进制数组。</p>
<p>3）f[i]表示m的前i个二进制数字的十进制形式。我们可以得到<strong><em> f[i+1] = (f[i]+a[i] )</em>2 *</strong> ，如：10 =((((1+0)<em>2+1)</em>2+0)<em>2+1)</em>2 。</p>
<p>4）2^3^4 = (2^3)^4 ，2^(1+2) = 2^2<em>2 ,由上面两条定理可以推得 g[i+1] = (g[i] </em>(n^a[i]))^2 。</p>
<p>其中g[i]表示 n^f[i]。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">package</span> acm;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/22.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickPower</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPower</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不能同时为0"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((m &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">                result *= n;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            result *= result;</div><div class="line"></div><div class="line">            m &gt;&gt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        System.out.println(getPower(<span class="number">2</span>, <span class="number">10</span>));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快排、递归、堆和基数四种排序方法]]></title>
      <url>http://baobing.github.io/2016/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9B%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>接下来文章将会讲述四种排序算法的实现和可行性证明。<strong><em>只有证明一个算法的正确性，才算理解一种算法。</em></strong><br><a id="more"></a></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1)从需要排序的数组选中一个作为Key，比Key小的放在右边，比Key大的放在左边。</p>
<p>2 )Key右侧的元素重复步骤1)</p>
<p>3)Key右侧的元素重复步骤1)</p>
<p>观察源码即可找到实现步骤一效果的方法。</p>
<h2 id="可行性证明"><a href="#可行性证明" class="headerlink" title="可行性证明"></a>可行性证明</h2><p>题设</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1)每次排序选中Key的左侧小于等于Key </div><div class="line"></div><div class="line">2)每次排序选中Key的右侧大于等于Key</div><div class="line"></div><div class="line">3)需要排序数组长度为2或3时，数据一定是升序</div></pre></td></tr></table></figure>
<p>假设数组为 a[] ，Key的下标为k，数组范围为0-n。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1)当 0&lt;=i&lt;k 时，a[i] &lt;=a[k] &amp;&amp; a[i]&lt;= a[i+1].</div><div class="line"></div><div class="line">2)当 k&lt;j&lt;=n 时，a[j] &gt;=a[k] &amp;&amp; a[j]&gt;= a[j-1].</div><div class="line"></div><div class="line">3)结合1)、2)可以推导出：当 0&lt;=l&lt;n , a[i]&lt;a[i+1]，即排序结果有序</div></pre></td></tr></table></figure>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><ul>
<li><p>优点:空间复杂度为 O(N) </p>
</li>
<li><p>缺点:时间复杂度O(Nlog(N))，但是不稳定。Key的选择很关键，选不好复杂度就会变为N的平方。</p>
</li>
<li><p>优化方法：选择数组头部中间尾部，三个元素中间值作为Key。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by baobing on 16/7/15.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        sort(<span class="number">0</span>, list.length-<span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> key = list[low];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> first = low;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> last = high;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//一定要从后往前先</span></div><div class="line"></div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; list[last] &gt;= key) &#123;</div><div class="line"></div><div class="line">                last--;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            list[first] = list[last];</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; list[first] &lt;= key) &#123;</div><div class="line"></div><div class="line">                first++;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            list[last] = list[first];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        list[first] = key;</div><div class="line"></div><div class="line">        sort(low, first - <span class="number">1</span>);</div><div class="line"></div><div class="line">        sort(first + <span class="number">1</span>, high);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        QuickSort q = <span class="keyword">new</span> QuickSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>1）将数组分为两个大小相同的数组（有可能大小相差1），继续分割数组，直到数组大小为1.</p>
<p>2）现在从同一个数组分割来的两个数组都为升序，将两个数组合并为一个升序的数组。</p>
<p>3）重复步骤 2）直到整个数组被合并</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>典型的分治算法。通过子序列的有序性，保证自身的有序性。</p>
<h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><ul>
<li><p>优点：时间复杂度为O(Nlog(N)) 并且极其稳定</p>
</li>
<li><p>缺点：空间复杂度为O(2N)),比较节省空间的场合不适用，尤其是比较大的数组</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/16.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span>[] list;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 合并两个有序的数组</div><div class="line"></div><div class="line">     * 第一个数组的起始下标为low 终止下标为mid</div><div class="line"></div><div class="line">     * 第二个数组的起始下标为mid+1 终止下标为high</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//用于保存两个数组合并结果</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="comment">//第一个数组的始末下标</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> first1 = low, end1 = mid;</div><div class="line"></div><div class="line">        <span class="comment">//第二个数组的始末下标</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> first2 = mid + <span class="number">1</span>, end2 = high;</div><div class="line"></div><div class="line">        <span class="comment">//记录临时数组的下标</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first1 &lt;= end1 &amp;&amp; first2 &lt;= end2) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (list[first1] &lt; list[first2]) &#123;</div><div class="line"></div><div class="line">                temp[k++] = list[first1++];</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                temp[k++] = list[first2++];</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//第一个数组的剩余元素放入临时数组</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first1 &lt;= end1) &#123;</div><div class="line"></div><div class="line">            temp[k++] = list[first1++];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//第二个数组的剩余元素放入临时数组</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (first2 &lt;= end2) &#123;</div><div class="line"></div><div class="line">            temp[k++] = list[first2++];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//排序好的临时数组覆盖原数组</span></div><div class="line"></div><div class="line">        System.arraycopy(temp, <span class="number">0</span>, list, low, temp.length);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 排序数组</div><div class="line"></div><div class="line">     *</div><div class="line"></div><div class="line">     * <span class="doctag">@param</span> low  起始下标</div><div class="line"></div><div class="line">     * <span class="doctag">@param</span> high 末尾下标</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">        sort(low, mid);</div><div class="line"></div><div class="line">        sort(mid + <span class="number">1</span>, high);</div><div class="line"></div><div class="line">        merge(low, mid, high);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        sort(<span class="number">0</span>, list.length - <span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        MergeSort q = <span class="keyword">new</span> MergeSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>最大堆：完全二叉树，所有根节点的子节点小于等于本身</li>
</ul>
<p>1）N个节点的树，构建为最大堆。</p>
<p>2）根节点与树最后一个叶子节点交换。</p>
<p>3）除去尾部的交换节点之后的树，构造为最大堆</p>
<p>4）重负步骤2）</p>
<h2 id="优点缺点-1"><a href="#优点缺点-1" class="headerlink" title="优点缺点"></a>优点缺点</h2><ul>
<li><p>优点 复杂度O(Nlog(N)) 空间复杂度为O(N)</p>
</li>
<li><p>缺点 构建最大堆浪费不少时间</p>
</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/16.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        buildMaxHeapify();</div><div class="line"></div><div class="line">        <span class="comment">//末尾与头交换，交换后调整最大堆</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line"></div><div class="line">            swap(<span class="number">0</span>, i);</div><div class="line"></div><div class="line">            maxHeapify(i, <span class="number">0</span>);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeapify</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//没有子节点的才需要创建最大堆，从最后一个的父节点开始</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> startIndex = getParentIndex(list.length - <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">//从尾端开始创建最大堆，每次都是正确的堆</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line"></div><div class="line">            maxHeapify(list.length, i);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 创建最大堆</div><div class="line"></div><div class="line">     *</div><div class="line"></div><div class="line">     * <span class="doctag">@paramheapSize</span>需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了</div><div class="line"></div><div class="line">     * <span class="doctag">@paramindex</span>当前需要创建最大堆的位置</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//当前点与左右子节点比较</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = getChildLeftIndex(index);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> right = getChildRightIndex(index);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">int</span> largest = index;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; list[index] &lt; list[left]) &#123;</div><div class="line"></div><div class="line">            largest = left;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; list[largest] &lt; list[right]) &#123;</div><div class="line"></div><div class="line">            largest = right;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (largest != index) &#123;</div><div class="line"></div><div class="line">            swap(index, largest);</div><div class="line"></div><div class="line">            maxHeapify(heapSize, largest);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> temp = list[a];</div><div class="line"></div><div class="line">        list[a] = list[b];</div><div class="line"></div><div class="line">        list[b] = temp;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 父节点位置</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 左子节点position注意括号，加法优先级更高</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildLeftIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 右子节点position</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildRightIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        HeapSort q = <span class="keyword">new</span> HeapSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h2><p>1）将需要排序的数组list中的数字根据他们的个位数字i放到对应的数组bucket[i]的末尾。</p>
<p>2）从0-9依次将bucket中的数字放置到需要排序的数组list。</p>
<p>3）接下来是十位、百位，重复类似步骤1），指导数组list中的所有元素该位置都没有数字。</p>
<h2 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>优点：</p>
<ul>
<li><p>时间复杂度低O(Mlog(N)).（N为排序数字个数M为最大位）对于N大M小的情况尤为突出。</p>
</li>
<li><p>可以实现相同大小的数字，依旧保持先后顺序</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>辅助空间需求要求比较大</p>
</li>
<li><p>M大N小时，性能下降</p>
</li>
<li><p>试用的排序类型比较少，整数最适合</p>
</li>
</ul>
<p>缺点</p>
<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by hubaobin on 16/7/17.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> list[];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> <span class="comment">//d表示最大的数有多少位</span></span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">//bucket[i]用来装载需要排序的位等于i的数字</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][list.length];</div><div class="line"></div><div class="line">        <span class="comment">//idxArr[i] 表示bucket[i]填充数据个数</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] idxArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) idxArr[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> isContinue = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">//将数组放入bucket</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> divRes = list[i] / n;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (divRes &gt;= <span class="number">10</span>) isContinue = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> lsd = (divRes % <span class="number">10</span>);</div><div class="line"></div><div class="line">                bucket[lsd][idxArr[lsd]++] = list[i];</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//bucket中的数字放回原数组</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; idxArr[i]; j++) &#123;</div><div class="line"></div><div class="line">                    list[k++] = bucket[i][j];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                idxArr[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!isContinue) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            n *= <span class="number">10</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">10</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">23</span>&#125;;</div><div class="line"></div><div class="line">        RadixSort q = <span class="keyword">new</span> RadixSort(list);</div><div class="line"></div><div class="line">        q.sort();</div><div class="line"></div><div class="line">        System.out.println(Arrays.toString(list));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
